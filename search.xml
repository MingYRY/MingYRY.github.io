<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/mingyry/0.html"/>
      <url>/mingyry/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/mingyry/0.html"/>
      <url>/mingyry/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/mingyry/0.html"/>
      <url>/mingyry/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h1><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p><p>比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>那么我们至少从这样的描述中挖掘出几个要点：</p><ul><li>RPC是协议：既然是<strong>协议就只是一套规范</strong>，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。</li><li>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。</li><li>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li><li>应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814150822089.png" alt="image-20230814150822089"></p><h3 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h3><p>在分布式系统中，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用交互，以此来完成完整的业务功能。</p><p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求</p><p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。</p><h3 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h3><ul><li>Thrift：thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。</li><li>gRPC：一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</li><li>Dubbo：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。</li><li>Spring Cloud：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。</li></ul><h3 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h3><h4 id="RPC调用流程"><a href="#RPC调用流程" class="headerlink" title="RPC调用流程"></a>RPC调用流程</h4><p>要让网络通信细节对使用者透明，我们需要对通信细节进行封装，我们先看下一个RPC调用的流程涉及到哪些通信细节：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814151008556.png" alt="image-20230814151008556"></p><ol><li>服务消费方（client）调用以本地调用方式调用服务；</li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。</p><p>下面是网上的另外一幅图，感觉一目了然：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814151102780.png" alt="image-20230814151102780"></p><h4 id="如何做到透明化远程服务调用"><a href="#如何做到透明化远程服务调用" class="headerlink" title="如何做到透明化远程服务调用"></a>如何做到透明化远程服务调用</h4><p>怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？</p><p>对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码维护不易，大部分公司实现RPC框架时还是选择动态代理方式。</p><p>下面简单介绍下动态代理怎么实现我们的需求。我们需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello(“test”)方法时就会调用invoke方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RPCProxyClient</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RPCProxyClient</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到被代理对象;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(obj.getClass().getClassLoader(),</span><br><span class="line">                obj.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">RPCProxyClient</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用此方法执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//结果参数;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// ...执行通信相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;         </span><br><span class="line">     <span class="type">HelloWorldService</span> <span class="variable">helloWorldService</span> <span class="operator">=</span> (HelloWorldService)RPCProxyClient.getProxy(HelloWorldService.class);</span><br><span class="line">     helloWorldService.sayHello(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实就是通过动态代理模式，在执行该方法的前后对数据进行封装和解码等，让用于感觉就像是直接调用该方法一样，殊不知，我们对方法前后都经过了复杂的处理。</p></blockquote><h4 id="如何对消息进行编码和解码"><a href="#如何对消息进行编码和解码" class="headerlink" title="如何对消息进行编码和解码"></a>如何对消息进行编码和解码</h4><h5 id="确定消息数据结构"><a href="#确定消息数据结构" class="headerlink" title="确定消息数据结构"></a>确定消息数据结构</h5><p>客户端的请求消息结构一般需要包括以下内容：</p><ul><li>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</li><li>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</li><li>参数类型&amp;参数值：参数类型有很多，比如有bool、int、long、double、string、map、list，甚至如struct等，以及相应的参数值；</li><li>超时时间 + requestID（标识唯一请求id）</li></ul><p>服务端返回的消息结构一般包括以下内容：</p><ul><li>状态code + 返回值</li><li>requestID</li></ul><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>一旦确定了消息的数据结构后，下一步就是要考虑序列化与反序列化了。</p><p>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p><p>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p>为什么需要序列化？转换为二进制串后才好进行网络传输。</p><p>为什么需要反序列化？将二进制转换为对象才好进行后续处理。</p><p>现如今序列化的方案越来越多，每种序列化方案都有优点和缺点，它们在设计之初有自己独特的应用场景，那到底选择哪种呢？从RPC的角度上看，主要看三点：</p><ul><li>通用性：比如是否能支持Map等复杂的数据结构；</li><li>性能：包括时间复杂度和空间复杂度，由于RPC框架将会被公司几乎所有服务使用，如果序列化上能节约一点时间，对整个公司的收益都将非常可观，同理如果序列化上能节约一点内存，网络带宽也能省下不少；</li><li>可扩展性：对互联网公司而言，业务变化飞快，如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</li></ul><p>目前互联网公司广泛使用<strong>Protobuf</strong>、Thrift、Avro等成熟的序列化解决方案来搭建RPC框架，这些都是久经考验的解决方案。</p><blockquote><p>消息里为什么要有requestID？</p><p>当在分布式系统中进行消息传递时，引入 Request ID（请求标识符）可以带来很多好处：</p><ol><li><strong>请求追踪：</strong> 在分布式系统中，一个请求可能需要经过多个不同的服务或组件处理。通过在消息中包含唯一的 Request ID，可以跟踪整个请求的路径，从而方便排查问题、分析性能，以及理解系统中各个组件之间的交互。</li><li><strong>日志关联：</strong> 在日志中加入 Request ID 可以帮助快速筛选出特定请求的日志，使得分析和调试变得更加容易。不同的请求使用不同的 Request ID，可以有效区分日志。</li><li><strong>错误排查：</strong> 当在系统中发生问题时，能够追溯问题请求的具体路径，从而更快地定位问题所在。如果所有的组件都将 Request ID 记录在日志中，可以帮助定位问题的根本原因。</li><li><strong>性能分析：</strong> 通过记录请求的处理时间、各个阶段的耗时等信息，可以进行性能分析，找出系统中的瓶颈。</li><li><strong>业务分析：</strong> 在分布式系统中，不同的请求可能涉及不同的业务流程。通过分析不同 Request ID 的请求路径，可以更好地理解业务流程的执行情况。</li></ol></blockquote><h4 id="如何发布自己的服务"><a href="#如何发布自己的服务" class="headerlink" title="如何发布自己的服务"></a>如何发布自己的服务</h4><p>Java常用zookeeper，服务端进行注册和心跳，客户端获取机器列表，比如zookeeper：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/642e926ac5b3402c9dc4391b9417332b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom: 25%;" /></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;mid=2247486405&amp;idx=1&amp;sn=e03722a78de27f7aacea2189461b1848&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;mid=2247486405&amp;idx=1&amp;sn=e03722a78de27f7aacea2189461b1848&amp;scene=21#wechat_redirect</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统设计+场景题</title>
      <link href="/mingyry/7bbc4099.html"/>
      <url>/mingyry/7bbc4099.html</url>
      
        <content type="html"><![CDATA[<h1 id="系统设计-场景题"><a href="#系统设计-场景题" class="headerlink" title="系统设计+场景题"></a>系统设计+场景题</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="多线程实战"><a href="#多线程实战" class="headerlink" title="多线程实战"></a>多线程实战</h3><h4 id="两个线程交替打印奇偶数"><a href="#两个线程交替打印奇偶数" class="headerlink" title="两个线程交替打印奇偶数"></a>两个线程交替打印奇偶数</h4><h5 id="使用信号量Semaphore"><a href="#使用信号量Semaphore" class="headerlink" title="使用信号量Semaphore"></a>使用信号量Semaphore</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">even</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOdd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                odd.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;奇数&quot;</span> + i);</span><br><span class="line">            even.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                even.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;偶数&quot;</span> + i);</span><br><span class="line">            odd.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">PrintNum</span> <span class="variable">printNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNum</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            printNum.printOdd();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            printNum.printEven();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Lock加上Condition"><a href="#使用Lock加上Condition" class="headerlink" title="使用Lock加上Condition"></a>使用Lock加上Condition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumOpt</span> <span class="variable">printNumOpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumOpt</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumOpt.print0()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumOpt.print1()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumOpt</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 偶数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition0</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 奇数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.opt == <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; num &lt; maxNum; num++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;偶数：&quot;</span> + num);</span><br><span class="line">                        <span class="built_in">this</span>.opt = <span class="number">1</span>;</span><br><span class="line">                        condition1.signal();</span><br><span class="line">                        condition0.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.opt == <span class="number">1</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (; num &lt; maxNum; num++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;奇数：&quot;</span> + num);</span><br><span class="line">                        <span class="built_in">this</span>.opt = <span class="number">0</span>;</span><br><span class="line">                        condition0.signal();</span><br><span class="line">                        condition1.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印ABCABCABC"><a href="#打印ABCABCABC" class="headerlink" title="打印ABCABCABC"></a>打印ABCABCABC</h4><h5 id="Lock-Condition"><a href="#Lock-Condition" class="headerlink" title="Lock+Condition"></a><strong>Lock+Condition</strong></h5><p>该思路和synchronized+wait/notify方法的很像，synchronized对应lock，await/signal方法对应wait/notify方法。下面的代码为了能精准地唤醒下一个线程，创建了多个Condition对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionABC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(<span class="type">int</span> targetNum, Condition currentThread, Condition nextThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123;</span><br><span class="line">                    currentThread.await();  <span class="comment">//阻塞当前线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.signal();    <span class="comment">//唤醒下一个线程，而不是唤醒所有线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockConditionABC</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockConditionABC</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">0</span>, c1, c2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">1</span>, c2, c3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printABC(<span class="number">2</span>, c3, c1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h5><p>Semaphore：用来控制同时访问某个特定资源的操作数量，或者同时执行某个制定操作的数量。Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。</p><p>一个线程要访问共享资源，先使用<code>acquire()</code>方法获得信号量，如果信号量的计数器值大于等于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。</p><p>当某个线程使用完共享资源后，使用<code>release()</code>释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreABC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">//因为先执行线程A，所以这里设s1的计数器为1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(Semaphore currentThread, Semaphore nextThread)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentThread.acquire();       <span class="comment">//阻塞当前线程，即信号量的计数器减1为0</span></span><br><span class="line">                System.out.print(Thread.currentThread().getName());</span><br><span class="line">                nextThread.release();          <span class="comment">//唤醒下一个线程，即信号量的计数器加1</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SemaphoreABC</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SemaphoreABC</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s1, s2);</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s2, s3);</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            printer.printABC(s3, s1);</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCABCABCABCABCABCABCABCABCABC</span><br></pre></td></tr></table></figure><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><h5 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a><strong>容器类</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//表示生产者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//表示消费者线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Container</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (list.size() == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;the list is empty........&quot;</span>);</span><br><span class="line">                   notEmpty.await();<span class="comment">//阻塞消费者线程</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;consumer--&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;--take:&quot;</span> + val+<span class="string">&quot;===size:&quot;</span>+list.size());</span><br><span class="line"></span><br><span class="line">           notFull.signalAll();<span class="comment">//唤醒所有生产者线程</span></span><br><span class="line">           <span class="keyword">return</span> val;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Integer val)</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (list.size() == capacity)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;the list is full........&quot;</span>);</span><br><span class="line"></span><br><span class="line">                   notFull.await();<span class="comment">//阻塞生产者线程</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           list.add(val);</span><br><span class="line">           System.out.println(<span class="string">&quot;producer--&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;--put:&quot;</span> + val+<span class="string">&quot;===size:&quot;</span>+ list.size());</span><br><span class="line"></span><br><span class="line">           notEmpty.signalAll();<span class="comment">//唤醒所有消费者线程</span></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a><strong>生产者</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            container.put(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a><strong>消费者</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> container.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a><strong>测试类</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Container</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(container));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        producer3.start();</span><br><span class="line">        producer4.start();</span><br><span class="line">        producer5.start();</span><br><span class="line"></span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">the list is empty........</span><br><span class="line">producer--Thread-<span class="number">3</span>--put:<span class="number">77</span>===size:<span class="number">1</span></span><br><span class="line">consumer--Thread-<span class="number">6</span>--take:<span class="number">77</span>===size:<span class="number">0</span></span><br><span class="line">the list is empty........</span><br><span class="line">producer--Thread-<span class="number">4</span>--put:<span class="number">55</span>===size:<span class="number">1</span></span><br><span class="line">producer--Thread-<span class="number">0</span>--put:<span class="number">62</span>===size:<span class="number">2</span></span><br><span class="line">producer--Thread-<span class="number">1</span>--put:<span class="number">90</span>===size:<span class="number">3</span></span><br><span class="line">producer--Thread-<span class="number">2</span>--put:<span class="number">57</span>===size:<span class="number">4</span></span><br><span class="line">consumer--Thread-<span class="number">5</span>--take:<span class="number">55</span>===size:<span class="number">3</span></span><br><span class="line">consumer--Thread-<span class="number">5</span>--take:<span class="number">62</span>===size:<span class="number">2</span></span><br><span class="line">consumer--Thread-<span class="number">5</span>--take:<span class="number">90</span>===size:<span class="number">1</span></span><br><span class="line">consumer--Thread-<span class="number">5</span>--take:<span class="number">57</span>===size:<span class="number">0</span></span><br><span class="line">the list is empty........</span><br><span class="line">the list is empty........</span><br><span class="line">producer--Thread-<span class="number">0</span>--put:<span class="number">10</span>===size:<span class="number">1</span></span><br><span class="line">producer--Thread-<span class="number">1</span>--put:<span class="number">21</span>===size:<span class="number">2</span></span><br><span class="line">producer--Thread-<span class="number">3</span>--put:<span class="number">3</span>===size:<span class="number">3</span></span><br><span class="line">producer--Thread-<span class="number">4</span>--put:<span class="number">75</span>===size:<span class="number">4</span></span><br><span class="line">producer--Thread-<span class="number">2</span>--put:<span class="number">94</span>===size:<span class="number">5</span></span><br><span class="line">consumer--Thread-<span class="number">5</span>--take:<span class="number">10</span>===size:<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="进行分布式计算"><a href="#进行分布式计算" class="headerlink" title="进行分布式计算"></a>进行分布式计算</h4><h5 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h5><p>加油业务，用户可以在app上通过当前位置和目标位置来查询地图路线以及路线途径的所有加油站，路线查询会调用高德地图提供的接口，途径油站则根据返回的路线信息进行查询，所以当用户输入起始位置和目标位置点击查询后会做以下几步操作：</p><ol><li>调用高德地图接口获取路线</li><li>根据高德地图返回的路线信息去查询途径的所有油站</li></ol><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>当用户输入的起始地和目标地距离很远时，那么途径油站的数量会很大，单独采取普通查询库的方式会很耗时，并且途径油站的数据必须是实时的，所以无法使用缓存来提高接口响应效率。第一步是调用高德地图API，也会存在一定的延迟。那么我们应该怎么优化呢？</p><p>为了降低接口耗时，提高用户体验，我们需要对接口实现进行优化，调用高德API我们无法优化，所以只能优化查询途径油站这部分。</p><h5 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h5><p>当油站过多时，一次查询会很耗时，所以我们可以考虑分批多线程并发的去查询，将一段很长的路线按照路径长度分成若干个条件，比如一段路径长达800km，我们可以将这800km的查询参数拆分成若干个距离较小的参数集合（ps:举例方便大家理解，实际路径规划查询都是根据经纬度、距离等多重参数进行查询的）。比如，{[0,50],[50,100],[100,150]…..[750,800]}，这时我们开启多个线程去并发的根据新的查询条件去查询，最后将结果拼接封装返回，从而达到降低查询时间的目的。</p><p>虽然思路很容易理解，但是实现起来有两个需要注意的地方，我列出来看看大家有没有考虑到。</p><ul><li>根据业务场景，这里不是单纯的异步查询就可以的，而是需要所有的线程都执行完后并且组合查询结果后进行返回，所以这里需要进行同步控制。这里我们使用jdk提供的CountDownLatch同步组件实现。</li><li>线程内操作需要有返回值，使用Callable接口以及FutureTask搭配实现。</li></ul><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>​    1. 通常来说，我们定义线程需要实现Runnable接口，但是对于需要返回值的线程，就需要线程实现Callable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Scope(&quot;protoType&quot;)</span> <span class="comment">// 这里需要注意Spring默认注入的Bean都是单例的，当前业务场景下肯定需要多个线程去执行查询操作，所以这里声明组件为protoType模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathPlanTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;List&lt;Object&gt;&gt; &#123;</span><br><span class="line"><span class="comment">// 查询参数</span></span><br><span class="line">    <span class="keyword">private</span> PathPlanPartQuery pathPlanPartQuery;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 业务查询</span></span><br><span class="line">            List&lt;Object&gt; result = queryList(pathPlanPartQuery);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 错误日志打印</span></span><br><span class="line">            log.error(<span class="string">&quot;query PathByGasstation error!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 类似 i-- 的操作，当减到0的时候，countDownLatch.await()就会放行，否则会一直阻塞。</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPathPlanPartQuery</span><span class="params">(PathPlanPartQuery pathPlanPartQuery)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.pathPlanPartQuery = pathPlanPartQuery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCountDownLatch</span><span class="params">(CountDownLatch countDownLatch)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">queryList</span><span class="params">(PathPlanPartQuery pathPlanPartQuery)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 具体查询逻辑，这里省略</span></span><br><span class="line">        <span class="keyword">return</span> Lists.newArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2. Callable通常和FutureTask搭配使用，通过FutureTask的get方法获取到线程的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常定义为工具类进行获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">8</span>, <span class="number">20</span>, <span class="number">1000</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">queryGasInfoBaseDtoList</span><span class="params">(List&lt;PathPlanQueryParam&gt; queryParamList)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stMills</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">     <span class="comment">// 定义线程池来进行多线程的管理，通过Util获取静态的线程池</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 定义countDownLatch，构造函数传递参数集合的size，该集合具体参数可以参考</span></span><br><span class="line">     <span class="comment">// 上面举的例子，&#123;[0,50],[50,100],[100,150]...[750,800]&#125;</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(queryParamList.size());</span><br><span class="line"><span class="comment">// 批量查询，定义FutureTask集合</span></span><br><span class="line">        List&lt;FutureTask&lt;List&lt;GasInfoBaseResponseDto&gt;&gt;&gt; futureTaskList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历查询参数集合</span></span><br><span class="line">            <span class="keyword">for</span> (PathPlanQueryParam queryParam : queryParamList) &#123;</span><br><span class="line">                <span class="comment">// 这里使用getBean方式获取。</span></span><br><span class="line">                <span class="type">PathPlanTask</span> <span class="variable">pathPlanTask</span> <span class="operator">=</span></span><br><span class="line">                    ApplicationContextProvider.getBean(<span class="string">&quot;pathPlanTask&quot;</span>, PathPlanTask.class);</span><br><span class="line">            <span class="comment">// 设置countDownLatch</span></span><br><span class="line">                pathPlanTask.setCountDown(countDownLatch);</span><br><span class="line">                <span class="comment">// 获取查询参数</span></span><br><span class="line">                <span class="type">PathPlanPartQuery</span> <span class="variable">pathPlanPartQuery</span> <span class="operator">=</span> getPathPlanPartQuery(queryParam);</span><br><span class="line">                pathPlanTask.setPathPlanPartQuery(pathPlanPartQuery);</span><br><span class="line">                <span class="comment">// 定义FutureTask，将定义好的Callable实现类作为构造参数</span></span><br><span class="line">                FutureTask&lt;List&lt;GasInfoBaseResponseDto&gt;&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(pathPlanTask);</span><br><span class="line">                <span class="comment">// 交给线程池去执行</span></span><br><span class="line">                poolExecutor.submit(futureTask);</span><br><span class="line">                <span class="comment">// 添加futureTask集合</span></span><br><span class="line">                futureTaskList.add(futureTask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里会一直进行阻塞，直到countDownLatch.countDown()方法将创建时传递的size参数减为0后放行。</span></span><br><span class="line">            <span class="comment">// 这块可以保证多个线程全部执行完后进行最终返回。</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 多个线程执行完后我们拼接最终结果</span></span><br><span class="line">            List&lt;Object&gt; gasInfoDtoList = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (FutureTask&lt;List&lt;Object&gt;&gt; futureTask : futureTaskList) &#123;</span><br><span class="line">                <span class="comment">// 通过futrueTask的get方法获取返回值，当线程还在执行未返回时执行futureTask.get()会被阻塞</span></span><br><span class="line">                List&lt;Object&gt; baseResponseDtoList = futureTask.get();</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(baseResponseDtoList)) &#123;</span><br><span class="line">                    gasInfoDtoList.addAll(baseResponseDtoList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gasInfoDtoList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;queryGasInfoBaseDtoList_err&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;queryGasInfoBaseDtoList_requestId:&#123;&#125;,batchTimes:&#123;&#125;,cost:&#123;&#125;&quot;</span>, pointRequestOld.getRequestId(),</span><br><span class="line">                pointRequestOld.getBatchTimes(), System.currentTimeMillis() - stMills);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总结下来就是通过线程池开启多个Callable线程去分批查询数据， 引入CountDownLatch组件来控制查询结束时机，而后利用FutureTask的get方法获取最终结果拼装返回。</p><h5 id="文章来源与作者"><a href="#文章来源与作者" class="headerlink" title="文章来源与作者"></a>文章来源与作者</h5><p>作者：森屿说<br>链接：<a href="https://juejin.cn/post/6903544822221504526">https://juejin.cn/post/6903544822221504526</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/mingyry/37cf2cfd.html"/>
      <url>/mingyry/37cf2cfd.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><ol><li>主从库建立连接、协商同步过程</li><li>主库将所有数据同步给从库：主库执行 bgsave命令，生成内存快照的RDB文件，发生给从库，从库接收到RDB后，先情况当前数据库，再加载RDB文件</li><li>主库发送新写命令给从库</li></ol><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>如果命令传播出现网络闪断，此使为了避免再次全量更新，采用增量复制的方式继续同步</p><p>repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以<strong>repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率</strong>。</p><p>进行主从复制时，需要在主服务器上开启持久化，如果不能持久化，那么需要避免实例自动重启</p><h3 id="为什么主从复制使用RDB而不是AOF"><a href="#为什么主从复制使用RDB而不是AOF" class="headerlink" title="为什么主从复制使用RDB而不是AOF"></a>为什么主从复制使用RDB而不是AOF</h3><ul><li>RDB文件比AOF文件小，传输RDB文件更节省带宽</li><li>使用RDB还原数据的速度高于AOF</li></ul><h3 id="数据过期问题"><a href="#数据过期问题" class="headerlink" title="数据过期问题"></a>数据过期问题</h3><p>在主从复制的场景下，在Redis3.2版本之前，从节点不会删除数据，有可能返回过期的数据。Redis3.2版本之后，客户端读从库，会先判断数据是否过期，如果过期，就会删除并且返回空值</p><h2 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h2><h3 id="什么是Sentinel"><a href="#什么是Sentinel" class="headerlink" title="什么是Sentinel"></a>什么是Sentinel</h3><p>是Redis的一种运行模式，默认运行在26379端口上，依赖Redis工作。目的是实现Redis集群的高可用性，帮助我们监控Redis节点的运行状态并自动实现故障转移</p><h3 id="Sentinel的作用"><a href="#Sentinel的作用" class="headerlink" title="Sentinel的作用"></a>Sentinel的作用</h3><ul><li>监控：监控所有的redis节点（包括sentinel节点本身）</li><li>故障转移：如果一个master节点出现故障，哨兵会自动将一台slave升级为master，确保整个Redis系统的可用性</li><li>通知：通知slave新的 master连接信息，让它们执行 replicaof成为新的master的slave</li><li>配置提供：客户端连接sentinel请求master的地址，如果发生故障转移，sentinel会通知新的master 链接信息给客户端。</li></ul><p><strong>如果要实现高可用，建议将哨兵配置成单数并且大于等于三台</strong></p><h3 id="Sentinel如何检测节点是否下线"><a href="#Sentinel如何检测节点是否下线" class="headerlink" title="Sentinel如何检测节点是否下线"></a>Sentinel如何检测节点是否下线</h3><p>有两种下线：</p><ul><li>主观下线：sentinel 认为某个节点已经下线，通知其他sentinel节点，其他节点开始投票</li><li>客观下线：如果超过<code>quorum</code> 配置项的数目的sentinel 认为该节点下线，则该redis 节点客观下线</li></ul><h3 id="Sentinel如何选出新的master？"><a href="#Sentinel如何选出新的master？" class="headerlink" title="Sentinel如何选出新的master？"></a>Sentinel如何选出新的master？</h3><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的，salve-priority`的值越小，优先级越高</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><h3 id="Sentinel如何选出leader"><a href="#Sentinel如何选出leader" class="headerlink" title="Sentinel如何选出leader"></a>Sentinel如何选出leader</h3><p>判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。</p><p>哨兵的选举机制其实很简单，就是一个Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong></p><ul><li>任何一个想成为 Leader 的哨兵，要满足两个条件：<ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul></li></ul><h2 id="Redis分片"><a href="#Redis分片" class="headerlink" title="Redis分片"></a>Redis分片</h2><h3 id="为什么需要Redis-Cluster？"><a href="#为什么需要Redis-Cluster？" class="headerlink" title="为什么需要Redis Cluster？"></a>为什么需要Redis Cluster？</h3><p>高并发场景下的问题：</p><ol><li>缓存的数据量太大</li><li>并发量要求太大</li></ol><p>主从复制和哨兵只能支持整体可用性和读吞吐量，不能够支持横向扩展master来缓解写压力以及解决缓存量过大的问题</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814133105468.png" alt="image-20230814133105468"></p><p>Redis 切片集群：部署多台主节点，节点之间平等，每个节点配置一个或多个从节点</p><p>Redis Cluster这种方案可以很方便地进行横向拓展(Scale Out)，内置了开箱即用的解决方案。当Redis Cluster的处理能力达到瓶颈无法满足系统要求的时候，直接动态添加Redis节点到集群中即可。根据官方文档中的介绍，Redis Cluster支持扩展到1000个节点。反之，当Redis Cluster的处理能力远远满足系统要求，同样可以动态删除集群中 Redis 节点，节省资源。</p><h4 id="Redis-Cluster的主要优势"><a href="#Redis-Cluster的主要优势" class="headerlink" title="Redis Cluster的主要优势:"></a>Redis Cluster的主要优势:</h4><ul><li>可以横向扩展缓解写压力和存储压力，支持动态扩容和缩容</li><li>具备主从复制、故障转移(内置了Sentinel机制，无需单独部署Sentinel集群)等开箱即用的功能。</li></ul><h3 id="Redis-Cluster是如何分片的"><a href="#Redis-Cluster是如何分片的" class="headerlink" title="Redis Cluster是如何分片的"></a>Redis Cluster是如何分片的</h3><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。Redis-cluster中有16384(即2的14次方）个哈希槽，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</p><p>比如集群中存在三个节点，则可能存在的一种分配如下：</p><ul><li>节点A包含0到5500号哈希槽；</li><li>节点B包含5501到11000号哈希槽；</li><li>节点C包含11001 到 16384号哈希槽。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/mingyry/d32d37e5.html"/>
      <url>/mingyry/d32d37e5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>相比MySQL，能够自动帮我们做分词，能够非常高效、灵活地查询内容</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>es中的索引 =&gt; MySQL 中的表</p><p>es中的字段（field）=&gt; MySQL 中的列</p><p>正向索引：理解为书籍的目录，可以快速帮你找到对于的内容</p><p>倒排索引：根据文章内容里面的词汇来找到对应的文章</p><h2 id="ES语法"><a href="#ES语法" class="headerlink" title="ES语法"></a>ES语法</h2><h4 id="DSL语言操作ES"><a href="#DSL语言操作ES" class="headerlink" title="DSL语言操作ES"></a>DSL语言操作ES</h4><p>不需要背</p><p>JSON格式的参数，和HTTP请求最兼容</p><h4 id="EQL"><a href="#EQL" class="headerlink" title="EQL"></a>EQL</h4><p>不需要背</p><p>专门查询 ECS 文档（标准指标文档）的数据的语法，更加规范，特定场景使用</p><h4 id="SQL语言操作ES"><a href="#SQL语言操作ES" class="headerlink" title="SQL语言操作ES"></a>SQL语言操作ES</h4><p>SQL能用尽量用，因为可以跨平台使用</p><p>学习成本低，可能需要额外插件的支持，性能较差</p><h2 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h2><h4 id="restful-api调用（HTTP请求）"><a href="#restful-api调用（HTTP请求）" class="headerlink" title="restful api调用（HTTP请求）"></a>restful api调用（HTTP请求）</h4><p>get请求：<a href="http://localhost:9200/">http://localhost:9200/</a></p><p>curl 可以模拟发送请求： curl -X GET “localhost:9200/?pretty”</p><p><strong>ES的启动端口</strong></p><ol><li>9200：给外部用户（客户端调用）的端口</li><li>9300：给ES集群内部通信的（外部调用不了）</li></ol><h4 id="kibana-devtools"><a href="#kibana-devtools" class="headerlink" title="kibana devtools"></a>kibana devtools</h4><p>利用命令行 自由地对 ES 进行操作（本质也是 restful api）</p><p>dev tools 不建议生产环境使用</p><h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><p>java 客户端操作 es：</p><ol><li><p>ES 官方的 Java API</p></li><li><p>ES 以前的官方 Java API</p><p>HighLevelRestClient（已废弃，不建议用）</p></li><li><p>Spring Data Elasticsearch</p><p>spring-data系列：spring 提供的操作数据库的框架</p><p>spring-data-redis：操作 redis 的一套方法</p><p>spring-data-mongodb：操作 mongodb 的一套方法</p><p>spring-data-elasticsearch：操作 elasticsearch 的一套方法</p><p><strong>自定义查询方法</strong>：用户可以指定接口的方法名称，框架帮你自动生成查询</p></li></ol><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>类型MySQL中的表结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DSL语法</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查询表结构</span></span></span><br><span class="line">get post/_mapping </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES 支持动态mapping，表结构可以动态改变</p><p>还支持显示创建mapping（手动指定mapping）</p><h3 id="Runtime-fields"><a href="#Runtime-fields" class="headerlink" title="Runtime fields"></a>Runtime fields</h3><p>这种字段属于运行时才确定值的字段值，可以保证动态计算（利用js的语法来进行计算）</p><p>如果存在该字段，就查找，如果不存在该字段，就不会查找</p><h3 id="index-类型"><a href="#index-类型" class="headerlink" title="index 类型"></a>index 类型</h3><ul><li><p>text：进行全文搜索的类型</p></li><li><p>keyword：不可拆分，用于过滤和排序，关键字，用于结构化内容，如id、电子邮件地址、主机名、状态码、邮政编码或标签。 手机号和（身份证号因为有X）设置为keyword</p></li><li><p>boolean：布尔类型</p></li><li><p>numbers：数字的类型，</p></li><li><p>ip类型</p></li><li><p>range：范围类型</p></li></ul><h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>分词的一种规则</p><p>es中有很多内置的分词器：</p><p>​    空格分词器：whitespace</p><p>​    标准分词器：standard，将满足的条件进行过滤</p><p>​    关键词分词器：就是不分词，整句话当作专业术语</p><h4 id="IK-分词器（ES的插件）"><a href="#IK-分词器（ES的插件）" class="headerlink" title="IK 分词器（ES的插件）"></a>IK 分词器（ES的插件）</h4><p>中文友好</p><p>ik_smart，只能分词，尽量选择最项一个词的拆分方式</p><p>ik_max_word，尽可能地分词，最精细化进行分词，将“小黑子”，分成 “小黑”，“黑子”</p><h4 id="打分机制"><a href="#打分机制" class="headerlink" title="打分机制"></a>打分机制</h4><p>看内容的词语的匹配度，关注于匹配比例，es会进行打分</p><h2 id="用-ES-实现搜索接口"><a href="#用-ES-实现搜索接口" class="headerlink" title="用 ES 实现搜索接口"></a>用 ES 实现搜索接口</h2><h4 id="1-建表（建立索引）"><a href="#1-建表（建立索引）" class="headerlink" title="1. 建表（建立索引）"></a>1. 建表（建立索引）</h4><p>ES 中，尽量存放需要用户筛选（搜索）的数据，频繁变化的数据也不适合放到ES中</p><p>根据数据库的表来建立 ES Mapping</p><p>ES Mapping：</p><p>id（可以不放到字段设置里）</p><p>aliases：别名（为了后续方便数据迁移），建表时尽量给别名</p><p>字段类型是text，这个字段是可被分词的、可模糊查询的；如果是keyword，只能完全匹配、精确查询</p><p>analyzer（存储时生效的分词器）：ik_max_word，拆的更碎、索引更多，更有可能被搜出来</p><p>search_analyzer（查询时生效的分词器）：ik_smart，更偏向于用户想搜的分词</p><p>如果想要让 text类型的分词字段也支持精确查询，可以创建 keyword 类型的子字段</p><p>ES 中 _字段表示系统的默认字段，比如 _id，如果系统不指定，会自动生成，但是不会再_source 字段中补充id的值，所以建议大家手动指定</p><h4 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h4><p>第一种方式：ElasticsearchRepositiry<PostEsDTO， Long>，默认提供了简单的增删改查，多用于可预期的，相对不复杂的查询、自定义查询</p><p>第二种方式：Spring 默认给我们提供的操作 es 的客户端对象 ElasticsearchRestTemplate，也提供了增删改查，它的增删改查更灵活，适用于更复杂的操作，返回结果更完成，需要自己解析</p><p><strong>查询 DSL语句：</strong></p><ul><li>bool：组合条件</li><li>must： 必须都满足</li><li>match：模糊查询</li><li>term：精确查询</li><li>range：范围查询</li><li>wildcard：模糊查询</li><li>regexp：正则匹配查询</li><li>score：代表查询出来的结果的分数</li><li>should：满足要求的个数才可以，minimum_should_match</li></ul><h4 id="3-查询步骤："><a href="#3-查询步骤：" class="headerlink" title="3. 查询步骤："></a>3. 查询步骤：</h4><ol><li>获取参数</li><li>把参数组合为 ES 支持的搜索条件</li><li>从返回值中获取结果</li><li>先模糊筛选<strong>静态数据</strong>，查出数据后，在根据查到的内容id去数据库查找到<strong>动态数据</strong></li></ol><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>一般情况下，如果做查询搜索功能；使用 ES 来模糊搜索，但是数据是存放在数据库 MySQL 为主，所以我们需要把MySQL 中的数据和 ES 进行同步，保证数据一致（以MySQL为主）。</p><p>首次安装完ES，把MySQL数据全量同步到ES里，写一个单词脚本</p><p><strong>4种方式：全量同步（首次）+增量同步（新数据）</strong></p><ol><li><p>定时任务，比如一分钟一次，找到 MySQL 中过去几分钟（至少是定时周期的两到三倍）内发生改变的数据，然后更新到 ES。</p><p>ES 根据id来更新或者查询数据</p><p>优点：简单易懂、占用资源少、不用引入第三方中间件</p><p>缺点：没有实时性</p><p>应用场景：数据短时间内不同步影响不大、或者数据几乎不发生修改</p></li><li><p>双写：写数据库的时候，必须也去写ES；更新删除数据库同理。（事务：建议先保证MySQL写入成功，如果ES写失败了，通过定时任务+日志+告警进行检测和修复（补偿功能））</p></li><li><p>用 Logstash 数据同步和数据处理管道（一般要配合 kafka消息队列+ beats采集器）：</p><p>配置config，整合了多种输入和输出的模式</p><p>把MySQL 同步到 Elasticsearch</p><p>增量配置：是不是可以只查最新更新的？可以记录上次更新的数据的时间</p><p>全量更新：只需要将配置中的更新数据时间进行删除，然后第一次就会全量更新</p><p>注意查询语句要按照updateTime进行排序，保证最后一条是最大的</p><p>两个问题： 利用<strong>数据处理</strong>的filter组件</p><ul><li>字段全部变成小写了</li><li>多了不想保存的数据</li></ul><p>优点：用起来方便，插件的</p><p>缺点：学习成本高，一般需要配合其他的组件使用，比如kafka</p></li><li><p>订阅数据库流水的同步方式，canal（实时同步）</p><p>原理：数据库每次修改时，会修改 binlog 文件，只要监听该文件的修改，就能第一时间得到消息并处理</p><p>canal：帮你监听 binlog，并解析 binlog 为你可以理解的内容，伪装成mysql的从节点，获取主节点的 binlog</p><p>优点：实时同步，实时性非常强</p></li></ol><p>预编译SQL的优点：</p><ol><li>灵活</li><li>模板好懂</li><li>部分防注入</li><li>主要是快（因为有缓存）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Elasticstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发面试题</title>
      <link href="/mingyry/a654c162.html"/>
      <url>/mingyry/a654c162.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发面试题"><a href="#Java并发面试题" class="headerlink" title="Java并发面试题"></a>Java并发面试题</h1><h2 id="JUC常用的并发类"><a href="#JUC常用的并发类" class="headerlink" title="JUC常用的并发类"></a>JUC常用的并发类</h2><ol><li><p><strong>atomic包</strong></p><p>CAS使用的原子操作类如，AtomicInteger等</p></li><li><p><strong>locks包</strong></p><p>AbstractQueuedSynchronizer (AQS)，ReentantLock（显式锁），ReentrantReadWriteLock (可重入的读写锁)</p></li><li><p><strong>tools包</strong></p><p>CountDownLatch（同步锁）、Semaphore（信号量）、CyclicBarrier（栅栏）</p></li><li><p><strong>collections包</strong></p><p>ConcurrentHashMap（同步HashMap）、CopyOnWriteArrayList（写时复制容器）、各种阻塞队列的实现：ArrayBlockingQueue（数组实现的有界阻塞队列，入队出队使用一把锁）、LinkedBlockingQueue（有界阻塞队列，入队出队两把锁）、PriorityBlockingQueue</p></li><li><p><strong>executor包</strong></p><p>Executor类，Future类，Callable类，RejcetedExecutionhandler（拒绝策略类）</p></li></ol><p><strong>condition</strong>在juc包中</p><h2 id="自增操作的非原子性"><a href="#自增操作的非原子性" class="headerlink" title="自增操作的非原子性"></a>自增操作的非原子性</h2><ul><li>读取当前值</li><li>增加当前值为新值</li><li>写回新值</li></ul><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><ol><li><strong>降低系统资源消耗</strong>，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li><strong>提高系统响应速度</strong>，当有任务到达时，<strong>无需等待新线程的创建便能立即执行</strong>；</li><li><strong>方便线程并发数的管控</strong>，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li><li>更强大的功能，线程池提供了<strong>定时、定期以及可控线程数</strong>等功能的线程池，使用方便简单。</li></ol><h2 id="并发编程三要素"><a href="#并发编程三要素" class="headerlink" title="并发编程三要素"></a>并发编程三要素</h2><h3 id="新建线程的几种方式"><a href="#新建线程的几种方式" class="headerlink" title="新建线程的几种方式"></a>新建线程的几种方式</h3><ol><li>通过继承Thread类，重写run方法；</li><li>通过实现runable接口；</li><li>通过实现callable接口</li></ol><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230806083919933.png" alt="image-20230806083919933"></p><h3 id="线程上下文切换的情况（4种）"><a href="#线程上下文切换的情况（4种）" class="headerlink" title="线程上下文切换的情况（4种）"></a>线程上下文切换的情况（4种）</h3><ol><li>时间片用完</li><li>调用sleep()，或者wait()</li><li>调用了阻塞类型的系统中断</li><li>被终止或结束运行</li></ol><h3 id="线程的几个方法（interrupt-join-sleep-yield-）"><a href="#线程的几个方法（interrupt-join-sleep-yield-）" class="headerlink" title="线程的几个方法（interrupt(), join(), sleep(), yield()）"></a>线程的几个方法（interrupt(), join(), sleep(), yield()）</h3><ol><li><p>interrupt()，中断线程，来清理资源，相比之间结束线程更优雅</p></li><li><p>join()，两个线程之间的通信，在A中执行B.join()，就是要等待B结束才能执行</p></li><li><p>sleep()，线程休眠</p><blockquote><p><strong>sleep() VS wait()</strong></p></blockquote><p>两者主要的区别：</p><ol><li>sleep()方法是<strong>Thread的静态方法</strong>，而wait是Object实例方法</li><li>wait()方法必须要在同步方法或者同步块中调用，也就是<strong>必须已经获得对象锁</strong>。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</li><li>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。</li></ol></li><li><p>yield()，当前线程让出CPU，并且让出的时间片只会分配<strong>给当前线程相同优先级</strong>的线程</p></li></ol><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>用户线程消亡，守护线程也自动消失，jvm的垃圾清理线程</p><h4 id="两个注意"><a href="#两个注意" class="headerlink" title="两个注意"></a>两个注意</h4><ol><li><strong>守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的</strong></li><li><strong>设置守护线程要先于</strong>start()方法</li></ol><h2 id="JMM（Java内存区域）"><a href="#JMM（Java内存区域）" class="headerlink" title="JMM（Java内存区域）"></a>JMM（Java内存区域）</h2><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><p>线程（本地变量（共享变量的副本））&lt;—-&gt;主内存（共享变量）</p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><ol><li>线程A读入共享变量，写到共享变量的副本中，修改共享变量的值，再写回共享变量中</li><li>线程B读取共享变量， 写到共享变量的副本中</li></ol><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>为了提高性能，编译器和处理器常常会对指令进行重排序</p><ol><li>编译器在不改变单线程语义的情况下，安排语句的执行顺序</li><li>处理器，如果不存在数据依赖性，会改变语句对应的机器指令的执行顺序</li></ol><h4 id="Happens-before（JMM原则就可以）"><a href="#Happens-before（JMM原则就可以）" class="headerlink" title="Happens-before（JMM原则就可以）"></a>Happens-before（JMM原则就可以）</h4><p>1）如果一个操作happens-before另一个操作，那么第一个操作的<strong>执行结果</strong>将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><p>2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>阻止指令重排序使用内存屏障</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2615789-a31dbae587e8a946.png" alt="volatile写插入内存屏障示意图"></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2615789-dc628461898a66a6.png" alt="volatile读插入内存屏障示意图"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="Volatile特性"><a href="#Volatile特性" class="headerlink" title="Volatile特性"></a>Volatile特性</h3><ol><li>禁止指令重排序</li><li>保证变量的可见性</li></ol><h3 id="Volatile不适用场景"><a href="#Volatile不适用场景" class="headerlink" title="Volatile不适用场景"></a>Volatile不适用场景</h3><ol><li>不适用于依赖先前状态的操作</li><li>不适用于不具备原子性的复合操作，例如自增</li><li>不适用于计数器</li><li>不适用于线程间复杂的通信</li></ol><h3 id="Volatile双重检验锁"><a href="#Volatile双重检验锁" class="headerlink" title="Volatile双重检验锁"></a>Volatile双重检验锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                      <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * new对象不是一个原子性操作包含三部分</span></span><br><span class="line"><span class="comment">                    * 1. 分配内存空间</span></span><br><span class="line"><span class="comment">                    * 2. 赋初始值</span></span><br><span class="line"><span class="comment">                    * 3. 指向分配的内存地址</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Volatile使用场景"><a href="#Volatile使用场景" class="headerlink" title="Volatile使用场景"></a>Volatile使用场景</h3><ol><li>适用于变量状态的改变的场景</li></ol><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="MarkWord"><a href="#MarkWord" class="headerlink" title="MarkWord"></a>MarkWord</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20200619123714116.png" alt="在这里插入图片描述"></p><h3 id="使用场景（两方面来回答）"><a href="#使用场景（两方面来回答）" class="headerlink" title="使用场景（两方面来回答）"></a>使用场景（两方面来回答）</h3><ol><li>方法上：    <ul><li>静态方法：锁住的是整个类</li><li>实例方法：锁住的是当前对象</li></ul></li><li>代码块：<ul><li>this：锁住的是当前对象</li><li>.class：锁住的是整个类</li><li>object：锁住的是目标对象</li></ul></li></ol><h3 id="偏向锁（获取和撤销）"><a href="#偏向锁（获取和撤销）" class="headerlink" title="偏向锁（获取和撤销）"></a>偏向锁（获取和撤销）</h3><p>偏向锁获取：看当前的偏向锁的拥有线程是不是当前线程，如果是则再次获取偏向锁，如果不是，则CAS竞争锁</p><p>偏向锁撤销：当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁的撤销，需要等待<strong>全局安全点</strong>（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word<strong>要么</strong>重新偏向于其他线程，<strong>要么</strong>恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p><h3 id="轻量级锁（加锁和解锁）"><a href="#轻量级锁（加锁和解锁）" class="headerlink" title="轻量级锁（加锁和解锁）"></a>轻量级锁（加锁和解锁）</h3><p>加锁：然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>解锁：轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>普通的锁</p><h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="类变量（static修饰）"><a href="#类变量（static修饰）" class="headerlink" title="类变量（static修饰）"></a>类变量（static修饰）</h4><ul><li>声明变量时直接赋初值</li><li>静态代码块中给变量赋初值</li></ul><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ul><li><p>声明变量时赋初值</p></li><li><p>非静态初始块中</p><p>就是{}中</p></li><li><p>构造器中</p></li></ul><p>赋值了之后不能再更改</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p><strong>仅有一次机会被赋值</strong>，赋值后不能再次赋值</p><blockquote><p>基本数据类型： 如果被赋初始值就不能再次赋值</p><p>引用数据类型：final只是保证引用的地址不变，对象的属性是可以改变的</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>final修饰的父类不能被重写</li><li>final修饰的方法可以被重载</li></ul><h3 id="修饰不变类"><a href="#修饰不变类" class="headerlink" title="修饰不变类"></a>修饰不变类</h3><p>不变类就是创建该类的实例后，该实例的实例变量是不可改变的（String）</p><ul><li>使用private和final来修饰成员变量</li><li>使用带参数的构造器来初始化成员变量</li><li>仅提供getter方法，普通方法无法修改final修饰的成员变量</li><li>有必要的话，重写Object类的hashCode()方法和equals()方法</li></ul><h2 id="三大性质"><a href="#三大性质" class="headerlink" title="三大性质"></a>三大性质</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个操作不可中断，要么全部执行成功，要么全部执行失败</p><p>Volatile不能保证原子性除非两点满足：</p><ul><li>运算结果不依赖当前值，或者只有一个线程在操作</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ul><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>在本线程内观察，所有操作都是有序的，但是在一个线程观察另一个线程，所有的操作都是无序的</p><h4 id="Volatile的双重校验锁："><a href="#Volatile的双重校验锁：" class="headerlink" title="Volatile的双重校验锁："></a>Volatile的双重校验锁：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;  <span class="comment">// 如果已经有对象了，就不用再获取锁了，防止锁等待</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;  <span class="comment">// 目的是，防止二次创建，可能线程A创建完释放锁，线程B正好获取锁进入</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * new对象不是一个原子性操作包含三部分</span></span><br><span class="line"><span class="comment">                    * 1. 分配内存空间</span></span><br><span class="line"><span class="comment">                    * 2. 赋初始值</span></span><br><span class="line"><span class="comment">                    * 3. 指向分配的内存地址</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>当一个线程修改了共享变量之后，其他线程能够立即得知这个修改。lock指令，在线程获取锁时从主内存中读取共享变量，释放锁时将共享变量写回到主内存中</p><h2 id="Lock包"><a href="#Lock包" class="headerlink" title="Lock包"></a>Lock包</h2><h3 id="AQS（抽象队列同步器）"><a href="#AQS（抽象队列同步器）" class="headerlink" title="AQS（抽象队列同步器）"></a>AQS（抽象队列同步器）</h3><p>同步组件通过使用AQS提供的模板方法来实现同步组件的语义，AQS则负责对<strong>同步状态进行管理，对阻塞线程进行排队，等待通知</strong>等等一系列底层处理的实现。</p><p>AQS的核心：</p><ul><li>同步队列</li><li>独占式锁的获取和释放</li><li>共享锁的获取和释放</li><li>可中断锁</li><li>超时等待锁获取</li></ul><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><ol><li><p>节点的数据结构（双向链表）</p><p>有一个静态内部类Node，里面保存着当前节点的状态信息，前驱和后继的节点信息和当前节点对应的线程的引用</p></li><li><p>管理同步队列</p><p>利用头尾指针来管理同步队列</p></li></ol><h4 id="独占锁的获取和释放"><a href="#独占锁的获取和释放" class="headerlink" title="独占锁的获取和释放"></a>独占锁的获取和释放</h4><ul><li>线程获取锁失败，包装成一个Node进行入队操作，方法是 addWaiter() 和 enq()，并且使用enq()来完成队列的头结点初始化工作和CAS失败重试（当前节点加入队列的失败重试）</li><li>获取锁是一个自旋等待的过程，当且仅当 当前节点的前驱节点是头结点，并且当前节点的状态值是同步状态时，该节点出队并且获取锁。不满足时就调用LockSupport.park()方法来进行线程阻塞</li><li>释放锁之后会唤醒其后继节点。这就代表AQS是一个先入先出的同步阻塞队列</li></ul><p>总体来说：<strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p><p>带头节点的队列就是有一个虚拟头节点或者说是哨兵节点</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>可重入的互斥锁</p><p>特性：</p><ul><li><p>可重入式</p><p>就是获取多少次锁，在state上自增，然后释放锁时，需要state为0</p></li><li><p>公平锁和非公平锁</p><ul><li>公平锁保证请求资源时间上的绝对顺序，非公平锁可能导致其他线程无法获取到锁，造成饥饿的现象</li><li>公平锁为保证时间上的顺序，频繁的进行上下文的切换。非公平锁一定程度上降低上下文切换的频率。ReentrantLock默认使用非公平锁</li></ul></li><li><p>等待可中断</p></li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition实现等待/通知的机制 配合Lock， 属于语言级别，有着更高的可控制性和扩展性</p><p>Object的wait/notify是利用对象监视器完成的线程等待/通知，属于Java底层级别</p><p>Codition的特性：</p><ul><li>支持不响应中断</li><li>支持多个等待队列，Object只能支持一个</li><li>支持超时时间的设置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">put() &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == length)</span><br><span class="line">    notFull.await();</span><br><span class="line">    <span class="comment">// 创建物品</span></span><br><span class="line">    notEmpty().signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">take() &#123;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">    <span class="comment">// 带走物品</span></span><br><span class="line">    notFull.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>是一个单向队列</p><p>一个Lock可以持有多个等待队列</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><strong>当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理</strong>。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p><strong>调用condition的signal的前提条件是当前线程已经获取了lock，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从await方法中的LockSupport.park(this)方法中返回，从而才有机会使得调用await方法的线程成功退出</strong>。</p><h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h4><p>就是用一个循环全部唤醒</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>作用，阻塞当前线程</p><p>synchronzed致使线程阻塞，线程会进入到BLOCKED状态，而调用LockSupprt方法阻塞线程会致使线程进入到WAITING状态。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>初始大小为16并且每一次扩容后的大小是2的n次方</p><p>注意：调用构造器方法的时候，没有构造出table数组（这个数组是concurrentHashMap来存放数据的容器），只是算出了table的长度，等到插入数据时，才真正构造table数组</p><p>Node类：</p><ol><li>hash值</li><li>key</li><li>value</li><li>next Node</li></ol><h4 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h4><ol><li>首先对Key的哈希值进行哈希计算，确定这个值在table（数组）中的位置</li><li>如果当前数组没有初始化，则进行初始化（插入第一个值时）</li><li>如果值所在数组位置的节点为null，则采用<strong>CAS</strong>的方式来放入key</li><li>如果节点不为空，代表出现了hash碰撞，首先需要判断节点的类型。如果fh==-1，表示正在扩容，则参与到扩容中</li><li>如果是链表节点，则需要遍历链表，如果key值相同，则覆盖旧值，如果不存在相同的key值，则尾插法插入到链表的尾部（<strong>synchronized</strong>）</li><li>如果节点是TreeBin的话，遍历红黑树，相同key值覆盖，不相同则插入树中（<strong>synchronized</strong>）</li><li>插入完节点后，检查链表的长度，如果大于8则再判断数组长度是否小于64，如果小于64，则对数组扩容。如果大于64，则将链表转换为红黑树</li><li>对当前的容量大小进行检查，如果超过了临界值（实际大小*加载因子（3/4））就需要扩容</li></ol><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><ol><li>查看当前数组的节点是否是要查找的节点，是就返回</li><li>不是，则判断当前的数组节点是否是红黑树节点，是的话查找树，查到返回值，查不到返回null</li><li>不是红黑树节点，则是链表节点，进行链表的查找，查到返回值，查不到返回null</li></ol><h3 id="JDK1-7-和-JDK1-8的区别"><a href="#JDK1-7-和-JDK1-8的区别" class="headerlink" title="JDK1.7 和 JDK1.8的区别"></a>JDK1.7 和 JDK1.8的区别</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>采用Segment（哈希桶）+ HashEntry的方式进行实现</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2184951-af57d9d50ae9f547.png" alt="img" style="zoom: 80%;" /></p><p>Segment默认大小为16，HashEntry默认大小为2的幂次方。</p><p>加锁是对segment的每个节点加锁（加ReentreantLock锁），如果数组的位置对应节点没有被初始化，则使用CAS进行初始化</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程的本地变量。即每个线程都拥有该变量的副本，避免共享资源的竞争（怎么判断是对应线程的变量？）</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>里面维护了一个Entry的数组</p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>是一个以ThreadLocal为Key，Object为值的键值对。其中，ThreadLocal是一个弱引用</p><p><strong>Entry中的key是弱引用，当threadLocal外部强引用被置为null( threadLocalInstance=null ),那么系统 GC的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</strong></p><p>在实际开发中，会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的，所以，threadLocal的内存泄漏问题，是应该值得我们思考和注意的问题。</p><p>ThreadLocal的生命周期中会清除key为null的脏Entry</p><h4 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h4><p>使用开放地址法，原因，ThreadLocalMap中的散列值的分布十分均匀，很少出现冲突，并且ThreadLocalMap经常清除无用对象，使用数组更加方便</p><h3 id="threadLocal最佳实践"><a href="#threadLocal最佳实践" class="headerlink" title="threadLocal最佳实践"></a>threadLocal最佳实践</h3><p>我们可以完全理解threadLocal内存泄漏的前因后果，那么实践中我们应该怎么做？</p><ol><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li><li>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li></ol><p>threadLocal只适合共享对象会造成线程安全的业务场景</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2b569b2f33904ad190946ebacb3ac87a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h2 id="BlockingQueue-阻塞队列"><a href="#BlockingQueue-阻塞队列" class="headerlink" title="BlockingQueue 阻塞队列"></a>BlockingQueue 阻塞队列</h2><p>特殊操作：</p><ol><li>put：当阻塞队列容量已满时，往阻塞队列里面插入数据会被阻塞，知道有空余容量可以使用</li><li><p>offer(E e, long timeout, TimeUnit unit)：与put相同，但是可以设置超时时间，超过超时时间，线程会退出</p></li><li><p>take()：当阻塞队列为空时，获取队头数据的线程会被阻塞</p></li><li>poll(E e, long timeout, TimeUnit unit)：和offer差不多</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断与降级</title>
      <link href="/mingyry/9719b31f.html"/>
      <url>/mingyry/9719b31f.html</url>
      
        <content type="html"><![CDATA[<h1 id="熔断与降级"><a href="#熔断与降级" class="headerlink" title="熔断与降级"></a>熔断与降级</h1><p>在高并发环境下，<strong>服务之间的依赖关系导致调用失败，解决的方式通常是: 限流-&gt;熔断-&gt;隔离-&gt;降级, 其目的是防止雪崩效应</strong>。</p><p>降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</p><h2 id="基本的容错模式"><a href="#基本的容错模式" class="headerlink" title="基本的容错模式"></a>基本的容错模式</h2><blockquote><p>常见的容错模式主要包含以下几种方式</p></blockquote><ul><li>主动超时：Http请求主动设置一个超时时间，超时就直接返回，不会造成服务堆积</li><li>限流：限制最大并发数</li><li>熔断：当错误数超过阈值时快速失败，不调用后端服务，同时隔一定时间放几个请求去重试后端服务是否能正常调用，如果成功则关闭熔断状态，失败则继续快速失败，直接返回。（此处有个重试，重试就是弹性恢复的能力）</li><li>隔离：把每个依赖或调用的服务都隔离开来，防止级联失败引起整体服务不可用</li><li>降级：服务失败或异常后，返回指定的默认信息</li></ul><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><blockquote><p>在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><blockquote><p>在学习服务熔断时，有必要区分下如下几个相关的概念。</p></blockquote><ul><li>服务雪崩</li></ul><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C有调用其他的微服务，如果整个链路上某个微服务的调用响应式过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统雪崩，所谓的”雪崩效应”</p><ul><li>断路器</li></ul><p>“断路器”本身是一种开关装置，当某个服务单元发生故障监控(类似熔断保险丝)，向调用方法返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延。乃至雪崩。</p><ul><li>服务熔断</li></ul><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当整个链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。</p><h3 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h3><p>它有两个基本状态（close和open）和一个基本trip动作：</p><ul><li>close状态下， client向supplier发起的服务请求， 直接无阻碍通过断路器， supplier的返回值接直接由断路器交回给client。</li><li>open状态下，client向supplier发起的服务请求后，断路器不会将请求转到supplier, 而是直接返回client, client和supplier之间的通路是断的</li><li>trip: 在close状态下，如果supplier持续超时报错， 达到规定的阀值后，断路器就发生trip, 之后断路器状态就会从close进入open。</li></ul><p>此外：需要额外的措施可以在supplier恢复服务后，可以重置断路器。一种可行的办法是断路器定期探测supplier的服务是否恢复， 一但恢复， 就将状态设置成close。断路器进行重试时的状态为半开（half-open）状态。</p><h3 id="服务熔断中需考虑的设计"><a href="#服务熔断中需考虑的设计" class="headerlink" title="服务熔断中需考虑的设计"></a>服务熔断中需考虑的设计</h3><p>源自博主张善友的观点：</p><ul><li><strong>异常处理</strong>：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li><li><strong>异常的类型</strong>：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li><li><strong>日志</strong>：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。 测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li><li><strong>手动重置</strong>：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。 并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。 资源的差异性：使用单个熔断器时，一个资源如果有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li><li><strong>加快熔断器的熔断操作</strong>:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li><li><strong>重复失败请求</strong>：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li></ul><h3 id="服务熔断恢复需注意的问题"><a href="#服务熔断恢复需注意的问题" class="headerlink" title="服务熔断恢复需注意的问题"></a>服务熔断恢复需注意的问题</h3><p>如果服务是幂等性的，则恢复重试不会有问题；而如果服务是非幂等性的，则重试会导致数据出现问题</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><h3 id="降级服务的特征"><a href="#降级服务的特征" class="headerlink" title="降级服务的特征"></a>降级服务的特征</h3><ul><li>原因：整体负荷超出整体负载承受能力。</li><li>目的：保证重要或基本服务正常运行，非重要服务<strong>延迟使用或暂停使用</strong></li><li>大小：降低服务粒度，要考虑整体模块粒度的大小，将粒度控制在合适的范围内</li><li>可控性：在服务粒度大小的基础上增加服务的可控性，后台服务开关的功能是一项必要配置（单机可配置文件，其他可领用数据库和缓存），可分为手动控制和自动控制。</li><li>次序：一般<strong>从外围延伸服务</strong>开始降级，需要有一定的配置项，重要性低的优先降级，比如可以分组设置等级1-10，当服务需要降级到某一个级别时，进行相关配置</li></ul><h3 id="降级方式"><a href="#降级方式" class="headerlink" title="降级方式"></a>降级方式</h3><ul><li>延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。</li><li>在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区</li><li>页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</li><li>页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址</li><li>写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</li><li>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景。</li></ul><h3 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h3><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ul><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ul><h3 id="服务降级分类"><a href="#服务降级分类" class="headerlink" title="服务降级分类"></a>服务降级分类</h3><ul><li>降级按照是否自动化可分为：自动开关降级（超时、失败次数、故障、限流）和人工开关降级（秒杀、电商大促等）。</li><li>降级按照功能可分为：读服务降级、写服务降级。</li><li>降级按照处于的系统层次可分为：多级降级。</li></ul><h3 id="自动降级分类"><a href="#自动降级分类" class="headerlink" title="自动降级分类"></a>自动降级分类</h3><ul><li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li><li>失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</li><li>故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</li><li>限流降级: 当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）</li></ul><h3 id="服务降级需考虑的问题"><a href="#服务降级需考虑的问题" class="headerlink" title="服务降级需考虑的问题"></a>服务降级需考虑的问题</h3><ul><li>核心服务或非核心服务。</li><li>是否支持降级，及其降级策略。</li><li>业务放通场景，极其策略。</li></ul><h3 id="服务熔断与服务降级比较"><a href="#服务熔断与服务降级比较" class="headerlink" title="服务熔断与服务降级比较"></a>服务熔断与服务降级比较</h3><p>服务熔断对服务提供了proxy，防止服务不可能时，出现串联故障（cascading failure），导致雪崩效应。</p><p><strong>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑</strong>。</p><ul><li>共性： <ul><li>目的 -&gt; 都是从可用性、可靠性出发，提高系统的容错能力。</li><li>最终表现-&gt;使某一些应用不可达或不可用，来保证整体系统稳定。</li><li>粒度 -&gt; 一般都是服务级别，但也有细粒度的层面：如做到数据持久层、只许查询不许增删改等。</li><li>自治 -&gt; 对其自治性要求很高。都要求具有较高的自动处理机制。</li></ul></li><li>区别： <ul><li>触发原因 -&gt; 服务熔断通常是下级服务故障引起；服务降级通常为整体系统而考虑。</li><li>管理目标 -&gt; 熔断是每个微服务都需要的，是一个框架级的处理；而服务降级一般是关注业务，对业务进行考虑，抓住业务的层级，从而决定在哪一层上进行处理：比如在IO层，业务逻辑层，还是在外围进行处理。</li><li>实现方式 -&gt; 代码实现中的差异。</li></ul></li></ul><hr><p>参考文章：<a href="https://pdai.tech/md/arch/arch-y-reduce.html">https://pdai.tech/md/arch/arch-y-reduce.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 熔断 </tag>
            
            <tag> 降级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量控制</title>
      <link href="/mingyry/2a553090.html"/>
      <url>/mingyry/2a553090.html</url>
      
        <content type="html"><![CDATA[<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="限流简介"><a href="#限流简介" class="headerlink" title="限流简介"></a>限流简介</h2><p>每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>令牌桶(Token Bucket)、漏桶(leaky bucket)，固定窗口和滑动窗口  四种限流的算法。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="应用级-单机"><a href="#应用级-单机" class="headerlink" title="应用级 - 单机"></a>应用级 - 单机</h4><p>应用级限流方式只是单应用内的请求限流，不能进行全局限流。</p><ol><li>限流总资源数</li><li>限流总并发/连接/请求数</li><li>限流某个接口的总并发/请求数</li><li>限流某个接口的时间窗请求数</li><li>平滑限流某个接口的请求数</li><li>Guava RateLimiter</li></ol><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>我们需要<strong>分布式限流</strong>和<strong>接入层限流</strong>来进行全局限流。</p><ol><li>redis+lua实现中的lua脚本</li><li>使用Nginx+Lua实现的Lua脚本</li><li>使用 OpenResty 开源的限流方案</li><li>限流框架，比如Sentinel实现降级限流熔断</li></ol><h2 id="固定窗口限流算法"><a href="#固定窗口限流算法" class="headerlink" title="固定窗口限流算法"></a>固定窗口限流算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>固定窗口限流算法（<code>Fixed Window Rate Limiting Algorithm</code>）是一种最简单的限流算法，其原理是在<strong>固定时间窗口</strong>(<code>单位时间</code>)内限制请求的数量。</p><p>该算法将时间分成固定的窗口，并在每个窗口内限制请求的数量。</p></blockquote><p>具体来说，算法将请求按照时间顺序放入时间窗口中，并计算该时间窗口内的请求数量，如果请求数量超出了限制，则拒绝该请求。</p><p>假设单位时间(固定时间窗口)是<code>1</code>秒，限流阀值为<code>3</code>。在单位时间<code>1</code>秒内，每来一个请求,计数器就加<code>1</code>，如果计数器累加的次数超过限流阀值<code>3</code>，后续的请求全部拒绝。等到<code>1s</code>结束后，计数器清<code>0</code>，重新开始计数。如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230806153753851.png" alt="image-20230806153753851" style="zoom:80%;" /></p><h3 id="固定窗口限流的伪代码实现"><a href="#固定窗口限流的伪代码实现" class="headerlink" title="固定窗口限流的伪代码实现"></a>固定窗口限流的伪代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//统计请求数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastAcquireTime</span> <span class="operator">=</span>  <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span> ; <span class="comment">//假设固定时间窗口是1000ms</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 窗口阀值是10</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 固定窗口时间算法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">fixedWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">     <span class="keyword">if</span> (currentTime - lastAcquireTime &gt; windowUnit) &#123;  <span class="comment">//检查是否在时间窗口内</span></span><br><span class="line">         counter = <span class="number">0</span>;  <span class="comment">// 计数器清0</span></span><br><span class="line">         lastAcquireTime = currentTime;  <span class="comment">//开启新的时间窗口</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (counter &lt; threshold) &#123;  <span class="comment">// 小于阀值</span></span><br><span class="line">         counter++;  <span class="comment">//计数统计器加1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="固定窗口算法的优缺点"><a href="#固定窗口算法的优缺点" class="headerlink" title="固定窗口算法的优缺点"></a>固定窗口算法的优缺点</h3><ul><li><strong>优点</strong>：固定窗口算法非常简单，易于实现和理解。</li><li><strong>缺点</strong>：存在<strong>明显的临界问题</strong>，比如: 假设限流阀值为<code>5</code>个请求，单位时间窗口是<code>1s</code>,如果我们在单位时间内的<code>前0.8-1s</code>和<code>1-1.2s</code>，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，<strong>已经超过单位时间1s不超过5阀值的定义</strong>。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/c33e00a0048042018b38126db6d7ee7d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom: 67%;" /></p><h2 id="滑动窗口限流算法"><a href="#滑动窗口限流算法" class="headerlink" title="滑动窗口限流算法"></a>滑动窗口限流算法</h2><h3 id="什么是滑动窗口限流算法"><a href="#什么是滑动窗口限流算法" class="headerlink" title="什么是滑动窗口限流算法"></a>什么是滑动窗口限流算法</h3><blockquote><p>滑动窗口限流算法是一种常用的限流算法，用于控制系统对外提供服务的速率，防止系统被过多的请求压垮。它将单位时间周期分为<code>n</code>个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。<strong>它可以解决固定窗口临界值的问题</strong>。</p></blockquote><p>用一张图解释滑动窗口算法，如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/24247985b4734d9192d34a36ce7aedc7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom: 67%;" /></p><p>假设单位时间还是<code>1</code>s，滑动窗口算法把它划分为<code>5</code>个小周期，也就是滑动窗口（<strong>单位时间</strong>）被划分为<code>5</code>个小格子。每格表示<code>0.2s</code>。每过<code>0.2s</code>，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是<code>0.83s</code>到达的，<code>0.8~1.0s</code>对应的计数器就会加<code>1</code>。</p><p><strong>我们来看下，滑动窗口,去解决固定窗口限流算法的临界问题，思想是怎样</strong></p><blockquote><p>假设我们<code>1s</code>内的限流阀值还是<code>5</code>个请求，<code>0.8~1.0s</code>内（比如<code>0.9s</code>的时候）来了<code>5</code>个请求，落在黄色格子里。时间过了<code>1.0s</code>这个点之后，又来<code>5</code>个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了<code>1.0s</code>这个点后，会右移一小格，当前的单位时间段是<code>0.2~1.2s</code>，这个区域的请求已经超过限定的<code>5</code>了，已触发限流啦，实际上，紫色格子的请求都被拒绝啦。</p></blockquote><p>当滑动窗口的<strong>格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确</strong>。</p><h3 id="2-2-滑动窗口限流算法的伪代码实现"><a href="#2-2-滑动窗口限流算法的伪代码实现" class="headerlink" title="2.2 滑动窗口限流算法的伪代码实现"></a>2.2 滑动窗口限流算法的伪代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment"> * 单位时间划分的小周期（单位时间是1分钟，10s一个小格子窗口，一共6个格子）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">SUB_CYCLE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每分钟限流请求数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">thresholdPerMin</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数器, k-为当前窗口的开始时间值秒，value为当前窗口的计数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Integer&gt; counters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 滑动窗口时间算法实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">slidingWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">currentWindowTime</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / SUB_CYCLE * SUB_CYCLE; <span class="comment">//获取当前时间在哪个小周期窗口</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">currentWindowNum</span> <span class="operator">=</span> countCurrentWindow(currentWindowTime); <span class="comment">//当前窗口总请求数</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//超过阀值限流</span></span><br><span class="line">       <span class="keyword">if</span> (currentWindowNum &gt;= thresholdPerMin) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计数器+1</span></span><br><span class="line">       counters.get(currentWindowTime)++;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统计当前窗口的请求数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">countCurrentWindow</span><span class="params">(<span class="type">long</span> currentWindowTime)</span> &#123;</span><br><span class="line">       <span class="comment">//计算窗口开始位置</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentWindowTime - SUB_CYCLE* (60s/SUB_CYCLE-<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//遍历存储的计数器</span></span><br><span class="line">       Iterator&lt;Map.Entry&lt;Long, Integer&gt;&gt; iterator = counters.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;Long, Integer&gt; entry = iterator.next();</span><br><span class="line">           <span class="comment">// 删除无效过期的子窗口计数器</span></span><br><span class="line">           <span class="keyword">if</span> (entry.getKey() &lt; startTime) &#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//累加当前窗口的所有计数器之和</span></span><br><span class="line">               count = count + entry.getValue();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口限流算法的优缺点"><a href="#滑动窗口限流算法的优缺点" class="headerlink" title="滑动窗口限流算法的优缺点"></a>滑动窗口限流算法的优缺点</h3><p><strong>优点</strong>：</p><ul><li>简单易懂</li><li>精度高（通过调整时间窗口的大小来实现不同的限流效果）</li><li>可扩展性强（可以非常容易地与其他限流算法结合使用）</li></ul><p><strong>缺点</strong>：</p><ul><li>突发流量无法处理（<strong>无法应对短时间内的大量请求，但是一旦到达限流后，请求都会直接暴力被拒绝。导致我们会损失一部分请求，这其实对于产品来说，并不太友好</strong>），需要合理调整时间窗口大小。</li></ul><h2 id="漏桶限流算法"><a href="#漏桶限流算法" class="headerlink" title="漏桶限流算法"></a>漏桶限流算法</h2><h3 id="什么是漏桶限流算法"><a href="#什么是漏桶限流算法" class="headerlink" title="什么是漏桶限流算法"></a>什么是漏桶限流算法</h3><p>漏桶限流算法（<code>Leaky Bucket Algorithm</code>）是一种流量控制算法，用于控制流入网络的数据速率，以防止网络拥塞。它的思想是将数据包看作是水滴，漏桶看作是一个固定容量的水桶，数据包像水滴一样从桶的顶部流入桶中，并通过桶底的一个小孔以一定的速度流出，从而限制了数据包的流量。</p><blockquote><p>漏桶限流算法的基本工作原理是：对于每个到来的数据包，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。如果超过了容量，就将多余的数据包丢弃。如果漏桶中还有水，就以一定的速率从桶底输出数据包，保证输出的速率不超过预设的速率，从而达到限流的目的。</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/52a145e7ed8f442b930e12f42d6b112b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom: 50%;" /></p><ul><li>流入的水滴，可以看作是访问系统的请求，这个流入速率是不确定的。</li><li>桶的容量一般表示系统所能处理的请求数。</li><li>如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）</li><li>流出的水滴，是恒定过滤的，对应服务按照固定的速率处理请求。</li></ul><h3 id="3-2-漏桶限流算法的伪代码实现"><a href="#3-2-漏桶限流算法的伪代码实现" class="headerlink" title="3.2 漏桶限流算法的伪代码实现"></a>3.2 漏桶限流算法的伪代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LeakyBucket 类表示一个漏桶,</span></span><br><span class="line"><span class="comment"> * 包含了桶的容量和漏桶出水速率等参数，</span></span><br><span class="line"><span class="comment"> * 以及当前桶中的水量和上次漏水时间戳等状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> capacity;    <span class="comment">// 桶的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> rate;        <span class="comment">// 漏桶出水速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> water;             <span class="comment">// 当前桶中的水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastLeakTimestamp; <span class="comment">// 上次漏水时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucket</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.water = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lastLeakTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryConsume() 方法用于尝试向桶中放入一定量的水，如果桶中还有足够的空间，则返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waterRequested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryConsume</span><span class="params">(<span class="type">long</span> waterRequested)</span> &#123;</span><br><span class="line">        leak();</span><br><span class="line">        <span class="keyword">if</span> (water + waterRequested &lt;= capacity) &#123;</span><br><span class="line">            water += waterRequested;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 。leak() 方法用于漏水，根据当前时间和上次漏水时间戳计算出应该漏出的水量，然后更新桶中的水量和漏水时间戳等状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leak</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> now - lastLeakTimestamp;</span><br><span class="line">        <span class="type">long</span> <span class="variable">leakedWater</span> <span class="operator">=</span> elapsedTime * rate / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (leakedWater &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            water = Math.max(<span class="number">0</span>, water - leakedWater);</span><br><span class="line">            lastLeakTimestamp = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意:   <code>tryConsume()</code> 和 <code>leak()</code>方法中，都需要对桶的状态进行同步，以保证线程安全性。</li></ul><h3 id="漏桶限流算法的优缺点"><a href="#漏桶限流算法的优缺点" class="headerlink" title="漏桶限流算法的优缺点"></a>漏桶限流算法的优缺点</h3><p><strong>优点</strong></p><ul><li>可以平滑限制请求的处理速度，避免瞬间请求过多导致系统崩溃或者雪崩。</li><li>可以控制请求的处理速度，使得系统可以适应不同的流量需求，避免过载或者过度闲置。</li><li>可以通过调整桶的大小和漏出速率来满足不同的限流需求，可以灵活地适应不同的场景。</li></ul><p><strong>缺点</strong></p><ul><li>需要对请求进行缓存，会增加服务器的内存消耗。</li><li>对于流量波动比较大的场景，需要较为灵活的参数配置才能达到较好的效果。</li><li>但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。</li></ul><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><h3 id="什么是令牌桶算法"><a href="#什么是令牌桶算法" class="headerlink" title="什么是令牌桶算法"></a>什么是令牌桶算法</h3><blockquote><p>令牌桶算法是<strong>一种常用的限流算法</strong>，可以用于限制单位时间内请求的数量。该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/54adea2ed3cb42fe98f9491f7f474cbb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="令牌桶算法的伪代码实现"><a href="#令牌桶算法的伪代码实现" class="headerlink" title="令牌桶算法的伪代码实现"></a>令牌桶算法的伪代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TokenBucket 类表示一个令牌桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;     <span class="comment">// 令牌桶容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> rate;         <span class="comment">// 令牌生成速率，单位：令牌/秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tokens;             <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastRefillTimestamp;  <span class="comment">// 上次令牌生成时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数中传入令牌桶的容量和令牌生成速率。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucket</span><span class="params">(<span class="type">int</span> capacity, <span class="type">int</span> rate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.rate = rate;</span><br><span class="line">        <span class="built_in">this</span>.tokens = capacity;</span><br><span class="line">        <span class="built_in">this</span>.lastRefillTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * allowRequest() 方法表示一个请求是否允许通过，该方法使用 synchronized 关键字进行同步，以保证线程安全。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allowRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        refill();</span><br><span class="line">        <span class="keyword">if</span> (tokens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tokens--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * refill() 方法用于生成令牌，其中计算令牌数量的逻辑是按照令牌生成速率每秒钟生成一定数量的令牌，</span></span><br><span class="line"><span class="comment">     * tokens 变量表示当前令牌数量，</span></span><br><span class="line"><span class="comment">     * lastRefillTimestamp 变量表示上次令牌生成的时间戳。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &gt; lastRefillTimestamp) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">generatedTokens</span> <span class="operator">=</span> (<span class="type">int</span>) ((now - lastRefillTimestamp) / <span class="number">1000</span> * rate);</span><br><span class="line">            tokens = Math.min(tokens + generatedTokens, capacity);</span><br><span class="line">            lastRefillTimestamp = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="令牌桶算法的优缺点"><a href="#令牌桶算法的优缺点" class="headerlink" title="令牌桶算法的优缺点"></a>令牌桶算法的优缺点</h3><p><strong>优点：</strong></p><ul><li><strong>稳定性高</strong>：令牌桶算法可以控制请求的处理速度，可以使系统的负载变得稳定。</li><li><strong>精度高</strong>：令牌桶算法可以根据实际情况动态调整生成令牌的速率，可以实现较高精度的限流。</li><li><strong>弹性好</strong>：令牌桶算法可以处理突发流量，可以在短时间内提供更多的处理能力，以处理突发流量。</li></ul><p><code>Guava</code>的<code>RateLimiter</code>限流组件，就是基于令牌桶算法实现的。</p><p><strong>缺点：</strong></p><ul><li>实现复杂：相对于固定窗口算法等其他限流算法，令牌桶算法的实现较为复杂。 对短时请求难以处理：在短时间内有大量请求到来时，可能会导致令牌桶中的令牌被快速消耗完，从而限流。这种情况下，可以考虑使用漏桶算法。</li><li>时间精度要求高：令牌桶算法需要在固定的时间间隔内生成令牌，因此要求时间精度较高，如果系统时间不准确，可能会导致限流效果不理想。</li></ul><p>总体来说，令牌桶算法具有较高的稳定性和精度，但实现相对复杂，适用于对稳定性和精度要求较高的场景。</p><h3 id="令牌桶和漏桶对比"><a href="#令牌桶和漏桶对比" class="headerlink" title="令牌桶和漏桶对比"></a>令牌桶和漏桶对比</h3><ul><li>令牌桶是按照<strong>固定速率</strong>往桶中<strong>添加</strong>令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；</li><li>漏桶则是按照常量<strong>固定速率流出</strong>请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</li><li>令牌桶<strong>限制的是平均流入速率</strong>（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；</li><li>漏桶限制的是<strong>常量流出速率</strong>（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；</li><li>令牌桶<strong>允许</strong>一定程度的<strong>突发</strong>，而漏桶主要目的是<strong>平滑流入速率</strong>；</li><li>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</li></ul><hr><p>参考文章：<a href="https://pdai.tech/md/arch/arch-y-ratelimit.html">https://pdai.tech/md/arch/arch-y-ratelimit.html</a></p><p><a href="https://juejin.cn/post/7209504489010430010">https://juejin.cn/post/7209504489010430010</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式协同</title>
      <link href="/mingyry/6f01c864.html"/>
      <url>/mingyry/6f01c864.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式协同"><a href="#分布式协同" class="headerlink" title="分布式协同"></a>分布式协同</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h3><blockquote><p>要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。</p></blockquote><ul><li><strong>线程锁</strong>：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。</li><li><strong>进程锁</strong>：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。</li><li><strong>分布式锁</strong>：当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问。</li></ul><h3 id="分布式锁的设计原则"><a href="#分布式锁的设计原则" class="headerlink" title="分布式锁的设计原则"></a>分布式锁的设计原则</h3><blockquote><p>分布式锁的最小设计原则：<strong>安全性</strong>和<strong>有效性</strong></p></blockquote><p><a href="https://redis.io/docs/reference/patterns/distributed-locks/">Redis的官网</a>上对使用分布式锁提出至少需要满足如下三个要求：</p><ol><li><strong>互斥</strong>（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。</li><li><strong>无死锁</strong>（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。</li><li><strong>容错性</strong>（属于有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。</li></ol><p>除此之外，分布式锁的设计中还可以/需要考虑：</p><ol><li>加锁解锁的<strong>同源性</strong>：A加的锁，不能被B解锁</li><li>获取锁是<strong>非阻塞</strong>的：如果获取不到锁，不能无限期等待；</li><li><strong>高性能</strong>：加锁解锁是高性能的</li></ol><h3 id="分布式锁的实现方案"><a href="#分布式锁的实现方案" class="headerlink" title="分布式锁的实现方案"></a>分布式锁的实现方案</h3><blockquote><p>就体系的角度而言，谈谈常见的分布式锁的实现方案。</p></blockquote><ul><li><strong>基于数据库实现分布式锁</strong><ul><li>基于数据库表（锁表，很少使用）</li><li>乐观锁(基于版本号)</li><li>悲观锁(基于排它锁)</li></ul></li><li><strong>基于 redis 实现分布式锁:</strong><ul><li>单个Redis实例：setnx(key,当前时间+过期时间) + Lua</li><li>Redis集群模式：Redlock</li></ul></li><li><strong>基于 zookeeper实现分布式锁</strong><ul><li>临时有序节点来实现的分布式锁,Curator</li></ul></li><li><strong>基于 Consul 实现分布式锁</strong></li></ul><h3 id="基于数据库如何实现分布式锁？有什么缺陷？"><a href="#基于数据库如何实现分布式锁？有什么缺陷？" class="headerlink" title="基于数据库如何实现分布式锁？有什么缺陷？"></a>基于数据库如何实现分布式锁？有什么缺陷？</h3><h4 id="基于悲观锁"><a href="#基于悲观锁" class="headerlink" title="基于悲观锁"></a>基于悲观锁</h4><p><strong>悲观锁实现思路</strong>？</p><ol><li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li><li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li><li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li><li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ol><p><strong>以MySQL InnoDB中使用悲观锁为例</strong>？</p><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;<span class="operator">/</span><span class="keyword">begin</span> work;<span class="operator">/</span><span class="keyword">start</span> transaction; (三者选一就可以)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (id,goods_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">4.</span>提交事务</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="keyword">commit</span> work;</span><br></pre></td></tr></table></figure><p>上面的查询语句中，我们使用了<code>select…for update</code>的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用<code>select…for update</code>会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p><h4 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h4><p>乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p><strong>以使用版本号实现乐观锁为例？</strong></p><p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (status,status,version) <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p><ul><li><strong>缺陷</strong></li></ul><p>对数据库依赖，开销问题，行锁变表锁问题，无法解决数据库单点和可重入的问题。</p><h3 id="基于redis如何实现分布式锁？有什么缺陷？"><a href="#基于redis如何实现分布式锁？有什么缺陷？" class="headerlink" title="基于redis如何实现分布式锁？有什么缺陷？"></a>基于redis如何实现分布式锁？有什么缺陷？</h3><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p><h4 id="Redis-分布式锁原理"><a href="#Redis-分布式锁原理" class="headerlink" title="Redis 分布式锁原理"></a>Redis 分布式锁原理</h4><p>这个分布式锁有 3 个重要的考量点：</p><ol><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 redis 节点创建了这把锁就可以）</li></ol><p>对应的 Redis 指令如下：</p><ul><li><code>setnx</code> - <code>setnx key val</code>：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li><li><code>expire</code> - <code>expire key timeout</code>：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li><li><code>delete</code> - <code>delete key</code>：删除 key</li></ul><blockquote><p>注意：</p><p>不要将 <code>setnx</code> 和 <code>expire</code> 作为两个命令组合实现加锁，这样就<strong>无法保证原子性</strong>。如果客户端在 <code>setnx</code> 之后崩溃，那么将导致锁无法释放。正确的做法应是在 <code>setnx</code> 命令中指定 <code>expire</code> 时间。</p></blockquote><h4 id="Redis-分布式锁实现"><a href="#Redis-分布式锁实现" class="headerlink" title="Redis 分布式锁实现"></a>Redis 分布式锁实现</h4><p>（1）申请锁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure><p>执行这个命令就 ok。</p><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li><li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li></ul><p>（2）释放锁</p><p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Redis分布式锁小结"><a href="#Redis分布式锁小结" class="headerlink" title="Redis分布式锁小结"></a>Redis分布式锁小结</h4><p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p><p>但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h4 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h4><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><p><a href="https://gitee.com/link?target=https%3A%2F%2Fredis.io%2F">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://gitee.com/link?target=https%3A%2F%2Fredis.io%2Ftopics%2Fdistlock">https://redis.io/topics/distlock</a> 。</p><h4 id="基于Redis的客户端"><a href="#基于Redis的客户端" class="headerlink" title="基于Redis的客户端"></a>基于Redis的客户端</h4><blockquote><p>这里Redis的客户端（Jedis, Redisson, Lettuce等）都是基于上述两类形式来实现分布式锁的，只是两类形式的封装以及一些优化（比如Redisson的watch dog)。</p></blockquote><p>以基于Redisson实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：</p><p><strong>特色</strong>？</p><ol><li>redisson所有指令都通过lua脚本执行，保证了操作的原子性</li><li>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</li><li>redisson支持Redlock的实现方式。</li></ol><p><strong>过程</strong>？</p><ol><li>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</li><li>线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</li></ol><p><strong>互斥</strong>？</p><p>如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在。接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl myLock返回的一个数字，代表myLock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不听的尝试加锁。</p><p><strong>watch dog自动延时机制</strong>？</p><p>客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。</p><p><strong>可重入</strong>？</p><p>每次lock会调用incrby，每次unlock会减一。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。</p><h3 id="ZooKeeper-分布式锁"><a href="#ZooKeeper-分布式锁" class="headerlink" title="ZooKeeper 分布式锁"></a>ZooKeeper 分布式锁</h3><h4 id="ZooKeeper-分布式锁原理"><a href="#ZooKeeper-分布式锁原理" class="headerlink" title="ZooKeeper 分布式锁原理"></a>ZooKeeper 分布式锁原理</h4><p>ZooKeeper 实现分布式锁基于 ZooKeeper 的两个特性：</p><ul><li><strong>顺序临时节点</strong>：ZooKeeper 的存储类似于 DNS 那样的具有层级的命名空间。ZooKeeper 节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），每个节点还能被标记为有序性（SEQUENTIAL），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。</li><li><strong>Watch 机制</strong>：ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在特定事件触发的时候，ZooKeeper 服务端会将事件通知给用户。</li></ul><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h4 id="ZooKeeper-分布式锁小结"><a href="#ZooKeeper-分布式锁小结" class="headerlink" title="ZooKeeper 分布式锁小结"></a>ZooKeeper 分布式锁小结</h4><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p><ul><li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li><li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li></ul><p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h3 id="分布式锁方案对比"><a href="#分布式锁方案对比" class="headerlink" title="分布式锁方案对比"></a>分布式锁方案对比</h3><p>数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐。</p><p>性能：</p><ul><li>Redis 分布式锁，其实<strong>需要自己不断自旋去尝试获取锁</strong>，比较消耗性能。</li><li>ZooKeeper 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li></ul><p>可靠性：</p><ul><li>如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；</li><li>而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</li></ul><p>综上分析，<strong>ZooKeeper 实现分布式锁更加的简单，可靠性更高</strong></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="如何理解分布式事务"><a href="#如何理解分布式事务" class="headerlink" title="如何理解分布式事务"></a>如何理解分布式事务</h3><blockquote><p>分布式的理论角度和分布式事务的知识体系角度理解分布式事务。</p></blockquote><h4 id="从分布式的理论的角度看"><a href="#从分布式的理论的角度看" class="headerlink" title="从分布式的理论的角度看"></a>从分布式的理论的角度看</h4><blockquote><p>分布式的理论基础是CAP，由于P(分区容错）是必选项，所以只能在AP或者CP中选择。</p></blockquote><ul><li><strong>分布式理论的CP</strong> -&gt; 刚性事务</li></ul><p>遵循ACID，对数据要求强一致性</p><ul><li><strong>分布式理论的AP+BASE</strong> -&gt; 柔性事务</li></ul><p>遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。</p><h4 id="从分布式事务的体系看"><a href="#从分布式事务的体系看" class="headerlink" title="从分布式事务的体系看"></a>从分布式事务的体系看</h4><blockquote><p>我在梳理这个体系时，发现网上几乎都直接写2PC,3PC,TCC,Seata方案，而实际上这是不成体系的。从分布式事务的体系看，我认为至少应该理清楚，什么是技术方案，什么是中间件，以及形成这些方案的依据；</p></blockquote><p>如下图，可以帮助你构筑分布式事务的知识体系，一目了然。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-transection-1.png" alt="img"></p><ul><li><strong>刚性事务</strong>：分布式理论的CP，遵循ACID，对数据要求强一致性。<ul><li><strong>XA协议</strong> 是一个基于数据库层面的分布式事务协议，其分为两部分：事务管理器（Transaction Manager）<strong>和</strong>本地资源管理器（Resource Manager）。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。主流的诸如Oracle、MySQL等数据库均已实现了XA接口。 <ul><li><strong>二阶提交协议（2PC）</strong>: 根据XA协议衍生出来而来; 引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交; 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。所谓的两个阶段是指：第一阶段：准备阶段 (投票阶段) 和第二阶段：提交阶段（执行阶段）</li><li><strong>三阶提交协议（3PC）</strong>: 是对两段提交（2PC）的一种升级优化，<strong>3PC在2PC的第一阶段和第二阶段中插入一个准备阶段</strong>。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题。</li></ul></li><li><strong>Java事务规范</strong><ul><li><strong>JTA</strong>： Java事务API（Java Transaction API）是一个Java企业版的应用程序接口，在Java环境中，允许完成跨越多个XA资源的分布式事务。</li><li><strong>JTS</strong>： Java事务服务（Java Transaction Service）是J2EE平台提供了分布式事务服务的具体实现规范，j2ee服务器提供商根据JTS规范实现事务并提供JTA接口。</li></ul></li></ul></li><li><strong>柔性事务</strong>：分布式理论的AP，遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。<ul><li><strong>基于业务层</strong><ul><li><strong>TCC</strong>:  TCC（Try-Confirm-Cancel）又被称补偿事务，TCC与2PC的思想很相似，事务处理流程也很相似，但2PC是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现。</li><li><strong>SAGA</strong>： Saga是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。Saga的实现有很多种方式，其中最流行的两种方式是：基于事件的方式和基于命令的方式。</li></ul></li><li><strong>最终一致性</strong><ul><li><strong>消息表</strong>：本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</li><li><strong>消息队列</strong>：基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</li><li><strong>最大努力通知</strong>：最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</li></ul></li></ul></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.nenggz.com/md/arch/arch-z-lock.html">https://www.nenggz.com/md/arch/arch-z-lock.html</a></p><p><a href="https://dunwu.github.io/blog/categories/">https://dunwu.github.io/blog/categories/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式协同 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式调度</title>
      <link href="/mingyry/74281dcb.html"/>
      <url>/mingyry/74281dcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式调度"><a href="#分布式调度" class="headerlink" title="分布式调度"></a>分布式调度</h1><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><h3 id="为什么需要全局唯一ID"><a href="#为什么需要全局唯一ID" class="headerlink" title="为什么需要全局唯一ID"></a>为什么需要全局唯一ID</h3><p>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT=1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。</p><h3 id="ID过于明显的问题"><a href="#ID过于明显的问题" class="headerlink" title="ID过于明显的问题"></a>ID过于明显的问题</h3><ol><li><strong>安全性问题</strong>，容易被暴力破解，并且根据id规律推断其他用户的id</li><li><strong>隐私泄露风险</strong></li><li><strong>数据可预测性</strong>，能够轻易的猜测订单或者交易的信息，并且推断交易数目</li><li><strong>扩展性受限</strong>，可能会导致多个操作同时对同一资源进行竞争，从而增加冲突和性能瓶颈</li><li><strong>维护困难</strong>，需要额外的资源和机制来保证规律的更新和变化</li></ol><p>阿里巴巴《Java 开发手册》提出单表行数超过500万行或者单表容量超过 2GB 就需要考虑分库分表了</p><p>解决上述问题，就需要使用分布式ID（也称全局唯一ID），满足以下特点：</p><ol><li><strong>全局唯一性：</strong>保证在整个分布式系统中唯一性，不会出现重复的标识符</li><li><strong>高可用性：</strong>可以通过水平扩展、冗余备份或集群部署来确保服务的可用性</li><li><strong>安全性：</strong>独立于应用程序和业务逻辑，被设计为一个单独的组件或服务</li><li><strong>高性能：</strong>要求在很短的时间内生成唯一的标识符，采用高效的算法和数据结构，以及优化的网络通信和存储策略。</li><li><strong>递增性：</strong>设计成可按时间顺序排序，以便更容易对生成的ID进行索引、检索或排序操作。这对于一些场景，如日志记录和事件溯源等，非常重要。</li></ol><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p><code>UUID （Universally Unique Identifier）</code>，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 <code>16^32=2^128</code>，约等于 <code>3.4 x 10^38</code>。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p><p>生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符’ - ‘，一般我们使用的时候会将连字符删除 uuid.<code>toString().replaceAll(&quot;-&quot;,&quot;&quot;)</code>。</p><p>目前UUID的产生方式有5种版本，每个版本的算法不同，应用范围也不同。</p><ul><li><code>基于时间的UUID</code> - 版本1： 这个一般是通过当前时间，随机数，和本地Mac地址来计算出来，可以通过 org.apache.logging.log4j.core.util包中的 UuidUtil.getTimeBasedUuid()来使用或者其他包中工具。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好。</li><li><code>DCE安全的UUID</code> - 版本2 DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</li><li><code>基于名字的UUID（MD5）</code>- 版本3 基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</li><li><code>随机UUID</code> - 版本4 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本。</li><li><code>基于名字的UUID（SHA1）</code> - 版本5 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</li></ul><p>我们 Java中 JDK自带的 UUID产生方式就是版本4根据随机数生成的 UUID 和版本3基于名字的 UUID，有兴趣的可以去看看它的源码。</p><p><strong>虽然 UUID 生成方便，本地生成没有网络消耗，但是使用起来也有一些缺点</strong>：</p><ul><li><strong>不易于存储</strong>：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li><li><strong>信息不安全</strong>：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，暴露使用者的位置。</li><li><strong>对MySQL索引不利</strong>：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能，可以查阅 Mysql 索引原理 B+树的知识。</li></ul><h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>是不是一定要基于外界的条件才能满足分布式唯一ID的需求呢，我们能不能在我们分布式数据库的基础上获取我们需要的ID？</p><p>由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。</p><p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增。</p><ul><li><code>auto_increment_offset</code>：表示自增长字段从那个数开始，他的取值范围是1 .. 65535。</li><li><code>auto_increment_increment</code>：表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535。</li></ul><p>假设有三台机器，则DB1中order表的起始ID值为1，DB2中order表的起始值为2，DB3中order表的起始值为3，它们自增的步长都为3，则它们的ID生成范围如下图所示：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-id-2.png" alt="img"></p><p>通过这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。</p><p>但是缺点也很明显，首先它<strong>强依赖DB</strong>，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是<strong>数据一致性在特殊情况下难以保证</strong>。主从切换时的不一致可能会导致重复发号。还有就是<strong>ID发号性能瓶颈限制在单台MySQL的读写性能</strong>。</p><h3 id="使用Redis实现"><a href="#使用Redis实现" class="headerlink" title="使用Redis实现"></a>使用Redis实现</h3><p>Redis实现分布式唯一ID主要是通过提供像 <code>INCR</code> 和 <code>INCRBY</code> 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。</p><p>但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。</p><p>为了避免<strong>长期自增后数字过大可以通过与当前时间戳组合起来使用</strong>，另外为了保证并发和业务多线程的问题可以采用 Redis + Lua的方式进行编码，保证安全。</p><p><strong>Redis使用：时间戳+序列号+数据库自增</strong></p><p>Redis 实现分布式全局唯一ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于redis，<strong>需要系统引进redis组件，增加了系统的配置复杂性</strong>。</p><p>当然现在Redis的使用性很普遍，所以如果其他业务已经引进了Redis集群，则可以资源利用考虑使用Redis来实现。</p><h3 id="雪花算法-Snowflake"><a href="#雪花算法-Snowflake" class="headerlink" title="雪花算法-Snowflake"></a>雪花算法-Snowflake</h3><p>Snowflake，雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的。</p><p><strong>第1位</strong>占用1bit，其值始终是0，可看做是符号位不使用。</p><p><strong>第2位</strong>开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是<code>(1L&lt;&lt;41)/(1000L360024*365)</code>=69 年的时间。</p><p><strong>中间的10-bit位</strong>可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。</p><p><strong>最后12-bit位</strong>是自增序列，可表示2^12 = 4096个数。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-id-3.png" alt="img"></p><p><strong>雪花算法提供了一个很好的设计思想，雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活</strong>。</p><p>但是雪花算法强<strong>依赖机器时钟</strong>，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。官方对于此并没有给出解决方案，而是简单的抛错处理，这样会造成在时间被追回之前的这段时间服务不可用。</p><p>很多其他类雪花算法也是在此思想上的设计然后改进规避它的缺陷，后面介绍的<code>百度 UidGenerator</code> 和 <code>美团分布式ID生成系统 Leaf</code> 中snowflake模式都是在 snowflake 的基础上演进出来的。</p><h3 id="Mist-薄雾算法"><a href="#Mist-薄雾算法" class="headerlink" title="Mist 薄雾算法"></a>Mist 薄雾算法</h3><blockquote><p>如下内容摘自 <a href="https://github.com/asyncins/mist/tree/master">GitHub中项目README</a></p></blockquote><p>薄雾算法是不同于 snowflake 的全局唯一 ID 生成算法。相比 snowflake ，薄雾算法具有更高的数值上限和更长的使用期限。</p><h4 id="薄雾算法的设计思路是怎么样的？"><a href="#薄雾算法的设计思路是怎么样的？" class="headerlink" title="薄雾算法的设计思路是怎么样的？"></a>薄雾算法的设计思路是怎么样的？</h4><p>薄雾算法采用了与 snowflake 相同的位数——64，在考量业务场景和要求后并没有沿用 1-41-10-12 的占位，而是采用了 1-47-8-8 的占位。即：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 1      2                                                     48         56       64</span><br><span class="line">* +------+-----------------------------------------------------+----------+----------+</span><br><span class="line">* retain | increas                                             | salt     | salt |</span><br><span class="line">* +------+-----------------------------------------------------+----------+----------+</span><br><span class="line">* 0      | 0000000000 0000000000 0000000000 0000000000 0000000 | 00000000 | 00000000 |</span><br><span class="line">* +------+-----------------------------------------------------+------------+--------+</span><br></pre></td></tr></table></figure><ul><li>第一段为最高位，占 1 位，保持为 0，使得值永远为正数；</li><li>第二段放置自增数，占 47 位，自增数在高位能保证结果值呈递增态势，遂低位可以为所欲为；</li><li>第三段放置随机因子一，占 8 位，上限数值 255，使结果值不可预测；</li><li>第四段放置随机因子二，占 8 位，上限数值 255，使结果值不可预测；</li></ul><h4 id="薄雾算法生成的数值是什么样的？"><a href="#薄雾算法生成的数值是什么样的？" class="headerlink" title="薄雾算法生成的数值是什么样的？"></a>薄雾算法生成的数值是什么样的？</h4><p>薄雾自增数为 1～10 的运行结果类似如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">171671</span><br><span class="line">250611</span><br><span class="line">263582</span><br><span class="line">355598</span><br><span class="line">427749</span><br><span class="line">482010</span><br><span class="line">581550</span><br><span class="line">644278</span><br><span class="line">698636</span><br><span class="line">762474</span><br></pre></td></tr></table></figure><p>根据运行结果可知，薄雾算法能够满足“全局不重复，不可猜测且呈递增态势”的场景要求。</p><h4 id="为什么薄雾算法不受时间回拨影响？"><a href="#为什么薄雾算法不受时间回拨影响？" class="headerlink" title="为什么薄雾算法不受时间回拨影响？"></a>为什么薄雾算法不受时间回拨影响？</h4><p>snowflake 受时间回拨影响的根本原因是高位采用时间戳的二进制值，而薄雾算法的高位是按序递增的数值。结果值的大小由高位决定，遂薄雾算法不受时间回拨影响。</p><h4 id="为什么说薄雾算法的结果值不可预测？"><a href="#为什么说薄雾算法的结果值不可预测？" class="headerlink" title="为什么说薄雾算法的结果值不可预测？"></a>为什么说薄雾算法的结果值不可预测？</h4><p>考虑到“不可预测”的要求，薄雾算法的中间位是 8 位随机值，且末 8 位是也是随机值，两组随机值大大增加了预测难度，因此称为结果值不可预测。</p><p>中间位和末位随机值的开闭区间都是 [0, 255]，理论上随机值可以出现 <code>256 * 256</code> 种组合。</p><h4 id="当程序重启，薄雾算法的值会重复吗？"><a href="#当程序重启，薄雾算法的值会重复吗？" class="headerlink" title="当程序重启，薄雾算法的值会重复吗？"></a>当程序重启，薄雾算法的值会重复吗？</h4><p>snowflake 受时间回拨影响，一旦时间回拨就有极大概率生成重复的 ID。薄雾算法中的高位是按序递增的数值，程序重启会造成按序递增数值回到初始值，但由于中间位和末尾随机值的影响，因此不是必定生成（有大概率生成）重复 ID，但递增态势必定受到影响。</p><h4 id="薄雾算法的值会重复，那我要它干嘛？"><a href="#薄雾算法的值会重复，那我要它干嘛？" class="headerlink" title="薄雾算法的值会重复，那我要它干嘛？"></a>薄雾算法的值会重复，那我要它干嘛？</h4><p>1、无论是什么样的全局唯一 ID 生成算法，都会有优点和缺点。在实际的应用当中，没有人会将全局唯一 ID 生成算法完全托付给程序，而是会用数据库存储关键值或者所有生成的值。全局唯一 ID 生成算法大多都采用分布式架构或者主备架构提供发号服务，这时候就不用担心它的重复问题；</p><p>2、生成性能比雪花算法高太多倍；</p><p>3、代码少且简单，在大型应用中，单功能越简单越好；</p><h4 id="是否提供薄雾算法的工程实践或者架构实践？"><a href="#是否提供薄雾算法的工程实践或者架构实践？" class="headerlink" title="是否提供薄雾算法的工程实践或者架构实践？"></a>是否提供薄雾算法的工程实践或者架构实践？</h4><p>是的，作者的另一个项目 <a href="https://github.com/asyncins/medis">Medis</a> 是薄雾算法与 Redis 的结合，实现了“全局不重复”，你再也不用担心程序重启带来的问题。</p><h4 id="薄雾算法的分布式架构，推荐-CP-还是-AP？"><a href="#薄雾算法的分布式架构，推荐-CP-还是-AP？" class="headerlink" title="薄雾算法的分布式架构，推荐 CP 还是 AP？"></a>薄雾算法的分布式架构，推荐 CP 还是 AP？</h4><p>CAP 是分布式架构中最重要的理论，C 指的是一致性、A 指的是可用性、P 指的是分区容错性。CAP 当中，C 和 A 是互相冲突的，且 P 一定存在，遂我们必须在 CP 和 AP 中选择。<strong>实际上这跟具体的业务需求有关</strong>，但是对于全局唯一 ID 发号服务来说，大多数时候可用性比一致性更重要，也就是选择 AP 会多过选择 CP。至于你怎么选，还是得结合具体的业务场景考虑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上基本列出了所有常用的分布式ID生成方式，其实大致分类的话可以分为两类：</p><ul><li><strong>一种是类DB型的</strong>，根据设置不同起始值和步长来实现趋势递增，需要考虑服务的容错性和可用性。</li><li><strong>另一种是类snowflake型</strong>，这种就是将64位划分为不同的段，每段代表不同的涵义，基本就是时间戳、机器ID和序列数。这种方案就是需要考虑时钟回拨的问题以及做一些 buffer的缓冲设计提高性能。</li></ul><p>而且可通过将三者（时间戳，机器ID，序列数）划分不同的位数来改变使用寿命和并发数。</p><p>例如对于并发数要求不高、期望长期使用的应用，可增加时间戳位数，减少序列数的位数. 例如配置成<code>&#123;&quot;workerBits&quot;:23,&quot;timeBits&quot;:31,&quot;seqBits&quot;:9&#125;</code>时, 可支持28个节点以整体并发量14400 UID/s的速度持续运行68年。</p><p>对于节点重启频率频繁、期望长期使用的应用, 可增加工作机器位数和时间戳位数, 减少序列数位数. 例如配置成<code>&#123;&quot;workerBits&quot;:27,&quot;timeBits&quot;:30,&quot;seqBits&quot;:6&#125;</code>时, 可支持37个节点以整体并发量2400 UID/s的速度持续运行34年。</p><h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><blockquote><p>Session + Cookie 会话方案比较简单，这里我在网上找了点资料，再回顾下基础吧。</p></blockquote><h4 id="为什么要产生Session"><a href="#为什么要产生Session" class="headerlink" title="为什么要产生Session"></a>为什么要产生Session</h4><p>http协议本身是无状态的，客户端只需要向服务器请求下载内容，客户端和服务器都不记录彼此的历史信息，每一次请求都是独立的。</p><p>为什么是无状态的呢？因为浏览器与服务器是使用socke套接字进行通信，服务器将请求结果返回给浏览器之后，会关闭当前的socket链接，而且服务器也会在处理页面完毕之后销毁页面对象。</p><p>然而在Web应用的很多场景下需要维护用户状态才能正常工作(是否登录等)，或者说提供便捷(记住密码，浏览历史等)，状态的保持就是一个很重要的功能。因此在web应用开发里就出现了保持http链接状态的技术：一个是cookie技术，另一种是session技术。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p><p>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><h4 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h4><p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p><p>一个简单的 cookie 设置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br><span class="line">HTTP/2.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure><h4 id="Cookie-的工作步骤"><a href="#Cookie-的工作步骤" class="headerlink" title="Cookie 的工作步骤"></a>Cookie 的工作步骤</h4><ol><li>浏览器请求服务器，如果服务器需要记录该用户的状态，就是用 response 向浏览器颁发一个 Cookie。</li><li>浏览器会把 Cookie 保存下来。</li><li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li></ol><h4 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h4><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。\</em></strong></p><h4 id="Cookie-的重要属性"><a href="#Cookie-的重要属性" class="headerlink" title="Cookie 的重要属性"></a>Cookie 的重要属性</h4><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong>。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td></tr><tr><td><strong>maxAge</strong></td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table></div><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h4><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/16f523a04d0b3cf5~tplv-t2oaga2asx-watermark.awebp" alt="session.png"></p><h4 id="Session-的工作步骤"><a href="#Session-的工作步骤" class="headerlink" title="Session 的工作步骤"></a>Session 的工作步骤</h4><ol><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p>Cookie 和 Session 的主要区别可以参考以下表格：</p><div class="table-container"><table><thead><tr><th></th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td><strong>作用范围</strong></td><td>保存在客户端（浏览器）</td><td>保存在服务器端</td></tr><tr><td><strong>隐私策略</strong></td><td>存储在客户端，比较容易遭到非法获取</td><td>存储在服务端，安全性相对 Cookie 要好一些</td></tr><tr><td><strong>存储方式</strong></td><td>只能保存 ASCII</td><td>可以保存任意数据类型。 一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</td></tr><tr><td><strong>存储大小</strong></td><td>不能超过 4K</td><td>存储大小远高于 Cookie</td></tr><tr><td><strong>生命周期</strong></td><td>可设置为永久保存 比如我们经常使用的默认登录（记住我）功能</td><td>一般失效时间较短 客户端关闭或者 Session 超时都会失效。</td></tr></tbody></table></div><h3 id="如果禁用-Cookie-怎么办"><a href="#如果禁用-Cookie-怎么办" class="headerlink" title="如果禁用 Cookie 怎么办"></a>如果禁用 Cookie 怎么办</h3><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p><p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p><h3 id="会话技术的发展"><a href="#会话技术的发展" class="headerlink" title="会话技术的发展"></a>会话技术的发展</h3><blockquote><p>会话技术的发展?</p></blockquote><ul><li>单机 - Session + Cookie</li><li>多机器 <ul><li>在负载均衡侧 - Session 粘滞</li><li>Session数据同步</li></ul></li><li>多机器，集群 - session集中管理，比如redis；目前方案上用的最多的是Spring Session，早前也有用tomcat集成方式的。</li><li>无状态token，比如JWT</li></ul><h3 id="分布式会话的方案"><a href="#分布式会话的方案" class="headerlink" title="分布式会话的方案"></a>分布式会话的方案</h3><h4 id="Session-Stick"><a href="#Session-Stick" class="headerlink" title="Session Stick"></a>Session Stick</h4><blockquote><p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-2.png" alt="img"></p><p>这种方案实现比较简单，对于Web服务器来说和单机的情况一样。但是可能会带来如下问题：</p><ul><li>如果有一台服务器宕机或者重启，那么这台机器上的会话数据会全部丢失。</li><li>会话标识是应用层信息，那么负载均衡要将同一个会话的请求都保存到同一个Web服务器上的话，就需要进行应用层（第7层）的解析，这个开销比第4层大。</li><li>负载均衡器将变成一个有状态的节点，要将会话保存到具体Web服务器的映射。和无状态节点相比，内存消耗更大，容灾方面也会更麻烦。</li></ul><h4 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h4><p>Session Replication 的方案则不对负载均衡器做更改，而是在Web服务器之间增加了会话数据同步的功能，各个服务器之间通过同步保证不同Web服务器之间的Session数据的一致性，如下图所示。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-2.png" alt="img"></p><p>Session Replication 方案对负载均衡器不再有要求，但是同样会带来以下问题：</p><ul><li>同步Session数据会造成额外的网络带宽的开销，只要Session数据有变化，就需要将新产生的Session数据同步到其他服务器上，服务器数量越多，同步带来的网络带宽开销也就越大。</li><li>每台Web服务器都需要保存全部的Session数据，如果整个集群的Session数量太多的话，则对于每台机器用于保存Session数据的占用会很严重。</li></ul><h4 id="Session-数据集中存储"><a href="#Session-数据集中存储" class="headerlink" title="Session 数据集中存储"></a>Session 数据集中存储</h4><p>Session 数据集中存储方案则是将集群中的所有Session集中存储起来，Web服务器本身则并不存储Session数据，不同的Web服务器从同样的地方来获取Session，如下图所示。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-3.png" alt="img"></p><p>相对于Session Replication方案，此方案的Session数据将不保存在本机，并且Web服务器之间也没有了Session数据的复制，但是该方案存在的问题在于：</p><ul><li>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，但是通信发生在内网，则问题不大。</li><li>如果集中存储Session的机器或集群出现问题，则会影响应用。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>JSON Web Token，一般用它来替换掉Session实现数据共享。</p><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ul><li>1、客户端通过用户名和密码登录服务器；</li><li>2、服务端对客户端身份进行验证；</li><li>3、服务端对该用户生成Token，返回给客户端；</li><li>4、客户端将Token保存到本地浏览器，一般保存到cookie中；</li><li>5、客户端发起请求，需要携带该Token；</li><li>6、服务端收到请求后，首先验证Token，之后返回数据。</li></ul><h3 id="JWT-Token"><a href="#JWT-Token" class="headerlink" title="JWT Token"></a>JWT Token</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p><h3 id="Spring-session-redis"><a href="#Spring-session-redis" class="headerlink" title="Spring session + redis"></a>Spring session + redis</h3><p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p><p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-session">sping session</a> 是一个很好的选择。</p><p>spring session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring session 从 redis 中获取数据了</p><h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><h3 id="定时任务和分布式任务介绍"><a href="#定时任务和分布式任务介绍" class="headerlink" title="定时任务和分布式任务介绍"></a>定时任务和分布式任务介绍</h3><h4 id="定时任务应用场景"><a href="#定时任务应用场景" class="headerlink" title="定时任务应用场景"></a>定时任务应用场景</h4><p>比如每天/每周/每月生成日志汇总，定时发送推送信息，定时生成数据表格等</p><h4 id="定时任务的基础"><a href="#定时任务的基础" class="headerlink" title="定时任务的基础"></a>定时任务的基础</h4><blockquote><p>Cron表达式是定时任务的基础。Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：</p></blockquote><ul><li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li><li>Seconds Minutes Hours DayofMonth Month DayofWeek</li></ul><h4 id="单体应用定时任务的演化"><a href="#单体应用定时任务的演化" class="headerlink" title="单体应用定时任务的演化"></a>单体应用定时任务的演化</h4><h5 id="cron-脚本定时任务"><a href="#cron-脚本定时任务" class="headerlink" title="cron+脚本定时任务"></a>cron+脚本定时任务</h5><p>Linux定时任务工具crontb</p><h5 id="JDK内置之Timer"><a href="#JDK内置之Timer" class="headerlink" title="JDK内置之Timer"></a>JDK内置之Timer</h5><p>JDK内置的Timer, 现在很少被使用。</p><blockquote><p>为什么几乎很少使用Timer这种方式？</p><p>Timer底层是使用一个单线来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。</p><p>如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。</p></blockquote><h5 id="JDK内置之ScheduleExecutorService"><a href="#JDK内置之ScheduleExecutorService" class="headerlink" title="JDK内置之ScheduleExecutorService"></a>JDK内置之ScheduleExecutorService</h5><p>ScheduledExecutorService是基于线程池的实现方式。</p><blockquote><p><strong>为什么用ScheduledExecutorService 代替 Timer</strong>？</p><p>上文我们说到Timer底层是使用一个单线程来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。</p><p>如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。</p><p>而ScheduledExecutorService是基于线程池的，可以开启多个线程进行执行多个任务，每个任务开启一个线程； 这样任务的延迟和未处理异常就不会影响其它任务的执行了</p></blockquote><h5 id="Netty之HashedWheelTimer"><a href="#Netty之HashedWheelTimer" class="headerlink" title="Netty之HashedWheelTimer"></a>Netty之HashedWheelTimer</h5><ul><li><strong>Netty的HashedWheelTimer要解决什么问题</strong></li></ul><p>在Netty中的一个典型应用场景是判断某个连接是否idle，如果idle（如客户端由于网络原因导致到服务器的心跳无法送达），则服务器会主动断开连接，释放资源。判断连接是否idle是通过定时任务完成的，但是Netty可能维持数百万级别的长连接，对每个连接去定义一个定时任务是不可行的，所以如何提升I/O超时调度的效率呢？</p><p>Netty根据时间轮(Timing Wheel)开发了HashedWheelTimer工具类，用来优化I/O超时调度(本质上是延迟任务）；之所以采用时间轮(Timing Wheel)的结构还有一个很重要的原因是I/O超时这种类型的任务对时效性不需要非常精准。</p><ul><li><strong>HashedWheelTimer的使用方式</strong></li></ul><p>通过构造函数看主要参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashedWheelTimer</span><span class="params">(</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> tickDuration, TimeUnit unit, <span class="type">int</span> ticksPerWheel, <span class="type">boolean</span> leakDetection,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> maxPendingTimeouts, Executor taskExecutor)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数说明如下：</p><ul><li><code>threadFactory</code>：线程工厂，用于创建工作线程， 默认是Executors.defaultThreadFactory()</li><li><code>tickDuration</code>：tick的周期，即多久tick一次</li><li><code>unit</code>: tick周期的单位</li><li><code>ticksPerWheel</code>：时间轮的长度，一圈下来有多少格</li><li><code>leakDetection</code>：是否开启内存泄漏检测，默认是true</li><li><code>maxPendingTimeouts</code>：最多执行的任务数，默认是-1，即不限制。在高并发量情况下才会设置这个参数。</li></ul><h5 id="Spring-Tasks"><a href="#Spring-Tasks" class="headerlink" title="Spring Tasks"></a>Spring Tasks</h5><p>Spring提供的schedule任务</p><p>具体使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔1分钟执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000 * 60 * 1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runScheduleFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;runScheduleFixedRate: current DateTime, &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个整点小时执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 */1 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runScheduleCron</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;runScheduleCron: current DateTime, &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@Scheduled所支持的参数</strong>：</li></ul><ol><li><code>cron</code>：cron表达式，指定任务在特定时间执行；</li><li><code>fixedDelay</code>：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；</li><li><code>fixedDelayString</code>：与fixedDelay含义一样，只是参数类型变为String；</li><li><code>fixedRate</code>：表示按一定的频率执行任务，参数类型为long，单位ms；</li><li><code>fixedRateString</code>: 与fixedRate的含义一样，只是将参数类型变为String；</li><li><code>initialDelay</code>：表示延迟多久再第一次执行任务，参数类型为long，单位ms；</li><li><code>initialDelayString</code>：与initialDelay的含义一样，只是将参数类型变为String；</li><li><code>zone</code>：时区，默认为当前时区，一般没有用到。</li></ol><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p><p><strong>它的特点如下</strong></p><ul><li>纯java实现，可以作为独立的应用程序，也可以嵌入在另一个独立式应用程序运行</li><li>强大的调度功能，Spring默认的调度框架，灵活可配置；</li><li>作业持久化，调度环境持久化机制，可以保存并恢复调度现场。系统关闭数据不会丢失；灵活的应用方式，可以任意定义触发器的调度时间表，支持任务和调度各种组合，组件式监听器、各种插件、线程池等功能，多种存储方式等；</li><li>分布式和集群能力，可以被实例化，一个Quartz集群中的每个节点作为一个独立的Quartz使用，通过相同的数据库表来感知到另一个Quartz应用</li></ul><p><strong>Quartz的体系结构</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/springboot-job-quartz-1.png" alt="img"></p><p> 上图来源于<a href="https://www.cnblogs.com/jijm123/p/14240320.html">https://www.cnblogs.com/jijm123/p/14240320.html</a></p><ul><li><strong>Job</strong> 表示一个工作，要执行的具体内容。</li><li><strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。</li><li><strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</li><li><strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</li></ul><h3 id="分布式任务的方案"><a href="#分布式任务的方案" class="headerlink" title="分布式任务的方案"></a>分布式任务的方案</h3><blockquote><p>常见的分布式任务的方案有：Quartz Cluster，XXL-Job，Elastic-Job等。</p><ol><li>如果仅是小团队内部自用，可以采用XXL-Job</li><li>如果是稍大一点的团队，建议使用ElasticJob或者基于ElasticJob进行二次开发</li></ol></blockquote><h4 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h4><blockquote><p>XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。<a href="https://www.xuxueli.com/xxl-job/">xxl-job官网</a></p></blockquote><h5 id="xxl-job的架构设计"><a href="#xxl-job的架构设计" class="headerlink" title="xxl-job的架构设计"></a>xxl-job的架构设计</h5><h6 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h6><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p><h6 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h6><ol><li>调度模块（调度中心）： <ol><li>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；</li><li>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li></ol></li><li>执行模块（执行器）： <ol><li>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；</li><li>接收“调度中心”的执行请求、终止请求和日志请求等。</li></ol></li></ol><h6 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h6><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/springboot-xxl-job-8.png" alt="img"></p><h4 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic-Job"></a>Elastic-Job</h4><blockquote><p>ElasticJob 是面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。 它通过弹性调度、资源管控、以及作业治理的功能，打造一个适用于互联网场景的分布式调度解决方案，并通过开放的架构设计，提供多元化的作业生态。 它的各个产品使用统一的作业 API，开发者仅需一次开发，即可随意部署。ElasticJob 已于 2020 年 5 月 28 日成为 Apache ShardingSphere 的子项目。</p></blockquote><p>使用 ElasticJob 能够让开发工程师不再担心任务的线性吞吐量提升等非功能需求，使他们能够更加专注于面向业务编码设计； 同时，它也能够解放运维工程师，使他们不必再担心任务的可用性和相关管理需求，只通过轻松的增加服务节点即可达到自动化运维的目的。</p><p><strong>ElasticJob-Lite</strong>: 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。</p><p><strong>ElasticJob-Cloud</strong>： 采用自研 Mesos Framework 的解决方案，额外提供资源治理、应用分发以及进程隔离等功能。</p><p><strong>ElasticJob-Lite和ElasticJob-Cloud的区别</strong></p><div class="table-container"><table><thead><tr><th></th><th>ElasticJob-Lite</th><th>ElasticJob-Cloud</th></tr></thead><tbody><tr><td>无中心化</td><td>是</td><td>否</td></tr><tr><td>资源分配</td><td>不支持</td><td>支持</td></tr><tr><td>作业模式</td><td>常驻</td><td>常驻 + 瞬时</td></tr><tr><td>部署依赖</td><td>ZooKeeper</td><td>ZooKeeper + Mesos</td></tr></tbody></table></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.nenggz.com/md/arch/arch-z-id.html">https://www.nenggz.com/md/arch/arch-z-id.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式注册中心</title>
      <link href="/mingyry/b0849f5d.html"/>
      <url>/mingyry/b0849f5d.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式注册中心"><a href="#分布式注册中心" class="headerlink" title="分布式注册中心"></a>分布式注册中心</h1><p>注册中心需要实现的功能</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814150339248.png" alt="image-20230814150339248"></p><p>注册中心选型</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814150135832.png" alt="image-20230814150135832"></p><ul><li><p><strong>服务健康检查</strong>：Euraka 使用时需要显式配置健康检查支持；Zookeeper、Etcd 则在失去了和服务进程的连接情况下任务不健康，而 Consul 相对更为详细点，比如内存是否已使用了90%，文件系统的空间是不是快不足了。</p></li><li><p><strong>多数据中心</strong>：Consul 和 Nacos 都支持，其他的产品则需要额外的开发工作来实现。</p></li><li><p><strong>KV 存储服务</strong>：除了 Eureka，其他几款都能够对外支持 k-v 的存储服务，所以后面会讲到这几款产品追求高一致性的重要原因。而提供存储服务，也能够较好的转化为动态配置服务哦。</p></li><li><p><strong>CAP 理论的取舍</strong>：</p></li><li><ul><li>Eureka 是典型的 AP，Nacos可以配置为 AP，作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。</li><li>而Zookeeper、Etcd、Consul则是 CP 类型牺牲可用性，在服务发现场景并没太大优势；</li></ul></li><li><p><strong>Watch的支持</strong>：Zookeeper 支持服务器端推送变化，其它都通过长轮询的方式来实现变化的感知。</p></li><li><p><strong>自身集群的监控</strong>：除了Zookeeper和Nacos，其它几款都默认支持 metrics，运维者可以搜集并报警这些度量信息达到监控目的。</p></li><li><p><strong>Spring Cloud的集成</strong>：目前都有相对应的 boot starter，提供了集成能力。</p></li></ul><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="Zookeeper概念"><a href="#Zookeeper概念" class="headerlink" title="Zookeeper概念"></a>Zookeeper概念</h3><p>是一个分布式的、开源的分布式应用程序的协调服务</p><p>用来管理分布式程序</p><p>主要功能：</p><ul><li>配置管理</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230520104150318.png" alt="image-20230520104150318"></p><ul><li><p>分布式锁</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230520104451402.png" alt="image-20230520104451402"></p></li><li><p>集群管理</p></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230520104456857.png" alt="image-20230520104456857"></p><h3 id="Zookeeper命令操作"><a href="#Zookeeper命令操作" class="headerlink" title="Zookeeper命令操作"></a>Zookeeper命令操作</h3><ul><li><p>是一个树形目录服务，拥有一个层次化结构</p></li><li><p>每个节点都是ZNode，每个节点都会保存自己的<strong>数据</strong>和<strong>节点信息</strong></p></li><li>节点拥有子节点，允许少量数据存储（1MB）在节点下</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230520153253787.png" alt="image-20230520153253787"></p><p>客户端命令：</p><ul><li>ls /  查看根节点， ls -s 查看节点详细信息</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230521083041014.png" alt="image-20230521083041014"></p><ul><li>增删改查：create，get，set，delete</li><li>默认创建持久化节点</li><li>-e  临时节点， -s  顺序节点  -es  创建临时顺序节点</li></ul><h3 id="Zookeeper-JavaAPI操作"><a href="#Zookeeper-JavaAPI操作" class="headerlink" title="Zookeeper JavaAPI操作"></a>Zookeeper JavaAPI操作</h3><p>Curator 是 Apache ZooKeeper 的Java客户端库，目的就是简化ZooKeeper客户端的使用  </p><h4 id="Curator-API常用操作"><a href="#Curator-API常用操作" class="headerlink" title="Curator API常用操作"></a>Curator API常用操作</h4><h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create a new client</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> connectString       list of servers to connect to</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> sessionTimeoutMs    session timeout</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> connectionTimeoutMs connection timeout</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> retryPolicy         retry policy to use</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> client</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 1. 创建客户端</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder().connectString(<span class="string">&quot;192.168.208.100:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">&quot;itheima&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/app1&quot;</span>, <span class="string">&quot;xiaoli&quot;</span>.getBytes());</span><br><span class="line">        client.create().creatingParentsIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line">        client.getData().storingStatIn(stat).forPath(<span class="string">&quot;/app1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="literal">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="Watch事件监听"><a href="#Watch事件监听" class="headerlink" title="Watch事件监听"></a>Watch事件监听</h4><ul><li>ZooKeeper允许用户在执行节点上注册一些Watcher，并且在一些特定的事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上。</li><li>Watcher机制来实现发布/订阅功能</li><li>Curator引入Cathe来实现对ZooKeeper服务端事件的监听</li><li>ZooKeeper提供了三种Watcher：<ul><li>NodeCache：只监听某一个特定的节点</li><li>PathChildrenCache：监控一个Znode的子节点</li><li>TreeCache：可以监控整个树上的所有节点，类似于P和N的组合</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 创建Node watcher</span></span><br><span class="line">    <span class="type">NodeCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, <span class="string">&quot;/app1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注册监听器</span></span><br><span class="line">    cache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">NodeCacheListener</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 监听器启动</span></span><br><span class="line">    cache.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 创建PathChildrenCache watcher只监听当前节点的子节点</span></span><br><span class="line">    <span class="type">PathChildrenCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, <span class="string">&quot;/app1&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注册监听器</span></span><br><span class="line">    cache.getListenable().addListener(<span class="keyword">new</span> <span class="title class_">PathChildrenCacheListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 得到当前节点的状态</span></span><br><span class="line">            System.out.println(client.getState());</span><br><span class="line">            <span class="comment">// 得到修改的数据</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 监听器启动</span></span><br><span class="line">    cache.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>跨机器的进程之间的数据同步问题</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</li></ul><ol><li>客户端获取锁，在lock节点下创建<font color='red'>临时顺序</font>节点<ul><li>临时：为了在客户端宕机的情况下，锁也可以被释放</li><li>顺序：保证最小节点的客户端优先获取锁</li></ul></li><li>然后获取lock下面的所有子节点，客户端比较自己创建的节点是否是序号最小的，如果是，则代表该客户端或读到了锁。当使用完锁后，将该节点删除</li><li>如果自己创建的节点并非lock所有子节点中最小的，说明没有获取到锁，此时客户端要找到比自己节点小的前一个节点，利用事件监听器Watcher来监听删除事件</li><li>如果发现比自己小的那个节点被删除，则客户端的事件监听器会收到通知，客户端再次判断，如果自己创建的节点最小，则获取到锁。否则，再次监听比自己小的前一个节点</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230521132829448.png" alt="image-20230521132829448"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li>Curator实现分布式锁的五种方案：<ul><li>InterProcessSemaphoreMutex：分布式排他锁（非可重入锁）</li><li>InterProcessMutex：分布式可重入排它锁</li><li>InterProcessReadWriteLock：分布式读写锁</li><li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li><li>InterProcessSemaphoreV2：共享信号量</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket12306</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 10 tickets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket12306</span><span class="params">(InterProcessMutex lock)</span> &#123;</span><br><span class="line">        <span class="type">RetryPolicy</span> <span class="variable">retryPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 1. 创建客户端</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder().connectString(<span class="string">&quot;192.168.208.100:2181&quot;</span>)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">15</span> * <span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.acquire(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+ tickets);</span><br><span class="line"></span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230521145343529.png" alt="image-20230521145343529"></p><p>在ZooKeeper集群服务中有三个角色：</p><ul><li><p>Leader 领导者：</p><ol><li>处理事务请求</li><li>集群内部各服务器的调度者</li></ol></li><li><p>Follower 跟随者：</p><ol><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>参与Leader的选举投票</li></ol></li><li><p>Observer 观察者：</p><ol><li>处理客户端非事务请求，转发事务请求给Leader服务器</li></ol></li></ul><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><blockquote><p>以下内容摘抄自Nacos官网：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814145948546.png" alt="image-20230814145948546"></p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><h3 id="Nacos-主要特点"><a href="#Nacos-主要特点" class="headerlink" title="Nacos 主要特点"></a>Nacos 主要特点</h3><p><strong>服务发现和服务健康监测</strong>：</p><ul><li>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用原生SDK、OpenAPI、或一个独立的Agent TODO注册 Service 后，服务消费者可以使用DNS TODO 或HTTP&amp;API查找和发现服务。</li><li>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</li></ul><p><strong>动态配置服务</strong>：</p><ul><li>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</li><li>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</li><li>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</li><li>Nacos 提供了一个简洁易用的UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</li></ul><p><strong>动态 DNS 服务</strong>：</p><ul><li>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</li><li>Nacos 提供了一些简单的 DNS APIs TODO 帮助您管理服务的关联域名和可用的 IP:PORT 列表。</li></ul><blockquote><p>小节一下：</p><ul><li>Nacos是阿里开源的，支持基于 DNS 和基于 RPC 的服务发现。</li><li><strong>Nacos的注册中心支持CP也支持AP</strong>，对他来说只是一个命令的切换，随你玩，还支持各种注册中心迁移到Nacos，反正一句话，只要你想要的他就有。</li><li><strong>Nacos除了服务的注册发现之外，还支持动态配置服务</strong>，一句话概括就是<strong>Nacos = Spring Cloud注册中心 + Spring Cloud配置中心</strong></li></ul></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;mid=2247486918&amp;idx=1&amp;sn=5651cd0b4b9c8e68bcfa55c00c0950d6&amp;chksm=cf034f24f874c632511684057337a744c54702543ec3690aa06dbf4bbaf980b2828f52276c9b&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;mid=2247486918&amp;idx=1&amp;sn=5651cd0b4b9c8e68bcfa55c00c0950d6&amp;chksm=cf034f24f874c632511684057337a744c54702543ec3690aa06dbf4bbaf980b2828f52276c9b&amp;scene=21#wechat_redirect</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/mingyry/f6253398.html"/>
      <url>/mingyry/f6253398.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>新版本dubbo3定义了全新的RPC通信协议-Triple，一款基于HTTP/2上构建的RPC协议，并且完全兼容gRPC</p><h2 id="Dubbo-与-gRPC"><a href="#Dubbo-与-gRPC" class="headerlink" title="Dubbo 与 gRPC"></a>Dubbo 与 gRPC</h2><p>Dubbo 与 gRPC 最大的差异在于两者的定位上：</p><ul><li><strong>gRPC 定位为一款 RPC 框架</strong>，Google 推出它的核心目标是定义云原生时代的 rpc 通信规范与标准实现；</li><li><strong>Dubbo 定位是一款微服务开发框架</strong>，它侧重解决微服务实践从服务定义、开发、通信到治理的问题，因此 Dubbo 同时提供了 RPC 通信、与应用开发框架的适配、服务治理等能力。</li></ul><p>Dubbo 不绑定特定的通信协议，即 Dubbo 服务间可通过多种 RPC 协议通信并支持灵活切换。因此，你可以在 Dubbo 开发的微服务中选用 gRPC 通信，<strong>Dubbo 完全兼容 gRPC，并将 gRPC 设计为内置原生支持的协议之一</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/dubbo-grpc.png" alt="dubbo-grpc"></p><p>如果您看中基于 HTTP/2 的通信协议、基于 Protobuf 的服务定义，并基于此决定选型 gRPC 作为微服务开发框架，那很有可能您会在未来的微服务业务开发中遇到障碍，这主要源于 gRPC 没有为开发者提供以下能力：</p><ul><li>缺乏与业务应用框架集成的开发模式，用户需要基于 gRPC 底层的 RPC API 定义、发布或调用微服务，中间可能还有与业务应用开发框架整合的问题</li><li>缺乏微服务周边生态扩展与适配，如服务发现、限流降级、链路追踪等没有多少可供选择的官方实现，且扩展起来非常困难</li><li>缺乏服务治理能力，作为一款 rpc 框架，缺乏对服务治理能力的抽象</li></ul><p>因此，gRPC 更适合作为底层的通信协议规范或编解码包，而 Dubbo 则可用作微服务整体解决方案。<strong>对于 gRPC 协议，我们推荐的使用模式 Dubbo + gRPC 的组合</strong>，这个时候，gRPC 只是隐藏在底层的一个通信协议，不被微服务开发者感知，开发者基于 Dubbo 提供的 API 和配置开发服务，并基于 dubbo 的服务治理能力治理服务，在未来，开发者还能使用 Dubbo 生态和开源的 IDL 配套工具管理服务定义与发布。</p><h2 id="Dubbo的特点"><a href="#Dubbo的特点" class="headerlink" title="Dubbo的特点"></a>Dubbo的特点</h2><ul><li><p>可以使用任意的通信协议</p></li><li><p>内置支持 Dubbo2、Triple 两款高性能通信协议，能够进行更高性能的数据传输4</p></li><li><p>构建可伸缩的微服务集群，可以扩展很多性能</p><ul><li>Dubbo3 服务发现：实现了应用粒度的服务发现机制</li><li>流量管控机制：就是利用各种路由策略，将消费者或者提供者按照一定的规则来匹配</li></ul></li><li><p>服务治理能力：</p><ul><li><p>流量管控：</p><ul><li><strong>地址发现与负载均衡</strong>，地址发现支持服务实例动态上下线，负载均衡确保流量均匀的分布到每个实例上。</li><li><strong>基于路由规则的流量管控</strong>，路由规则对每次请求进行条件匹配，并将符合条件的请求路由到特定的地址子集。</li></ul></li><li><p>构建了完善的微服务治理生态，满足大多数服务治理的需求</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/governance.png" alt="governance"></p></li><li><p>可视化控制台：利用Dubbo Admin来实现可视化的控制台，监测Dubbo 的各种服务情况</p></li><li><p>安全体系：支持TLS安全验证，还支持认证、鉴权策略</p></li><li><p>服务网格：可以透明的介入Istio等服务网格体系，也支持基于Envoy的流量拦截方式，也支持更加轻量的 Proxyless Mesh 部署模式</p></li></ul></li></ul><h2 id="开发服务"><a href="#开发服务" class="headerlink" title="开发服务"></a>开发服务</h2><p><strong>1. 定义服务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    String <span class="title function_">hello</span><span class="params">(String arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 提供业务逻辑实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="comment">// put your microservice logic here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布服务"><a href="#发布服务" class="headerlink" title="发布服务"></a>发布服务</h3><p><strong>1. 发布服务定义</strong></p><p>为使消费方顺利调用服务，服务提供者首先要将服务定义以 Jar 包形式发布到 Maven 中央仓库。</p><p><strong>2. 对外暴露服务</strong></p><p>补充 Dubbo 配置并启动 Dubbo Server</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-demo</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3><p>首先，消费方通过 Maven/Gradle 引入 <code>DemoService</code> 服务定义依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-demo-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编程注入远程 Dubbo 服务实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Dubbo依赖第三方注册中心组件来协调服务发现过程，支持常用的注册中心，如Nacos、Consul、Zookeeper等</p><p>Dubbo 服务发现机制的基本工作原理图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arc.png" alt="service-discovery"></p><ul><li>Dubbo提供者实例注册URL地址到注册中心</li><li>注册中心负责对数据进行聚合</li><li>Dubbo消费者从注册中心读取地址列表并订阅变更。</li><li>当地址列表发生变更时，注册中心将最新的列表通知到所有订阅的消费者实例</li></ul><h3 id="服务发现机制"><a href="#服务发现机制" class="headerlink" title="服务发现机制"></a>服务发现机制</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arc2.png" alt="service-discovery"></p><ul><li>Dubbo注册中心，以<strong>应用粒度</strong>聚合实例数据（2.0以前是根据接口粒度来聚合实例数据），消费者按照消费需求精准订阅</li><li>Dubbo SDK在实现上对消费端地址列表处理过程做了大量优化，地址通知增加了异步、缓存、bitmap等多种解析优化，避免了地址更新常出现的消费端进程资源波动。</li><li>提高了功能丰富度和易用性。服务发现除了同步ip、port等端点基本信息到消费者外，Dubbo还将服务端的RPC/HTTP服务及其配置的元数据信息同步到消费端，让消费者、提供者两端的更细粒度的协助成为可能。</li></ul><h3 id="高效地址推送实现"><a href="#高效地址推送实现" class="headerlink" title="高效地址推送实现"></a>高效地址推送实现</h3><p>从注册中心视角来看，它负责以应用名 (dubbo.application.name) 对整个集群的实例地址进行聚合，每个对外提供服务的实例将自身的应用名、实例ip: port 地址信息 (通常还包含少量的实例元数据，如机器所在区域、环境等) 注册到注册中心。</p><blockquote><p>Dubbo2 版本注册中心以服务粒度聚合实例地址，比应用粒度更细，也就意味着传输的数据量更大，因此在大规模集群下也遇到一些性能问题。 针对 Dubbo2 与 Dubbo3 跨版本数据模型不统一的问题，Dubbo3 给出了<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/upgrades-and-compatibility/service-discovery/migration-service-discovery/">平滑迁移方案</a>，可做到模型变更对用户无感。</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/registry-data.png" alt="service-discovery"></p><p>每个消费服务的实例从注册中心订阅实例地址列表，相比于一些产品直接将注册中心的全量数据 (应用 + 实例地址) 加载到本地进程，Dubbo 实现了按需精准订阅地址信息。比如一个消费者应用依赖 app1、app2，则只会订阅 app1、app2 的地址列表更新，大幅减轻了冗余数据推送和解析的负担。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/subscription2.png" alt="service-discovery"></p><h3 id="丰富元数据配置"><a href="#丰富元数据配置" class="headerlink" title="丰富元数据配置"></a>丰富元数据配置</h3><p>除了与注册中心的交互，Dubbo3 的完整地址发现过程还有一条额外的元数据通路，我们称之为元数据服务 (MetadataService)，实例地址与元数据共同组成了消费者端有效的地址列表。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/metadata.png" alt="service-discovery"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式相关理论</title>
      <link href="/mingyry/e466e80f.html"/>
      <url>/mingyry/e466e80f.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式相关理论"><a href="#分布式相关理论" class="headerlink" title="分布式相关理论"></a>分布式相关理论</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP定理：对于一个分布式系统来说，当设计读写操作时，只能同时满足一下三点中的两个：</p><ul><li><strong>一致性（Consistency）</strong>：所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。系统在任何时刻都能够处理客户端的请求并返回合理的响应</li><li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p><strong>网络分区</strong>就是连通的网络不连通了，分为几个区</p><h3 id="不是所谓的“3-选-2”"><a href="#不是所谓的“3-选-2”" class="headerlink" title="不是所谓的“3 选 2”"></a>不是所谓的“3 选 2”</h3><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p><blockquote><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p></blockquote><p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p><p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p><p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p><p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong>三个短语的缩写。</p><h3 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h3><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><p><strong>什么叫允许损失部分可用性呢？</strong></p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><blockquote><p>分布式一致性的 3 种级别：</p><ol><li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol><p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p></blockquote><p><strong>实现最终一致性的具体方式</strong>：</p><blockquote><p><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</p><p><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</p><p><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</p></blockquote><p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p><h2 id="CAP在服务中实际的应用例子"><a href="#CAP在服务中实际的应用例子" class="headerlink" title="CAP在服务中实际的应用例子"></a>CAP在服务中实际的应用例子</h2><p><a href="https://juejin.cn/post/6844903936718012430">https://juejin.cn/post/6844903936718012430</a></p><h2 id="Raft-算法"><a href="#Raft-算法" class="headerlink" title="Raft 算法"></a>Raft 算法</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><h4 id="1-1-拜占庭将军"><a href="#1-1-拜占庭将军" class="headerlink" title="1.1 拜占庭将军"></a>1.1 拜占庭将军</h4><blockquote><p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p></blockquote><p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p><p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p><h4 id="1-2-共识算法"><a href="#1-2-共识算法" class="headerlink" title="1.2 共识算法"></a>1.2 共识算法</h4><p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p><p>适用于实际系统的共识算法通常具有以下特性：</p><ul><li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li><li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li><li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li><li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li></ul><h3 id="2-基础"><a href="#2-基础" class="headerlink" title="2 基础"></a>2 基础</h3><h4 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a>2.1 节点类型</h4><p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p><ul><li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li><li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li><li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li></ul><p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/paxos-server-state.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图-2：服务器的状态</span><br></pre></td></tr></table></figure><h4 id="2-2-任期"><a href="#2-2-任期" class="headerlink" title="2.2 任期"></a>2.2 任期</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/paxos-term.png" alt="img"></p><p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p><p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p><h4 id="2-3-日志"><a href="#2-3-日志" class="headerlink" title="2.3 日志"></a>2.3 日志</h4><ul><li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li><li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li></ul><h3 id="3-领导人选举"><a href="#3-领导人选举" class="headerlink" title="3 领导人选举"></a>3 领导人选举</h3><p>raft 使用心跳机制来触发 Leader 的选举。</p><p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p><p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p><p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p><ul><li>赢得选举</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p><p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p><ul><li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li><li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li></ul><p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p><p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p><h3 id="4-日志复制"><a href="#4-日志复制" class="headerlink" title="4 日志复制"></a>4 日志复制</h3><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p><p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p><p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p><p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p><p>raft 保证以下两个性质：</p><ul><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li></ul><p>通过“仅有 Leader 可以生存 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p><p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p><p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p><p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p><h3 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5 安全性"></a>5 安全性</h3><h4 id="5-1-选举限制"><a href="#5-1-选举限制" class="headerlink" title="5.1 选举限制"></a>5.1 选举限制</h4><p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p><p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p><p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p><h4 id="5-2-节点崩溃"><a href="#5-2-节点崩溃" class="headerlink" title="5.2 节点崩溃"></a>5.2 节点崩溃</h4><p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p><p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p><h4 id="5-3-时间与可用性"><a href="#5-3-时间与可用性" class="headerlink" title="5.3 时间与可用性"></a>5.3 时间与可用性</h4><p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</span><br></pre></td></tr></table></figure><ul><li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code>：选举超时时间；</li><li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li></ul><p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p><p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p><p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p><h2 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h2><h3 id="Gossip-协议介绍"><a href="#Gossip-协议介绍" class="headerlink" title="Gossip 协议介绍"></a>Gossip 协议介绍</h3><p><strong>Gossip 协议</strong> 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p><p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p><p> <strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p><h3 id="Gossip-协议应用"><a href="#Gossip-协议应用" class="headerlink" title="Gossip 协议应用"></a>Gossip 协议应用</h3><p>Redis Cluster 为例说明 Gossip 协议的实际应用。</p><p>我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/up-fcacc1eefca6e51354a5f1fc9f2919f51ec.png" alt="img"></p><p>Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，Redis Cluster 中的各个节点基于 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。</p><p>Redis Cluster 的节点之间会相互发送多种 Gossip 消息：</p><ul><li><strong>MEET</strong> ：在 Redis Cluster 中的某个 Redis 节点上执行 <code>CLUSTER MEET ip port</code> 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。</li><li><strong>PING/PONG</strong> ：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</li><li><strong>FAIL</strong> ：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。</li><li>……</li></ul><p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-cluster-gossip-acd10106.png" alt="img"></p><p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。</p><h3 id="Gossip-类型"><a href="#Gossip-类型" class="headerlink" title="Gossip 类型"></a><strong>Gossip 类型</strong></h3><p>Gossip 有两种类型：</p><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li></ul><p>Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。</p><p>Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。</p><p>其实，Anti-entropy 反熵是一个很奇怪的名词，之所以定义成这样，Jelasity 进行了解释，因为 entropy 是指混乱程度（disorder），而在这种模式下可以消除不同节点中数据的 disorder，因此 Anti-entropy 就是 anti-disorder。换句话说，它可以提高系统中节点之间的 similarity。</p><p>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p><p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p><p>但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p><p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p><h3 id="Gossip-中的通信模式"><a href="#Gossip-中的通信模式" class="headerlink" title="Gossip 中的通信模式"></a><strong>Gossip 中的通信模式</strong></h3><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p><ul><li>Push：节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li><li>Pull： A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p><h3 id="Gossip-协议优势和缺陷"><a href="#Gossip-协议优势和缺陷" class="headerlink" title="Gossip 协议优势和缺陷"></a>Gossip 协议优势和缺陷</h3><p><strong>优势：</strong></p><p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p><p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p><p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p><p><strong>缺陷</strong> :</p><p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p><p>2、由于拜占庭将军问题，不允许存在恶意节点。</p><p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/41228196">https://zhuanlan.zhihu.com/p/41228196</a></p><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><a href="https://dunwu.github.io/blog/">https://dunwu.github.io/blog/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式相关理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO</title>
      <link href="/mingyry/bcfad141.html"/>
      <url>/mingyry/bcfad141.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="IO实现的设计模式（装饰者模式）"><a href="#IO实现的设计模式（装饰者模式）" class="headerlink" title="IO实现的设计模式（装饰者模式）"></a>IO实现的设计模式（装饰者模式）</h2><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。</p><p>所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。</p><p>可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png" alt="img"></p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>类应该对扩展开放，对修改关闭: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p><p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p><h3 id="IO-装饰者模式"><a href="#IO-装饰者模式" class="headerlink" title="IO 装饰者模式"></a>IO 装饰者模式</h3><p>以 InputStream 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/DP-Decorator-java.io.png" alt="image"></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h2 id="IO常见类的使用"><a href="#IO常见类的使用" class="headerlink" title="IO常见类的使用"></a>IO常见类的使用</h2><p>Java 的 I/O 大概可以分成以下几类:</p><ul><li>磁盘操作: File</li><li>字节操作: InputStream 和 OutputStream</li><li>字符操作: Reader 和 Writer</li><li>对象操作: Serializable</li><li>网络操作: Socket</li></ul><h3 id="File相关"><a href="#File相关" class="headerlink" title="File相关"></a>File相关</h3><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地列出一个目录下所有文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listAllFiles</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节流相关"><a href="#字节流相关" class="headerlink" title="字节流相关"></a>字节流相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dist);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> (in.read(buffer, <span class="number">0</span>, buffer.length) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化-amp-Serializable-amp-transient"><a href="#序列化-amp-Serializable-amp-transient" class="headerlink" title="序列化 &amp; Serializable &amp; transient"></a>序列化 &amp; Serializable &amp; transient</h3><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化: ObjectOutputStream.writeObject()</li><li>反序列化: ObjectInputStream.readObject()</li></ul><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><p><strong>Serializable</strong></p><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">123</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">objectFile</span> <span class="operator">=</span> <span class="string">&quot;file/a1&quot;</span>;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(objectFile));</span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="type">int</span> x, String y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;y = &quot;</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transient</strong></p><p>transient 关键字可以使一些属性不会被序列化。</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h3 id="Java-中的网络支持"><a href="#Java-中的网络支持" class="headerlink" title="Java 中的网络支持:"></a>Java 中的网络支持:</h3><ul><li>InetAddress: 用于表示网络上的硬件资源，即 IP 地址；</li><li>URL: 统一资源定位符；</li><li>Sockets: 使用 TCP 协议实现网络通信；</li><li>Datagram: 使用 UDP 协议实现网络通信。</li></ul><h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="type">byte</span>[] address);</span><br></pre></td></tr></table></figure><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>可以直接从 URL 中读取字节流数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h4><ul><li>ServerSocket: 服务器端类</li><li>Socket: 客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/ClienteServidorSockets1521731145260.jpg" alt="image"></p><h4 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h4><ul><li>DatagramSocket: 通信类</li><li>DatagramPacket: 数据包类</li></ul><h2 id="IO-模型-Unix-IO-模型"><a href="#IO-模型-Unix-IO-模型" class="headerlink" title="IO 模型 - Unix IO 模型"></a>IO 模型 - Unix IO 模型</h2><h3 id="Unix-IO-模型简介"><a href="#Unix-IO-模型简介" class="headerlink" title="Unix IO 模型简介"></a>Unix IO 模型简介</h3><p>一个输入操作通常包括两个阶段:</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 下有五种 I/O 模型:</p><ul><li>阻塞式 I/O (BIO)</li><li>非阻塞式 I/O (NIO)</li><li>I/O 复用(select 和 poll)</li><li>信号驱动式 I/O (SIGIO)</li><li>异步 I/O (AIO)</li></ul><h3 id="I-O-模型比较"><a href="#I-O-模型比较" class="headerlink" title="I/O 模型比较"></a>I/O 模型比较</h3><h4 id="同步-I-O-与异步-I-O"><a href="#同步-I-O-与异步-I-O" class="headerlink" title="同步 I/O 与异步 I/O"></a>同步 I/O 与异步 I/O</h4><ul><li>同步 I/O: 应用进程在调用 recvfrom 操作时会阻塞。</li><li>异步 I/O: 不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h4 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h4><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/1492928105791_3.png" alt="img"></p><h2 id="BIO-详解"><a href="#BIO-详解" class="headerlink" title="BIO 详解"></a>BIO 详解</h2><blockquote><p>BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。</p></blockquote><h3 id="传统的BIO通信方式简介"><a href="#传统的BIO通信方式简介" class="headerlink" title="传统的BIO通信方式简介"></a>传统的BIO通信方式简介</h3><p>以前大多数网络通信方式都是阻塞模式的，即:</p><ul><li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li><li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-bio-1.png" alt="img"></p><h4 id="传统的BIO的问题"><a href="#传统的BIO的问题" class="headerlink" title="传统的BIO的问题"></a>传统的BIO的问题</h4><ul><li>同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。</li><li>由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。</li></ul><h3 id="多线程方式-伪异步方式"><a href="#多线程方式-伪异步方式" class="headerlink" title="多线程方式 - 伪异步方式"></a>多线程方式 - 伪异步方式</h3><ul><li><p>当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</p></li><li><p>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程</p></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-bio-2.png" alt="img"></p><p><strong>局限性：</strong></p><ul><li><p>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()、read()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来。</p></li><li><p>在linux系统中，可以创建的线程是有限的。我们可以通过cat /proc/sys/kernel/threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</p></li><li><p>创建一个线程是有较大的资源消耗的。JVM创建一个线程的时候，即使这个线程不做任何的工作，JVM都会分配一个堆栈空间。这个空间的大小默认为128K，您可以通过-Xss参数进行调整。当然您还可以使用ThreadPoolExecutor线程池来缓解线程的创建问题，但是又会造成BlockingQueue积压任务的持续增加，同样消耗了大量资源。</p></li><li><p>另外，如果应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。 那么，如果你真想单纯使用线程解决阻塞的问题，那么您自己都可以算出来您一个服务器节点可以一次接受多大的并发了。看来，单纯使用线程解决这个问题不是最好的办法。</p></li></ul><h2 id="NIO-详解"><a href="#NIO-详解" class="headerlink" title="NIO 详解"></a>NIO 详解</h2><p>NIO（非阻塞式同步IO）把IO抽象成块，类似磁盘的读写，每次IO操作的单位都是一个块，块被读入内存之后就是一个byte[]，NIO一次可以读或写多个字节。</p><h3 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h3><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.<em> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.</em> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h3 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h3><h4 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h4><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型:</p><ul><li>FileChannel: 从文件中读写数据；</li><li>DatagramChannel: 通过 UDP 读写网络中数据；</li><li>SocketChannel: 通过 TCP 读写网络中数据；</li><li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h4 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h4><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型:</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffe</li></ul><h4 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h4><ul><li>capacity: 最大容量；</li><li>position: 当前已经读写的字节数；</li><li>limit: 还可以读写的字节数。</li></ul><p>初始状态：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230509192024905.png" alt="image-20230509192024905"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0018.png" alt=""></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0019.png" alt=""></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="image"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>NIO 与普通 I/O 的区别主要有以下两点:</p><ul><li>NIO 是非阻塞的</li><li>NIO 面向块，I/O 面向流</li></ul><h2 id="IO多路复用详解"><a href="#IO多路复用详解" class="headerlink" title="IO多路复用详解"></a>IO多路复用详解</h2><h3 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h3><p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p><p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p><p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p><p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230509203206396.png" alt="image-20230509203206396"></p><p>当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p><p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <strong>多线程模型</strong>。</p><p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p><p>如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。使用<strong>线程池</strong>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230509203403943.png" alt="image-20230509203403943"></p><p>需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。</p><p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。</p><h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><p><strong>I/O 多路复用</strong>技术只使用一个进程来维护多个 Socket </p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230509203543149.png" alt="image-20230509203543149" style="zoom: 80%;" /></p><p>一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。</p><p>我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p><h3 id="典型的多路复用IO实现"><a href="#典型的多路复用IO实现" class="headerlink" title="典型的多路复用IO实现"></a>典型的多路复用IO实现</h3><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p><div class="table-container"><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows/Linux</td><td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor/Proactor</td><td>Linux</td><td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前JAVA的版本不支持</td></tr></tbody></table></div><p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><h4 id="传统IO模型"><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h4><p>对于传统IO模型，其主要是一个Server对接N个客户端，在客户端连接之后，为每个客户端都分配一个执行线程。如下图是该模型的一个演示：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-reactor-1.png" alt="img"></p><p>从图中可以看出，传统IO的特点在于：</p><ul><li>每个客户端连接到达之后，服务端会分配一个线程给该客户端，该线程会处理包括读取数据，解码，业务计算，编码，以及发送数据整个过程；</li><li>同一时刻，服务端的吞吐量与服务器所提供的线程数量是呈线性关系的。</li></ul><p>这种设计模式在客户端连接不多，并发量不大的情况下是可以运行得很好的，但是在海量并发的情况下，这种模式就显得力不从心了。这种模式主要存在的问题有如下几点：</p><ul><li><strong>服务器的并发量对服务端能够创建的线程数有很大的依赖关系</strong>，但是服务器线程却是不能无限增长的；</li><li>服务端每个线程不仅要进行IO读写操作，而且<strong>还需要进行业务计算</strong>；</li><li>服务端在<strong>获取客户端连接</strong>，<strong>读取数据</strong>，<strong>以及写入数据的过程都是阻塞类型的</strong>，在网络状况不好的情况下，这将极大的降低服务器每个线程的利用率，从而降低服务器吞吐量。</li></ul><h4 id="Reactor事件驱动模型"><a href="#Reactor事件驱动模型" class="headerlink" title="Reactor事件驱动模型"></a>Reactor事件驱动模型</h4><p>该API本质上是以事件驱动来处理网络事件的，而Reactor是基于该API提出的一套IO模型。如下是Reactor事件驱动模型的示意图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-reactor-2.png" alt="img"></p><p>从图中可以看出，在Reactor模型中，主要有四个角色：客户端连接，Reactor，Acceptor和Handler。这里Acceptor会不断地接收客户端的连接，然后将接收到的连接交由Reactor进行分发，最后有具体的Handler进行处理。改进后的Reactor模型相对于传统的IO模型主要有如下优点：</p><ul><li>从模型上来讲，如果仅仅还是只使用一个线程池来处理客户端连接的网络读写，以及业务计算，那么Reactor模型与传统IO模型在效率上并没有什么提升。但是Reactor模型是以事件进行驱动的，其能够将接收客户端连接 + 网络读和网络写，以及业务计算进行拆分，从而极大的提升处理效率；</li><li>Reactor模型是异步非阻塞模型，工作线程在没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待。</li></ul><h4 id="Reactor模型——业务处理与IO分离"><a href="#Reactor模型——业务处理与IO分离" class="headerlink" title="Reactor模型——业务处理与IO分离"></a>Reactor模型——业务处理与IO分离</h4><p>在上面的Reactor模型中，由于网络读写和业务操作都在同一个线程中，在高并发情况下，这里的系统瓶颈主要在两方面：</p><ul><li>高频率的网络读写事件处理；</li><li>大量的业务操作处理；</li></ul><p>基于上述两个问题，这里在单线程Reactor模型的基础上提出了使用线程池的方式处理业务操作的模型。如下是该模型的示意图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-reactor-3.png" alt="img"></p><p>从图中可以看出，在多线程进行业务操作的模型下，该模式主要具有如下特点：</p><ul><li>使用一个线程进行客户端连接的接收以及网络读写事件的处理；</li><li>在接收到客户端连接之后，将该连接交由线程池进行数据的编解码以及业务计算。</li></ul><p>这种模式相较于前面的模式性能有了很大的提升，主要在于在进行网络读写的同时，也进行了业务计算，从而大大提升了系统的吞吐量。但是这种模式也有其不足，主要在于：</p><ul><li>网络读写是一个比较消耗CPU的操作，在高并发的情况下，将会有大量的客户端数据需要进行网络读写，此时一个线程将不足以处理这么多请求。</li></ul><h4 id="Reactor模型——并发读写"><a href="#Reactor模型——并发读写" class="headerlink" title="Reactor模型——并发读写"></a>Reactor模型——并发读写</h4><p>对于使用线程池处理业务操作的模型，由于网络读写在高并发情况下会成为系统的一个瓶颈，因而针对该模型这里提出了一种改进后的模型，即使用线程池进行网络读写，而仅仅只使用一个线程专门接收客户端连接。如下是该模型的示意图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-reactor-4.png" alt="img"></p><p>可以看到，改进后的Reactor模型将Reactor拆分为了mainReactor和subReactor。这里mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。这里的subReactor则是使用一个线程池来支撑的，其读写能力将会随着线程数的增多而大大增加。对于业务操作，这里也是使用一个线程池，而每个业务请求都只需要进行编解码和业务计算。通过这种方式，服务器的性能将会大大提升，在可见情况下，其基本上可以支持百万连接。</p><h3 id="JAVA-NIO-框架简要设计分析"><a href="#JAVA-NIO-框架简要设计分析" class="headerlink" title="JAVA NIO 框架简要设计分析"></a>JAVA NIO 框架简要设计分析</h3><p>通过上文的描述，我们知道了多路复用IO技术是操作系统的内核实现。在不同的操作系统，甚至同一系列操作系统的版本中所实现的多路复用IO技术都是不一样的。那么作为跨平台的JAVA JVM来说如何适应多种多样的多路复用IO技术实现呢? 面向对象的威力就显现出来了: 无论使用哪种实现方式，他们都会有“选择器”、“通道”、“缓存”这几个操作要素，那么可以为不同的多路复用IO技术创建一个统一的抽象组，并且为不同的操作系统进行具体的实现。JAVA NIO中对各种多路复用IO的支持，主要的基础是java.nio.channels.spi.SelectorProvider抽象类，其中的几个主要抽象方法包括:</p><ul><li>public abstract DatagramChannel openDatagramChannel(): 创建和这个操作系统匹配的UDP 通道实现。</li><li>public abstract AbstractSelector openSelector(): 创建和这个操作系统匹配的NIO选择器，就像上文所述，不同的操作系统，不同的版本所默认支持的NIO模型是不一样的。</li><li>public abstract ServerSocketChannel openServerSocketChannel(): 创建和这个NIO模型匹配的服务器端通道。</li><li>public abstract SocketChannel openSocketChannel(): 创建和这个NIO模型匹配的TCP Socket套接字通道(用来反映客户端的TCP连接)</li></ul><p>由于JAVA NIO框架的整个设计是很大的，所以我们只能还原一部分我们关心的问题。这里我们以JAVA NIO框架中对于不同多路复用IO技术的选择器 进行实例化创建的方式作为例子，以点窥豹观全局:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-nio-5.png" alt="img"></p><p>很明显，不同的SelectorProvider实现对应了不同的 选择器。由具体的SelectorProvider实现进行创建。另外说明一下，实际上netty底层也是通过这个设计获得具体使用的NIO模型，我们后文讲解Netty时，会讲到这个问题。以下代码是Netty 4.0中NioServerSocketChannel进行实例化时的核心代码片段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            *  Use the &#123;<span class="doctag">@link</span> SelectorProvider&#125; to open &#123;<span class="doctag">@link</span> SocketChannel&#125; and so remove condition in</span></span><br><span class="line"><span class="comment">            *  &#123;<span class="doctag">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            *  See &lt;a href=&quot;See https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(</span><br><span class="line">                <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AIO详解"><a href="#AIO详解" class="headerlink" title="AIO详解"></a>AIO详解</h2><p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，在主动通知应用程序，触发相应的函数:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-io-aio-1.png" alt="img"></p><p><strong>异步 I/O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这<strong>两个过程都不用等待</strong>。</p><p>当我们发起 <code>aio_read</code> （异步 I/O） 之后，就立即返回，内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，<strong>应用程序并不需要主动发起拷贝动作</strong>。</p><h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</p><p><strong>Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件</strong>。</p><p>Proactor 模式的示意图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Proactor.png" alt="img"></p><p>介绍一下 Proactor 模式的工作流程：</p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li><li>Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；</li><li>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor；</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li><li>Handler 完成业务处理；</li></ul><p>可惜的是，在 Linux 下的异步 I/O 是不完善的， <code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p><p>而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code>，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="为什么要有-DMA-技术"><a href="#为什么要有-DMA-技术" class="headerlink" title="为什么要有 DMA 技术?"></a>为什么要有 DMA 技术?</h3><p>在没有 DMA 技术前，I/O 的过程是这样的：</p><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511103519461.png" alt="image-20230511103519461"></p><p>整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p><p>磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（PageCache）</strong>。</p><p>PageCache 的优点主要是两个：</p><ul><li>缓存最近被访问的数据；</li><li>预读功能；</li></ul><p>这两个做法，将大大提高读写磁盘的性能。</p><p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p><p>DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p><p>什么是 DMA 技术？简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511103643696.png" alt="image-20230511103643696"></p><p>具体过程：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><p>可以看到， <strong>CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成</strong>。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p><h3 id="传统文件传输"><a href="#传统文件传输" class="headerlink" title="传统文件传输"></a>传统文件传输</h3><p>一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="img"></p><p><strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。<strong>发生了 4 次数据拷贝</strong></p><p><strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong></p><h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>零拷贝技术实现的方式通常有 2 种：</p><ul><li>mmap + write</li><li>sendfile</li></ul><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511104134175.png" alt="image-20230511104134175" style="zoom:80%;" /></p><p>通过 DirectByteBuf，<strong>Java</strong></p><ul><li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li><li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li></ul><p>Java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li></ul><p><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据。</p><p>它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511104521736.png" alt="image-20230511104521736"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了2次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h4 id="SG-DMA（The-Scatter-Gather-Direct-Memory-Access）技术"><a href="#SG-DMA（The-Scatter-Gather-Direct-Memory-Access）技术" class="headerlink" title="SG-DMA（The Scatter-Gather Direct Memory Access）技术"></a>SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术</h4><p>从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下，可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p><code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511104846439.png" alt="image-20230511104846439"></p><p><strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。零拷贝适合小文件传输。</p><h3 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h3><p>Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p><p>曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，使用了零拷贝能够缩短 <code>65%</code> 的时间，大幅度提升了机器传输数据的吞吐量。</p><p>Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率</p><h2 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h2><p>当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511105557775.png" alt="image-20230511105557775"  /></p><p>具体过程：</p><ul><li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li><li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li><li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li></ul><p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230511105639796.png" alt="image-20230511105639796"></p><p>它把读操作分为两部分：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><p>异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p><p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p><p>直接 I/O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li></ul><p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p><h2 id="为什么还有Netty"><a href="#为什么还有Netty" class="headerlink" title="为什么还有Netty"></a>为什么还有Netty</h2><ul><li>既然JAVA NIO / JAVA AIO已经实现了各主流操作系统的底层支持，那么为什么现在主流的JAVA NIO技术会是Netty和MINA呢? </li></ul><p>答案很简单: 因为更好用，这里举几个方面的例子:</p><ul><li>虽然JAVA NIO 和 JAVA AIO框架提供了 多路复用IO/异步IO的支持，但是并没有提供上层“信息格式”的良好封装。例如前两者并没有提供针对 Protocol Buffer、JSON这些信息格式的封装，但是Netty框架提供了这些数据格式封装(基于责任链模式的编码和解码功能)</li><li>要编写一个可靠的、易维护的、高性能的(注意它们的排序)NIO/AIO 服务器应用。除了框架本身要兼容实现各类操作系统的实现外。更重要的是它应该还要处理很多上层特有服务，例如: 客户端的权限、还有上面提到的信息格式封装、简单的数据读取。这些Netty框架都提供了响应的支持。</li><li>JAVA NIO框架存在一个poll/epoll bug: Selector doesn’t block on Selector.select(timeout)，不能block意味着CPU的使用率会变成100%(这是底层JNI的问题，上层要处理这个异常实际上也好办)。当然这个bug只有在Linux内核上才能重现。</li><li>这个问题在JDK 1.7版本中还没有被完全解决: <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719。虽然Netty">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=2147719。虽然Netty</a> 4.0中也是基于JAVA NIO框架进行封装的(上文中已经给出了Netty中NioServerSocketChannel类的介绍)，但是Netty已经将这个bug进行了处理。</li><li>其他原因</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p><p><a href="https://www.nenggz.com/">https://www.nenggz.com/</a></p><p><a href="https://blog.csdn.net/yinwenjie/article/details/48522403">https://blog.csdn.net/yinwenjie/article/details/48522403</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java-IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="/mingyry/1c6ba3e2.html"/>
      <url>/mingyry/1c6ba3e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>non-blocking io 非阻塞 IO</p><h3 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h3><h4 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h4><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>buffer 则用来缓冲读写数据，常见的 buffer 有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h4 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h4><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p><h5 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="⚠️-多线程版缺点"><a href="#⚠️-多线程版缺点" class="headerlink" title="⚠️ 多线程版缺点"></a>⚠️ 多线程版缺点</h5><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><h5 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="⚠️-线程池版缺点"><a href="#⚠️-线程池版缺点" class="headerlink" title="⚠️ 线程池版缺点"></a>⚠️ 线程池版缺点</h5><ul><li>阻塞模式下，线程仅能处理一个 socket 连接</li><li>仅适合短连接场景</li></ul><h5 id="selector-版设计"><a href="#selector-版设计" class="headerlink" title="selector 版设计"></a>selector 版设计</h5><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p><h3 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h3><h4 id="2-1-ByteBuffer-正确使用姿势"><a href="#2-1-ByteBuffer-正确使用姿势" class="headerlink" title="2.1  ByteBuffer 正确使用姿势"></a>2.1  ByteBuffer 正确使用姿势</h4><ol><li>向 buffer 写入数据，例如调用 channel.read(buffer)</li><li>调用 flip() 切换至<strong>读模式</strong></li><li>从 buffer 读取数据，例如调用 buffer.get()</li><li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li><li>重复 1~4 步骤</li></ol><h4 id="2-2-ByteBuffer-结构"><a href="#2-2-ByteBuffer-结构" class="headerlink" title="2.2 ByteBuffer 结构"></a>2.2 ByteBuffer 结构</h4><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>一开始</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0021.png" alt=""></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0018.png" alt=""></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0019.png" alt=""></p><p>读取 4 个字节后，状态</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0020.png" alt=""></p><p>clear 动作发生后，状态</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0021.png" alt=""></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0022.png" alt=""></p><h4 id="2-3-ByteBuffer-常见方法"><a href="#2-3-ByteBuffer-常见方法" class="headerlink" title="2.3 ByteBuffer 常见方法"></a>2.3 ByteBuffer 常见方法</h4><h5 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h5><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bytebuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h5 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h5><p>有两种办法</p><ul><li>调用 channel 的 read 方法</li><li>调用 buffer 自己的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h5 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h5><p>同样有两种办法</p><ul><li>调用 channel 的 write 方法</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ul><h5 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h5><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p><strong>注意</strong></p><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><h5 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"></span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure><h5 id="⚠️Buffer-是非线程安全的"><a href="#⚠️Buffer-是非线程安全的" class="headerlink" title="⚠️Buffer 是非线程安全的"></a>⚠️Buffer 是<strong>非线程安全的</strong></h5><h3 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h3><h4 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h4><h5 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h5><blockquote><p>FileChannel 只能工作在阻塞模式下</p></blockquote><h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure><h5 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h5><p>写入的正确姿势如下， SocketChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><p>获取当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1 </li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h5 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h5><p>使用 size 方法获取文件的大小</p><h5 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h5><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h4 id="3-2-两个-Channel-传输数据"><a href="#3-2-两个-Channel-传输数据" class="headerlink" title="3.2 两个 Channel 传输数据"></a>3.2 两个 Channel 传输数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;helloword/data.txt&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;helloword/to.txt&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    ) &#123;</span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferTo 用时：8.2011</span><br></pre></td></tr></table></figure><p>超过 2g 大小的文件传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="comment">// left 变量代表还剩余多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;position:&quot;</span> + (size - left) + <span class="string">&quot; left:&quot;</span> + left);</span><br><span class="line">                left -= from.transferTo((size - left), left, to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际传输一个超大文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position:0 left:7769948160</span><br><span class="line">position:2147483647 left:5622464513</span><br><span class="line">position:4294967294 left:3474980866</span><br><span class="line">position:6442450941 left:1327497219</span><br></pre></td></tr></table></figure><h4 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h4><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">|- data</span><br><span class="line">|- projects</span><br><span class="line">|- a</span><br><span class="line">|- b</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure><p>会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure><h4 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h4><h5 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a><strong>检查文件是否存在</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure><h5 id="创建一级目录"><a href="#创建一级目录" class="headerlink" title="创建一级目录"></a><strong>创建一级目录</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><h5 id="创建多级目录用"><a href="#创建多级目录用" class="headerlink" title="创建多级目录用"></a><strong>创建多级目录用</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure><h5 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a><strong>拷贝文件</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><h5 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a><strong>删除目录</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><h5 id="遍历目录文件"><a href="#遍历目录文件" class="headerlink" title="遍历目录文件"></a><strong>遍历目录文件</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="统计-jar-的数目"><a href="#统计-jar-的数目" class="headerlink" title="统计 jar 的数目"></a><strong>统计 jar 的数目</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\a&quot;</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="⚠️-删除很危险"><a href="#⚠️-删除很危险" class="headerlink" title="⚠️ 删除很危险"></a>⚠️ 删除很危险</h4><blockquote><p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p></blockquote><h5 id="拷贝多级目录"><a href="#拷贝多级目录" class="headerlink" title="拷贝多级目录"></a><strong>拷贝多级目录</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source, target);</span><br><span class="line">        <span class="comment">// 是目录</span></span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是普通文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">            Files.copy(path, Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure><h3 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h3><h4 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs 阻塞"></a>4.1 非阻塞 vs 阻塞</h4><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h5><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><p>服务器端，客户端代码不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h4 id="4-2-Selector"><a href="#4-2-Selector" class="headerlink" title="4.2 Selector"></a>4.2 Selector</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>好处</p><ul><li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li><li>让这个线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure><h5 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h5><p>也称之为注册事件，绑定的事件 selector 才会关心 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h5 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h5><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure><p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure><h5 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h5><blockquote><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用 selector.wakeup()</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul></blockquote><h4 id="4-3-处理-accept-事件"><a href="#4-3-处理-accept-事件" class="headerlink" title="4.3 处理 accept 事件"></a>4.3 处理 accept 事件</h4><p>客户端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h5><blockquote><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p></blockquote><h4 id="4-4-处理-read-事件"><a href="#4-4-处理-read-事件" class="headerlink" title="4.4 处理 read 事件"></a>4.4 处理 read 事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启两个客户端，修改一下发送文字，输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h5 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h5><blockquote><p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li></ul></blockquote><h5 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h5><blockquote><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p></blockquote><h5 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️  不处理边界的问题"></a>⚠️  不处理边界的问题</h5><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> in.read(arr);</span><br><span class="line">                <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> max.getOutputStream();</span><br><span class="line">        out.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line">        max.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hell</span><br><span class="line">owor</span><br><span class="line">ld�</span><br><span class="line">�好</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么？</p><h5 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/0023.png" alt=""></p><ul><li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>另一种思路是按分隔符拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure><h5 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h5><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h4 id="4-5-处理-write-事件"><a href="#4-5-处理-write-事件" class="headerlink" title="4.5 处理 write 事件"></a>4.5 处理 write 事件</h4><h5 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h5><ul><li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li><li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h5><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p><h4 id="4-6-更进一步"><a href="#4-6-更进一步" class="headerlink" title="4.6 更进一步"></a>4.6 更进一步</h4><h5 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h5><blockquote><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p></blockquote><p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BossEventLoop</span>().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BossEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">ssckey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line"><span class="comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkerEventLoop</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(worker, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h5><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h3 id="5-Reactor模型示例"><a href="#5-Reactor模型示例" class="headerlink" title="5. Reactor模型示例"></a>5. Reactor模型示例</h3><p>参考文章：<a href="https://www.nenggz.com/md/java/io/java-io-nio-select-epoll.html">https://www.nenggz.com/md/java/io/java-io-nio-select-epoll.html</a></p><p>对于上述Reactor模型，服务端主要有三个角色：Reactor，Acceptor和Handler。这里基于Doug Lea的文档对其进行了实现，如下是Reactor的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    serverSocket = ServerSocketChannel.open();  <span class="comment">// 创建服务端的ServerSocketChannel</span></span><br><span class="line">    serverSocket.configureBlocking(<span class="literal">false</span>);  <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    selector = Selector.open();  <span class="comment">// 创建一个Selector多路复用器</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));  <span class="comment">// 绑定服务端端口</span></span><br><span class="line">    key.attach(<span class="keyword">new</span> <span class="title class_">Acceptor</span>(serverSocket));  <span class="comment">// 为服务端Channel绑定一个Acceptor</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        selector.select();  <span class="comment">// 服务端使用一个线程不断等待客户端的连接到达</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          dispatch(iterator.next());  <span class="comment">// 监听到客户端连接事件后将其分发给Acceptor</span></span><br><span class="line">          iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        selector.selectNow();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 这里的attachement也即前面为服务端Channel绑定的Acceptor，调用其run()方法进行</span></span><br><span class="line">    <span class="comment">// 客户端连接的获取，并且进行分发</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">attachment</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line">    attachment.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Reactor首先开启了一个ServerSocketChannel，然后将其绑定到指定的端口，并且注册到了一个多路复用器上。接着在一个线程中，其会在多路复用器上等待客户端连接。当有客户端连接到达后，Reactor就会将其派发给一个Acceptor，由该Acceptor专门进行客户端连接的获取。下面我们继续看一下Acceptor的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverSocket)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.serverSocket = serverSocket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 获取客户端连接</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">null</span> != channel) &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Handler</span>(channel));  <span class="comment">// 将客户端连接交由线程池处理</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，在Acceptor获取到客户端连接之后，其就将其交由线程池进行网络读写了，而这里的主线程只是不断监听客户端连接事件。下面我们看看Handler的具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Selector selector;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">  <span class="keyword">private</span> SelectionKey key;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ByteBuffer</span> <span class="variable">input</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ByteBuffer</span> <span class="variable">output</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    channel.configureBlocking(<span class="literal">false</span>);  <span class="comment">// 设置客户端连接为非阻塞模式</span></span><br><span class="line">    selector = Selector.open();  <span class="comment">// 为客户端创建一个新的多路复用器</span></span><br><span class="line">    key = channel.register(selector, SelectionKey.OP_READ);  <span class="comment">// 注册客户端Channel的读事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (selector.isOpen() &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = select();  <span class="comment">// 等待客户端事件发生</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果当前是读事件，则读取数据</span></span><br><span class="line">          <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            read(key);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">           <span class="comment">// 如果当前是写事件，则写入数据</span></span><br><span class="line">            write(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里处理的主要目的是处理Jdk的一个bug，该bug会导致Selector被意外触发，但是实际上没有任何事件到达，</span></span><br><span class="line">  <span class="comment">// 此时的处理方式是新建一个Selector，然后重新将当前Channel注册到该Selector上</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;SelectionKey&gt; <span class="title function_">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    <span class="keyword">if</span> (keys.isEmpty()) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> key.interestOps();</span><br><span class="line">      selector = Selector.open();</span><br><span class="line">      key = channel.register(selector, interestOps);</span><br><span class="line">      <span class="keyword">return</span> select();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取客户端发送的数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    channel.read(input);</span><br><span class="line">    <span class="keyword">if</span> (input.position() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input.flip();</span><br><span class="line">    process();  <span class="comment">// 对读取的数据进行业务处理</span></span><br><span class="line">    input.clear();</span><br><span class="line">    key.interestOps(SelectionKey.OP_WRITE);  <span class="comment">// 读取完成后监听写入事件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    output.flip();</span><br><span class="line">    <span class="keyword">if</span> (channel.isOpen()) &#123;</span><br><span class="line">      channel.write(output);  <span class="comment">// 当有写入事件时，将业务处理的结果写入到客户端Channel中</span></span><br><span class="line">      key.channel();</span><br><span class="line">      channel.close();</span><br><span class="line">      output.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，</span></span><br><span class="line">  <span class="comment">// 则直接将其处理过程放入线程池即可，并且使用一个Future获取处理结果，最后写入客户端Channel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[input.remaining()];</span><br><span class="line">    input.get(bytes);</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, CharsetUtil.UTF_8);</span><br><span class="line">    System.out.println(<span class="string">&quot;receive message from client: \n&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    output.put(<span class="string">&quot;hello client&quot;</span>.getBytes());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Handler中，主要进行的就是为每一个客户端Channel创建一个Selector，并且监听该Channel的网络读写事件。当有事件到达时，进行数据的读写，而业务操作这交由具体的业务线程池处理。</p><h2 id="Netty各个组件介绍"><a href="#Netty各个组件介绍" class="headerlink" title="Netty各个组件介绍"></a>Netty各个组件介绍</h2><p>以聊天室为例，介绍服务器的各个组件和及其作用</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230513184334496.png" alt="image-20230513184334496"></p><h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>负责初始化Netty服务器，所有的Netty组件都需要添加到服务器中。</p><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><ul><li><p>group(parentGroup，childGroup)</p><p>向服务器中加入 EventLoopGroup组，用于处理Channel的所有事件，包括io事件。</p><p>parentGroup负责接受新的连接，childGroup负责处理事件</p></li><li><p>channel()</p><p>选择服务Scoket的实现类，NioServerLoopEvent表示基于NIO的客户端的实现</p></li><li><p>childHandler()</p><p>添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），里面的参数是表示要处理的Channel的类型，它的作用是待客户端 SocketChannel（是一个接口，里面包含所有实现的SocketChannel类） 建立连接后，执行 initChannel 以便添加更多的处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>bind() / connect() </p><p>绑定对应的端口号 / 连接对应的ip地址和端口</p></li><li><p>sync()</p><p>ChannelFuture中的sync方法，等待异步方法bind绑定端口完成，主线程是main线程，进行绑定的是nio线程，如果不同步，main线程会直接运行</p></li><li><p>channel.closeFuture().sync()</p><p>让main方法阻塞，等待网络组件关闭的通知，如果没有该代码，main方法会直接结束</p></li></ul><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>EventLoopGroup是一组EventLoop，Channel 一般会调用EventLoopGroup的<code>reister</code>方法来绑定其中的一个EventLoop，然后Channel上的事件io都由此EventLoop来处理（保证了io时间处理时的线程安全）</p><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>就是一个单线程的执行器（同时每一个EventLoop维护一个Selector）来监听多个Channel的事件</p><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Boss组，主要是负责连接的建立，只需要一个线程即可</span></span><br><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">(nThreads, Executor)内的参数可以自定义，线程个数和线程池</span><br><span class="line">还可以定义Seletor的提供器</span><br><span class="line">() 无参情况下，默认的线程数是本地的处理器的数量的<span class="number">2</span>倍</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置Worker组，主要负责SocketChannel的数据的读写，处理业务逻辑</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">   boss线程中，绑定几个端口，一般就会用到几个eventLoop，这样可以把绑定的端口个数和设置的线程数定在一起</span><br><span class="line">    但是文档中也表示，不需要设置，因为如果没有使用的eventLoop的状态是NOT_STARTED，该eventLoop就不会被启用</span><br><span class="line">一般应用服务的QPS几百万，worker设置为<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230814135546870.png" alt="image-20230814135546870"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="主要操作方法"><a href="#主要操作方法" class="headerlink" title="主要操作方法"></a>主要操作方法</h4><ul><li><p>close() </p><p>关闭当前channel</p></li><li><p>closeFuture()</p><p>异步处理channel的关闭</p><ul><li>利用sync 方法来等待关闭</li><li>利用addListener 方法来异步主动关闭channel</li></ul></li><li><p>pipeline()</p><p>添加处理器</p></li><li><p>write()</p><p>将数据写入到channel中，等待程序输出到接收方</p></li><li><p>writeAndFlush()</p><p>将数据写入到channel中，并且直接刷出</p></li></ul><h3 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3><p>异步处理所使用的接口</p><p>Future继承JDK的future，Promise是对netty的future的扩展</p><p>具体区别：</p><ul><li>JDK Future：只能同步等待任务结束、成功或者失败，任务结束才能够得到结果</li><li>Netty Future：可以同步等待任务结束、成功或者失败，也可以异步方式等待任务，但都需要任务结束</li><li>Netty Promise：不仅包含Future的功能，还可以脱离任务存在，作为两个线程之间的通信工具，可以设置成功和失败</li></ul><p><strong>方法列表：</strong></p><div class="table-container"><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addListener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table></div><p><strong>1）异步处理addListener成功</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调，异步接收结果</span></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的 future 就是上面的 promise</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1000 后设置成功结果</span></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">30</span> [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">31</span> [DEBUG] [defaultEventLoop-<span class="number">1</span>-<span class="number">1</span>] c.i.o.DefaultPromiseTest2 - set success, <span class="number">10</span></span><br><span class="line"><span class="number">11</span>:<span class="number">49</span>:<span class="number">31</span> [DEBUG] [defaultEventLoop-<span class="number">1</span>-<span class="number">1</span>] c.i.o.DefaultPromiseTest2 - <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>2）异步处理任务 失败</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">12</span>:<span class="number">04</span>:<span class="number">57</span> [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line"><span class="number">12</span>:<span class="number">04</span>:<span class="number">58</span> [DEBUG] [defaultEventLoop-<span class="number">1</span>-<span class="number">1</span>] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line"><span class="number">12</span>:<span class="number">04</span>:<span class="number">58</span> [DEBUG] [defaultEventLoop-<span class="number">1</span>-<span class="number">1</span>] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure><h3 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理Channel上的各种事件，Pipeline是多个Handler组成的线</p><p>ChannelHandler有两种：</p><ul><li><strong>ChannelInboundHandlerAdapter</strong>的子类：入站处理器，主要作用是读取客户端的数据，并且写回结果</li><li><strong>ChannelOutboundHandlerAdapter</strong>的子类：出站处理器，主要对写回的结果进行加工</li></ul><p><strong>执行顺序：</strong></p><ul><li><p>ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，</p></li><li><p>ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。</p></li><li>ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514104007261.png" alt="image-20230514104007261"></p><p><strong>传递过程:</strong></p><p>在每一个Handler中都有一个<strong>ChannelHandlerContex(ctx)</strong> 参数，表示处理器上下文，可以进行传递</p><ul><li><p>ctx.fireChannelRead(msg)</p><p>调用下一个入站处理器</p></li><li><p>ctx.write(msg, promise)</p><p>触发上一个出站处理器</p></li><li><p>ctx.channel().write(msg)</p><p>从pipeline的尾部开始触发出站处理器，</p></li></ul><p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514105420505.png" alt="image-20230514105420505"></p><h4 id="Handler所实现的方法"><a href="#Handler所实现的方法" class="headerlink" title="Handler所实现的方法"></a>Handler所实现的方法</h4><p><strong>ChannelInboundHandlerAdapter</strong>：</p><div class="table-container"><table><thead><tr><th>方法名称</th><th>触发事件</th></tr></thead><tbody><tr><td>channelActive()</td><td>在连接建立后触发 active 事件</td></tr><tr><td>channelInactive()</td><td>当连接断开时触发 inactive 事件</td></tr><tr><td>channelRead()</td><td>触发read事件，可能有消息分段发送，每次读取一段</td></tr><tr><td>channelReadComplete()</td><td>在每条消息全部读取完毕后调用</td></tr><tr><td>userEventTriggered()</td><td>触发用户的自定义事件</td></tr><tr><td>channelWritabilityChanged()</td><td>channel的写状态变化的时候触发</td></tr><tr><td>exceptionCaught()</td><td>当出现异常时触发 异常事件</td></tr></tbody></table></div><p><strong>ChannelOutboundHandlerAdapter</strong>：</p><div class="table-container"><table><thead><tr><th>回调方法</th><th>触发时机</th><th>client</th><th>server</th></tr></thead><tbody><tr><td>bind(ChannelHandlerContext,SocketAddress,ChannelPromise)</td><td>当请求将 Channel 绑定到本地地址时被调用</td><td>false</td><td>true</td></tr><tr><td>connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)</td><td>当请求将 Channel 连接到远程节点时被调用</td><td>true</td><td>false</td></tr><tr><td>disconnect(ChannelHandlerContext,ChannelPromise)</td><td>当请求将 Channel 从远程节点断开时被调用</td><td>true</td><td>false</td></tr><tr><td>close(ChannelHandlerContext,ChannelPromise)</td><td>当请求关闭 Channel 时被调用</td><td>false</td><td>true</td></tr><tr><td>deregister(ChannelHandlerContext,ChannelPromise)</td><td>当请求将 Channel 从它的 EventLoop 注销时被调用</td><td></td><td></td></tr><tr><td>read(ChannelHandlerContext)</td><td>当请求从 Channel 读取更多的数据时被调用</td><td>true</td><td>true</td></tr><tr><td>write(ChannelHandlerContext,Object,ChannelPromise)</td><td>当请求通过 Channel 将数据写到</td><td>true</td><td>true</td></tr><tr><td>flush(ChannelHandlerContext)</td><td>远程节点时被调用当请求通过 Channel 将入队数据冲刷到远程节点时被调</td><td>true</td><td>true</td></tr></tbody></table></div><p>一些回调方法有ChannelPromise这个参数，我们可以调用它的addListener注册监听，当回调方法所对应的操作完成后，会触发这个监听</p><p><strong>SimpleChannelInboundHandler<T></strong>：</p><p>当消息的类型是指定的泛型才会调用该处理器</p><p><strong>处理泛型的泛型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;Result&lt;User&gt;&gt;</span></span><br><span class="line"><span class="comment">// SimpleChannelInboundHandler是通过acceptInboundMessage这个方法来判断当前的类型是否匹配</span></span><br><span class="line"><span class="comment">// Netty会匹配到Result就结束</span></span><br><span class="line"><span class="comment">// 我们如果想要修改匹配的规则，就要重写acceptInboundMessage方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof方法</span></span><br><span class="line">测试它左边的对象是否是它右边的类的实例</span><br><span class="line">类的实例包含本身的实例，以及所有直接或间接子类的实例        </span><br></pre></td></tr></table></figure><p><strong>ChannelDuplexHandler：</strong></p><p>既处理入站事件又要处理出站事件</p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><h4 id="ByteBuf相关内容"><a href="#ByteBuf相关内容" class="headerlink" title="ByteBuf相关内容"></a>ByteBuf相关内容</h4><p>Netty对ByteBuffer进行封装，加入了很多功能</p><p><strong>1）创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用ByteBufAllocator池化创建一个默认的buffer，容量大小为10</span></span><br></pre></td></tr></table></figure><p><strong>2）直接内存与堆内存</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建池化基于堆的ByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建池化基于直接内存的ByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比</span></span><br><span class="line">* 直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</span><br><span class="line">* 直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</span><br></pre></td></tr></table></figure><p><strong>3）池化与非池化</strong></p><p>池化的最大意义在于可以重用 ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 池化功能的开启与关闭 通过系统环境变量来设置</span></span><br><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure><p><strong>4）组成</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514110319663.png" alt="image-20230514110319663"></p><p><strong>5）写入方法</strong></p><div class="table-container"><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01\</td><td>00 代表 true\</td><td>false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td></tr></tbody></table></div><blockquote><p>注意</p><ul><li><p>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</p></li><li><p>网络传输，默认习惯是 Big Endian：将高序字节存储在起始地址</p><p>例如：0x1234abcd 存在内存中</p><p>地址01：12，地址02：34，地址03：ab，地址04：cd</p></li></ul></blockquote><p>此外还有对应的Set方法，Set方法的作用是不改变写指针的位置</p><p><strong>6）扩容</strong></p><p>扩容的规则：</p><ul><li>写入后数据大小未超过512，扩容的大小是16的整数倍</li><li>写入后数据大小超过512，扩容的大小是2的n次方</li><li>扩容不能超过max capacity</li></ul><p><strong>7）读取方法</strong></p><p>就是写操作的反向</p><p>例如：</p><p>​    readByte()  读取一个字节<br>​    readInt()  读取四个字节</p><p><strong>重复读取</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.markReaderIndex(); <span class="comment">// 先做一个读取的标记</span></span><br><span class="line">System.out.println(buffer.readInt()); <span class="comment">// 在进行读取</span></span><br><span class="line">buffer.resetReaderIndex() <span class="comment">// 再重置到标记的位置</span></span><br></pre></td></tr></table></figure><p>get方法不会改变读指针的位置</p><p><strong>8）释放ByteBuf内存</strong></p><p>几种内存的释放情况：</p><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty使用引用计数法来控制内存的回收，每个ByteBuf都实现了ReferenceCounted 接口</p><ul><li>每个初始的ByteBuf对象计数为1</li><li>调用<strong>release</strong>方法，使计数减1，如果计数为0，则会被回收</li><li>调用<strong>retain</strong>方法，使计数加1，即使其他Handler调用了release方法也不会被回收</li><li>如果计数为0，底层内存会被回收，这时候调用ByteBuf的所有方法都失效</li></ul><p><strong>release的释放时机</strong></p><ul><li>Handler在最后使用了ByteBuf，就需要释放它</li><li>如果没有值传递的调用，那么也需要释放ByteBuf</li><li>如果没有成功传递，出现异常，也需要释放ByteBuf</li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><h4 id="ByteBuf的拷贝"><a href="#ByteBuf的拷贝" class="headerlink" title="ByteBuf的拷贝"></a>ByteBuf的拷贝</h4><p><strong>1）sline</strong></p><p>【零拷贝的体现】切片拷贝，没有发生内存复制，使用原始的ByteBuf内存，只是维护独立的read和write指针</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514115333893.png" alt="image-20230514115333893"></p><p><strong>2）duplicate</strong></p><p>【零拷贝的体现】完整拷贝，没有发生内存复制，使用原始的ByteBuf内存，只是维护独立的read和write指针</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514142040907.png" alt="image-20230514142040907"></p><p><strong>3）CompositeByteBuf</strong></p><p>【零拷贝的体现】可以将多个ByteBuf合成一个逻辑上的ByteBuf，避免拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure><h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul><h2 id="Netty解决粘包半包问题"><a href="#Netty解决粘包半包问题" class="headerlink" title="Netty解决粘包半包问题"></a>Netty解决粘包半包问题</h2><h3 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h3><p><strong>粘包情况：</strong></p><ul><li>现象，发送 abc def，接收 abcdef</li><li>原因<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul><p><strong>半包情况：</strong></p><ul><li>现象，发送 abcdef，接收 abc def</li><li>原因<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><p>服务端修改接收缓冲区的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);  <span class="comment">// option可以调整参数的大小</span></span><br><span class="line"><span class="comment">// 同理客户端也可以修改发送缓冲区的大小</span></span><br></pre></td></tr></table></figure><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><h4 id="1-短链接"><a href="#1-短链接" class="headerlink" title="1.短链接"></a>1.短链接</h4><p>发送一个包，建立一次连接，能够避免粘包的现象。但是效率太低</p><h4 id="2-固定长度"><a href="#2-固定长度" class="headerlink" title="2.固定长度"></a>2.固定长度</h4><p>客户端和服务器端约定一个固定长度的数据包</p><p>服务器端加入内置的定长的编码处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>客户端怎么发送包，都能够把每个数据包解码成8个字节</p><p><strong>缺点：</strong></p><ul><li>不好确定数据包的大小</li><li>太小，某些数据不够，太大，数据空间浪费</li></ul><h4 id="3-固定分隔符"><a href="#3-固定分隔符" class="headerlink" title="3.固定分隔符"></a>3.固定分隔符</h4><p>约定以\n，\r\n作为消息的分割符，如果超出指定长度，仍然没有出现分隔符，则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><h4 id="4-预设长度"><a href="#4-预设长度" class="headerlink" title="4.预设长度"></a>4.预设长度</h4><p>在发送消息前，先约定用定长的字节数来表示接下来的数据的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="Netty自带的编解码器"><a href="#Netty自带的编解码器" class="headerlink" title="Netty自带的编解码器"></a>Netty自带的编解码器</h3><ol><li><p><strong>LineBasedFrameDecoder</strong></p><p>LineBasedFrameDecoder是回车换行解码器，如果发送的消息以回车换行符结束标识，可以用LineBasedFrameDecoder进行解码。</p></li><li><p><strong>DelimiterBasedFrameDecoder</strong></p><p>DelimiterBasedFrameDecoder是分隔符解码器，用户可以指定消息结束的分隔符，它可以自动选择分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>,delimiter));  <span class="comment">// delimiter 分隔符的Byte</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FixedLengthFrameDecoder</strong></p><p>FixedLengthFrameDecoder是固定长度解码器，能够按照固定的长度进行解码</p></li><li><p><strong>LengthFieldBasedFrameDecoder</strong></p><p>LengthFieldBasedFrameDecoder是预设长度的解码器，能够设置参数来获取对应的信息。</p></li></ol><h2 id="Netty协议设计与解析"><a href="#Netty协议设计与解析" class="headerlink" title="Netty协议设计与解析"></a>Netty协议设计与解析</h2><p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则，也就是遵循一定的规则来把整个TCP传入的流式信息解析出来。获取到各个部分对应的内容。</p><p><strong>举例：</strong></p><ul><li>redis协议</li><li>http协议</li></ul><p>我们要进行双方的通信，需要自定义协议，双方根据协议来传输信息</p><h3 id="自定义协议的要素"><a href="#自定义协议的要素" class="headerlink" title="自定义协议的要素"></a>自定义协议的要素</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><p><strong>Netty 的编解码器抽象类主要有以下两种：</strong></p><ul><li>实现从字节到消息的编解码（<code>ByteToMessageCodec</code>）。不能用<strong>@Sharable</strong>进行注释</li><li>实现从消息到消息的编解码（<code>MessageToMessageCodec</code>）。</li></ul><blockquote><p>@Sharable</p><p>标志同一个ChannelHandler的实例能否被<strong>多次</strong>加入到pipeline中</p><p>即该Handler能不能被多个pipeline所共享，不存在不能够被共享的内容</p><p><strong>注意</strong>，如果消息是<code>ReferenceCounted</code>类型，则需要对刚刚通过的消息调用<code>ReferenceCounted.ratain()</code>。这个调用是必须的，因为<code>MessageToMessageCodec</code>将在编码/解码的消息上调用<code>ReferenceCounted.ralease()</code>。</p></blockquote><h4 id="自定义编解码器"><a href="#自定义编解码器" class="headerlink" title="自定义编解码器"></a>自定义编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p><blockquote><p>byte 类型可以自动转为int类型 int类型不能自动转为byte类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230514150229150.png" alt="image-20230514150229150"></p><h3 id="💡-什么时候可以加-Sharable"><a href="#💡-什么时候可以加-Sharable" class="headerlink" title="💡 什么时候可以加 @Sharable"></a>💡 什么时候可以加 @Sharable</h3><ul><li>handler不保存状态时，就可以安全地在多线程下被共享</li><li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li></ul><h2 id="Netty心跳机制"><a href="#Netty心跳机制" class="headerlink" title="Netty心跳机制"></a>Netty心跳机制</h2><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><p><strong>服务器端解决：</strong></p><ul><li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>客户端解决：</strong></p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            <span class="comment">//  log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IdleStateHandler</span><span class="params">(<span class="type">long</span> readerIdleTime, <span class="type">long</span> writerIdleTime, <span class="type">long</span> allIdleTime, TimeUnit unit)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(ObserveOutput(<span class="literal">false</span>), readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ObserveOutput标志用来解决慢输出问题。</span></span><br><span class="line"><span class="comment">// 如果设置为true，那么即使写过程中发生了写空闲事件，但是只要hasOutputChanged方法判断此时仍然在向外写（写缓存发生变化），那么就不会为此次超时产生写超时事件。</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> readerIdleTime：读空闲超时时间</span><br><span class="line"><span class="number">2.</span> writerIdleTime：写空闲超时时间</span><br><span class="line"><span class="number">3.</span> allIdleTime: 所有类型的空闲超时时间</span><br><span class="line"><span class="number">4.</span> unit: 时间的单位</span><br></pre></td></tr></table></figure><h2 id="Netty面试题"><a href="#Netty面试题" class="headerlink" title="Netty面试题"></a>Netty面试题</h2><h3 id="BIO，NIO，AIO有啥区别？"><a href="#BIO，NIO，AIO有啥区别？" class="headerlink" title="BIO，NIO，AIO有啥区别？"></a>BIO，NIO，AIO有啥区别？</h3><ul><li>BIO：阻塞式IO，发起请求到读取数据必须阻塞</li><li>NIO：非阻塞式IO，发起请求，通过监听器询问数据是否准备好，读取数据时阻塞线程</li><li>AIO：异步IO，发起请求，等操作系统自动读取数据</li></ul><h3 id="Netty是什么"><a href="#Netty是什么" class="headerlink" title="Netty是什么"></a>Netty是什么</h3><p>基于NIO的高性能的网络框架，支持多种协议，简化网络编程，提供更好的性能和安全性</p><h3 id="为什么不直接用NIO"><a href="#为什么不直接用NIO" class="headerlink" title="为什么不直接用NIO"></a>为什么不直接用NIO</h3><p>NIO编程复杂，并且存在BUG，并且在面对断连重连、包丢失、粘包等问题不好解决</p><h3 id="为什么用Netty"><a href="#为什么用Netty" class="headerlink" title="为什么用Netty"></a>为什么用Netty</h3><ul><li>统一API，支持阻塞和非阻塞</li><li>自带解码器解决TCP粘包/拆包问题</li><li>自带各种协议栈</li><li>安全性不错</li></ul><h3 id="Netty的应用场景"><a href="#Netty的应用场景" class="headerlink" title="Netty的应用场景"></a>Netty的应用场景</h3><ul><li>作为RPC框架的网络通信工具：负责不同服务节点之间的通信</li><li>实现一个HTTP服务器：例如Tomcat</li><li>实现一个即时通讯系统：类似微信</li><li>实现一个消息推送系统</li></ul><h3 id="用到Netty的开源项目"><a href="#用到Netty的开源项目" class="headerlink" title="用到Netty的开源项目"></a>用到Netty的开源项目</h3><p>Dubbo，RocketMQ，Elasticsearch，gRPC</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL慢查询优化</title>
      <link href="/mingyry/cb8b299f.html"/>
      <url>/mingyry/cb8b299f.html</url>
      
        <content type="html"><![CDATA[<h1 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h1><h2 id="Explain执行计划"><a href="#Explain执行计划" class="headerlink" title="Explain执行计划"></a>Explain执行计划</h2><h3 id="慢查询优化思路"><a href="#慢查询优化思路" class="headerlink" title="慢查询优化思路"></a>慢查询优化思路</h3><ol><li>慢查询日志记录慢SQL</li><li>explain分析SQL的执行计划</li><li>profile 分析执行耗时</li><li>Optimizer Trace分析详情</li><li>确定问题并采用相应的措施</li></ol><h4 id="慢查询日志记录慢SQL"><a href="#慢查询日志记录慢SQL" class="headerlink" title="慢查询日志记录慢SQL"></a>慢查询日志记录慢SQL</h4><p>默认情况下，MySQL不开启慢查询日志（slow query log），所以需要手动打开。</p><p>查看下慢查询日志配置，我们可以使用<code>show variables like &#39;slow_query_log%&#39;</code>命令，如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230805105051776.png" alt="image-20230805105051776"></p><ul><li><code>slow query log</code>表示慢查询开启的状态</li><li><code>slow_query_log_file</code>表示慢查询日志存放的位置</li></ul><p>使用<code>show variables like &#39;long_query_time&#39;</code>命令，查看超过多少时间，才记录到慢查询日志</p><ul><li><code>long_query_time</code>表示查询超过多少秒才记录到慢查询日志。</li></ul><h4 id="explain查看分析SQL的执行计划"><a href="#explain查看分析SQL的执行计划" class="headerlink" title="explain查看分析SQL的执行计划"></a>explain查看分析SQL的执行计划</h4><p>使用<code>explain</code>查看<code>SQL</code>的执行计划</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230805105551682.png" alt="image-20230805105551682"></p><p>重点关注<code>type、key、rows、filtered、extra</code></p><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>type表示<strong>连接类型</strong>，查看索引执行情况的一个重要指标。以下性能从好到坏依次：<code>system  &gt; const &gt; eq_ref &gt; ref  &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</code></p><ul><li><p>system：这种类型要求数据库表中只有一条数据，是<code>const</code>类型的一个特例，一般情况下是不会出现的。</p></li><li><p><strong>const：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，，速度非常快。</strong></p></li><li><p><strong>eq_ref：常用于主键或唯一索引扫描，一般指使用主键的关联查询</strong></p></li><li><p><strong>ref : 常用于非主键和唯一索引扫描。</strong></p></li><li><p>ref_or_null：这种连接类型类似于<code>ref</code>，区别在于<code>MySQL</code>会额外搜索包含<code>NULL</code>值的行</p></li><li><p>index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。</p></li><li><p>unique_subquery：类似于<code>eq_ref</code>，条件用了<code>in</code>子查询</p></li><li><p>index_subquery：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p></li><li><p><strong>range：常用于范围查询，比如：between … and 或 In 等操作</strong></p></li><li><p>index：全索引扫描</p></li><li><p>ALL：全表扫描</p></li></ul><p>一般不能到 <code>index</code> 和 <code>ALL</code></p><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>该列表示实际用到的索引。一般配合<code>possible_keys</code>列一起看。</p><h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>该列表示MySQL估算要找到我们所需的记录，需要读取的行数。对于InnoDB表，此数字是估计值，并非一定是个准确值</p><h5 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h5><p>该列是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p><h5 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h5><p>该字段包含有关MySQL如何解析查询的其他信息，它一般会出现这几个值：</p><ul><li>Using filesort：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现。一般见于order by语句</li><li>Using index ：表示是否用了覆盖索引。</li><li>Using temporary: 表示是否使用了<strong>临时表,性能特别差</strong>，需要重点优化。一般多见于group by语句，或者union语句。</li><li>Using where : 表示使用了where条件过滤.</li><li>Using index condition：MySQL5.6之后新增的索引下推。在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li></ul><p><strong>注意</strong>: 有时候，<code>explain</code>配合<code>show WARNINGS;</code>（可以查看优化后, 最终执行的sql），效果更佳</p><h4 id="profile-分析执行耗时"><a href="#profile-分析执行耗时" class="headerlink" title="profile 分析执行耗时"></a>profile 分析执行耗时</h4><p><code>explain</code>只是看到<code>SQL</code>的预估执行计划，如果要了解<code>SQL</code><strong>真正的执行线程状态及消耗的时间</strong>，需要使用<code>profiling</code>。开启<code>profiling</code>参数后，后续执行的<code>SQL</code>语句都会记录其资源开销，包括<code>IO，上下文切换，CPU，内存</code>等等，我们可以根据这些开销进一步分析当前慢SQL的瓶颈再进一步进行优化。</p><p><code>profiling</code>默认是关闭，我们可以使用<code>show variables like &#39;%profil%&#39;</code>查看是否开启，如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230805110834116.png" alt="image-20230805110834116"></p><p>使用<code>set profiling=ON</code>开启。开启后，可以运行几条SQL，然后使用<code>show profiles</code>查看一下</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/685bd45b9d8d4ff287e114cadfee9e3f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom:67%;" /></p><p><code>show profiles</code>会显示最近发给服务器的多条语句，条数由变量<code>profiling_history_size</code>定义，默认是15。如果我们需要看单独某条SQL的分析，可以<code>show profile</code>查看最近一条SQL的分析。也可以使用<code>show profile for query id</code>（其中id就是show profiles中的QUERY_ID）查看具体一条的SQL语句分析。除了查看profile ，还可以查看cpu和io</p><p><code>Duration</code>就是执行这条SQL语句所消耗的时间</p><h4 id="Optimizer-Trace分析详情"><a href="#Optimizer-Trace分析详情" class="headerlink" title="Optimizer Trace分析详情"></a>Optimizer Trace分析详情</h4><p>profile只能查看到SQL的执行耗时，但是无法看到SQL真正执行的过程信息，即不知道MySQL优化器是如何选择执行计划。这时候，我们可以使用<code>Optimizer Trace</code>，它可以跟踪执行语句的解析优化执行的全过程。</p><p>我们可以使用<code>set optimizer_trace=&quot;enabled=on&quot;</code>打开开关，接着执行要跟踪的SQL，最后执行<code>select * from information_schema.optimizer_trace</code>跟踪，如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/104017072a6e444388ce0841e8294641~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>查看分析其执行树，会包括三个阶段：</p><ul><li>join_preparation：准备阶段</li><li>join_optimization：分析阶段</li><li>join_execution：执行阶段</li></ul><h4 id="确定问题并采用相应的措施"><a href="#确定问题并采用相应的措施" class="headerlink" title="确定问题并采用相应的措施"></a>确定问题并采用相应的措施</h4><ul><li><p>多数慢SQL都跟索引有关，比如不加索引，索引不生效、不合理等，这时候，我们可以<strong>优化索引</strong>。</p></li><li><p>我们还可以优化SQL语句，比如一些in元素过多问题（分批），深分页问题（基于上一次数据过滤等），进行时间分段查询</p></li><li><p>SQl没办法很好优化，可以改用ES的方式，或者数仓。</p></li><li><p>如果单表数据量过大导致慢查询，则可以考虑分库分表</p></li><li><p>如果数据库在刷脏页导致慢查询，考虑是否可以优化一些参数，跟DBA讨论优化方案</p></li><li><p>如果存量数据量太大，考虑是否可以让部分数据归档</p></li></ul><h2 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h2><h3 id="MySQL慢查询出现的原因"><a href="#MySQL慢查询出现的原因" class="headerlink" title="MySQL慢查询出现的原因"></a>MySQL慢查询出现的原因</h3><h4 id="1-SQL没加索引"><a href="#1-SQL没加索引" class="headerlink" title="1. SQL没加索引"></a>1. SQL没加索引</h4><h4 id="2-SQL索引没生效"><a href="#2-SQL索引没生效" class="headerlink" title="2. SQL索引没生效"></a>2. SQL索引没生效</h4><ul><li>隐式的类型转换，索引失效</li><li>查询条件包含or，左边条件加索引，右边条件没加索引，<strong>注意</strong>：如果<code>or</code>条件的列都加了索引，<strong>索引可能会走也可能不走</strong>，因此可以拆成两个SQL查询语句</li><li>like通配符可能导致索引失效，左模糊匹配</li><li>查询条件不满足联合索引的最左匹配原则</li><li>使用了MySQL的内置函数</li><li>对索引列进行了表达式计算</li><li>对索引列使用 <code>!=</code> 或者 <code>not in</code></li><li>索引字段使用 is null 或者 is not null 可能会失效</li><li>关键字段的编码格式不一样</li></ul><h4 id="3-Limit深分页问题"><a href="#3-Limit深分页问题" class="headerlink" title="3. Limit深分页问题"></a>3. Limit深分页问题</h4><p><code>limit</code>深分页，导致<code>SQL</code>变慢原因有两个：</p><ul><li><code>limit</code>语句会先扫描<code>offset+n</code>行，然后再丢弃掉前<code>offset</code>行，返回后<code>n</code>行数据。也就是说<code>limit 100000,10</code>，就会扫描<code>100010</code>行，而limit <code>0,10</code>，只扫描<code>10</code>行。</li><li><code>limit 100000,10</code> 扫描更多的行数，也意味着<strong>回表更多的次数</strong>。</li></ul><p>两种解决办法：</p><ul><li><strong>标签记录法</strong>：记录前一次搜索的记录id，限制：需要一种类似连续自增的字段。</li><li><strong>延迟关联法</strong>：把条件转移到<strong>主键索引树</strong>，然后减少回表。<strong>优化思路</strong>就是，先通过<code>idx_create_time</code>二级索引树查询到满足条件的<code>主键ID</code>，再与原表通过<code>主键ID</code>内连接，这样后面直接走了主键索引了，同时也减少了回表。</li></ul><h4 id="4-单表数据量太大"><a href="#4-单表数据量太大" class="headerlink" title="4. 单表数据量太大"></a>4. 单表数据量太大</h4><p>B+树高度一般为1-3层，已经满足千万级别的数据存储。</p><p>解决方法：<strong>分库分表</strong></p><h4 id="5-join-或者子查询过多"><a href="#5-join-或者子查询过多" class="headerlink" title="5. join 或者子查询过多"></a>5. join 或者子查询过多</h4><p><strong>尽量不要有超过3个以上的表连接</strong>。</p><p>解决办法：可以使用被驱动表的<strong>索引</strong>，并且使用<strong>小表来做驱动表</strong>，<strong>查询效率更佳</strong>。</p><p>一般情况下，如果业务需要的话，关联<code>2~3</code>个表是可以接受的，但是<strong>关联的字段需要加索引</strong>哈。如果需要关联更多的表，建议从代码层面进行拆分，在业务层先查询一张表的数据，然后以关联字段作为条件查询关联表形成<code>map</code>，然后在业务层进行数据的拼装。</p><h4 id="6-in元素过多"><a href="#6-in元素过多" class="headerlink" title="6. in元素过多"></a>6. in元素过多</h4><p><code>in</code>元素一般建议不要超过<code>500</code>个，如果超过了，建议分组，每次<code>500</code>一组进行。</p><h4 id="7-order-by-文件排序"><a href="#7-order-by-文件排序" class="headerlink" title="7. order by 文件排序"></a>7. order by 文件排序</h4><p>因为<code>order by</code>平时用得多，并且数据量一上来，还是走<strong>文件排序</strong>的话，很容易有慢SQL</p><p>当查看<code>explain</code>执行计划的时候，可以看到<code>Extra</code>这一列，有一个<code>Using filesort</code>，它表示用到<strong>文件排序</strong>。</p><p><code>order by</code>使用<strong>文件排序</strong>，效率会低一点。怎么优化？</p><ul><li>因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不会再用到文件排序啦。而索引数据本身是有序的，我们通过建立索引来优化<code>order by</code>语句。</li><li>我们还可以通过调整<code>max_length_for_sort_data</code>、<code>sort_buffer_size</code>等参数优化；</li></ul><h4 id="8-delete-in子查询不走索引！"><a href="#8-delete-in子查询不走索引！" class="headerlink" title="8. delete + in子查询不走索引！"></a>8. delete + in子查询不走索引！</h4><h4 id="9-group-by使用临时表"><a href="#9-group-by使用临时表" class="headerlink" title="9. group by使用临时表"></a>9. group by使用临时表</h4><p><code>group by</code>一般用于分组统计，它表达的逻辑就是根据<strong>一定的规则，进行分组</strong>。日常开发中，我们使用得比较频繁。如果不注意，很容易产生慢SQL</p><h2 id="MySQL的优化"><a href="#MySQL的优化" class="headerlink" title="MySQL的优化"></a>MySQL的优化</h2><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>数据库对象名称必须使用小写字母并用下划线分割</li><li>数据库名称禁止使用MySQL的保留关键字</li><li>临时库表必须以<code>tem_</code>为前缀，日期为后缀，备份表必须以<code>bak_</code>为前缀，日期为后缀</li><li>所有存储相同数据的列名和列类型必须一致，防止出现隐式类型转换</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><ul><li>所有表使用InnoDB存储引擎</li><li>库和表的字符集统一使用UTF8，如果存储emoji表情，采用utf8mb4字符集</li><li>表和字段需要添加注释</li><li>尽量控制单表的数据量的大小，一般是500万以内，多了就需要分库分表</li><li>经常使用的列放到一个表中</li><li>禁止建立预留字段</li><li>禁止在数据库中存储文件（图片或者视频音频）这类的大的二进制数据，一般这类数据存储于文件服务器中，数据库只存储文件地址信息</li></ul><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><ul><li>优先选择符合存储需要的最小的数据类型</li><li>对于非负型的数据，使用无符号的整型来存储</li><li>小数值类型使用TINYINT类型</li><li>尽可能把所有的列都定义为NOT NULL</li><li>使用TIMESTAMP或者DATETIME类型来存储时间</li><li>使用DECIMAL类型来存储金额类数据</li></ul><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><ul><li>限制单表索引数量，建议单表索引数量不超过5个</li><li>禁止给表中的每一类都建立索引，因为可以使用联合索引</li><li>每个表中都需要主键</li><li>将WHERE，ORDER BY，GROUP BY，DISTINCT中的字段建立索引，或者将多表join的关联列建立索引</li><li><p>避免建立冗余索引和重复索引，例如index（a,b,c）、index(a,b)</p></li><li><p>对频繁的查询优先考虑覆盖索引</p></li><li><p><strong>避免使用外键约束，数据的关联性在业务端实现，需要在表与表之间的关联键上建立索引</strong></p></li></ul><h3 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h3><ul><li>优化对性能影响较大的SQL语句，利用慢查询日志，EXPLAIN</li><li>避免使用select *，无法走覆盖索引</li><li>禁止使用不包含字段列表的INSERT语句</li><li><strong>使用预编译语句进行数据库的操作</strong></li><li>避免数据类型的隐式转换</li><li><strong>避免使用子查询，把子查询优化为join操作</strong></li><li>避免使用JOIN关联太多的表，建议不超过五个</li><li>将批量操作代替单次操作</li><li>将in代替or，or有时候不会走索引</li><li>禁止使用order by rand()进行随机排序</li><li>在明显不会有重复值时使用UNION ALL 而不是 UNION，因为UNION会去重，影响效率</li><li>禁止跨库查询</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><ul><li><p>避免大批量的写操作，要分批多次进行操作</p></li><li><p>对于打包使用pt-online-schema-change来修改表结构</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/mingyry/fec99276.html"/>
      <url>/mingyry/fec99276.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h2><p>其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？</p><p>面试官问你这个问题，<strong>期望的一个回答</strong>是说，你们公司有个什么<strong>业务场景</strong>，这个业务场景有个什么技术挑战，如果不用 MQ 可能会很麻烦，但是你现在用了 MQ 之后带给了你很多的好处。</p><p>先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-1.png" alt="mq-1"></p><p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p><p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-2.png" alt="mq-2"></p><p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-3.png" alt="mq-3"></p><p>一般<strong>互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的</strong>。</p><p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-4.png" alt="mq-4"></p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-5.png" alt="mq-5"></p><p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/mq-6.png" alt="mq-6"></p><p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p><h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><p>缺点有以下几个：</p><ul><li><p>系统可用性降低</p><p>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证消息队列的高可用。</p></li><li><p>系统复杂度提高</p><p>硬生生加个 MQ 进来，你怎么<strong>保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</strong>头大头大，问题一大堆，痛苦不已。</p></li><li><p>一致性问题</p><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p></li></ul><h2 id="消息队列的对比"><a href="#消息队列的对比" class="headerlink" title="消息队列的对比"></a>消息队列的对比</h2><h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table></div><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了。</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高。</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://doocs.gitee.io/advanced-java/">https://doocs.gitee.io/advanced-java/</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型</title>
      <link href="/mingyry/e712e4ca.html"/>
      <url>/mingyry/e712e4ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-行为型"><a href="#设计模式-行为型" class="headerlink" title="设计模式-行为型"></a>设计模式-行为型</h1><p>负责对象间高效沟通和职责委派</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p><p>其实就是一个链表，只是里面的节点是类，可以处理事务</p><font color='red'>希望处理流程可以灵活变化，处理者可以被灵活替换或者增加</font><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230518084556963.png" alt="image-20230518084556963"></p><ol><li><p><strong>处理者</strong> （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p><p>也可以将其设置为抽象类，放入链的构造和需要每个具体处理器的抽象实现，加上传递方法。</p></li><li><p><strong>基础处理者</strong> （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</p><p>通常，该类定义了一个保存对于下个处理者引用的成员变量。</p><p>客户端可以通过将处理者传递给上个处理者的构造函数或设定方法来创建链。</p></li><li><p><strong>具体处理者</strong> （Concrete Handlers） 包含实际处理请求的代码，每个处理者接受请求后，可以选择是否处理或者传递给下一个处理者</p></li><li><strong>客户端</strong> （Client）可以一次性或者动态的生成链，并且请求可以发送给链上的任意一个处理者，而非第一个处理者</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>本例：当某人提出聚餐费用申请的请求后，该请求会在项目经理-部门经理-总经理这样一条链上来传递，但是请求发起者不知道谁来处理他的请求，每个领导会根据自己的职责范围，来判断使处理请求还是把请求交给更高级的领导</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2062729-2be08de919550b8e.png" alt="img"></p><ol><li><p><strong>定义处理类</strong>，处理类是抽象的，里面包括抽象的处理方法</p><p>类里面包含，请求的下一个处理对象，请求的下一个处理对象的设置，还有处理的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义职责对象的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> successor 下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理聚餐费用的申请</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 申请人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fee 申请的钱数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功或失败的具体通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user,<span class="type">double</span> fee)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义具体的处理类，各个部门领导</p><ul><li><p><strong>项目经理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//项目经理的权限比较小，只能在500以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">500</span>)&#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意小李的</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;小李&quot;</span>.equals(user))&#123;</span><br><span class="line">                str = <span class="string">&quot;项目经理同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//其它人一律不同意</span></span><br><span class="line">                str = <span class="string">&quot;项目经理不同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//超过500，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.successor!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> successor.handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>部门经理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//部门经理的权限只能在1000以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意小李申请的</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;小李&quot;</span>.equals(user))&#123;</span><br><span class="line">                str = <span class="string">&quot;部门经理同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//其它人一律不同意</span></span><br><span class="line">                str = <span class="string">&quot;部门经理不同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//超过1000，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.successor!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.successor.handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>总经理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//总经理的权限很大，只要请求到了这里，他都可以处理</span></span><br><span class="line">        <span class="keyword">if</span>(fee &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意小李的</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;小李&quot;</span>.equals(user))&#123;</span><br><span class="line">                str = <span class="string">&quot;总经理同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//其它人一律不同意</span></span><br><span class="line">                str = <span class="string">&quot;总经理不同意&quot;</span>+user+<span class="string">&quot;聚餐费用&quot;</span>+fee+<span class="string">&quot;元的请求&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果还有后继的处理对象，继续传递</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.successor!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> successor.handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>客户端使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先要组装职责链   </span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepManager</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectManager</span>();</span><br><span class="line">        h3.setSuccessor(h2);</span><br><span class="line">        h2.setSuccessor(h1);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//开始测试</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret1</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小李&quot;</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the ret1=&quot;</span>+ret1); </span><br><span class="line">        <span class="type">String</span> <span class="variable">ret2</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小张&quot;</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the ret2=&quot;</span>+ret2); </span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">ret3</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小李&quot;</span>, <span class="number">600</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the ret3=&quot;</span>+ret3); </span><br><span class="line">        <span class="type">String</span> <span class="variable">ret4</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小张&quot;</span>, <span class="number">600</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the ret4=&quot;</span>+ret4); </span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">ret5</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小李&quot;</span>, <span class="number">1200</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;the ret5=&quot;</span>+ret5); </span><br><span class="line">        <span class="type">String</span> <span class="variable">ret6</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;小张&quot;</span>, <span class="number">1200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the ret6=&quot;</span>+ret6); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：<font color='red'>这种情况只针对于一种已经定义好的方法，可以创建通用的类来定义通用方法，然后根据传入的参数来动态的进行处理</font></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>声明处理者接口并描述请求处理方法的签名。</p><p>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</p></li><li><p>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。</p><p>该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。</p><p>为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。</p></li><li><p>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：</p><ul><li>是否自行处理这个请求。</li><li>是否将该请求沿着链进行传递。</li></ul></li><li><p>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</p></li><li><p>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</p></li><li><p>由于链的动态性， 客户端需要准备好处理以下情况：</p><ul><li>链中可能只有单个链接。</li><li>部分请求可能无法到达链尾。</li><li>其他请求可能直到链尾都未被处理。</li></ul></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><font color='red'>必须按照顺序来执行多个处理者的时候</font><p>无论按照何种顺序来组成责任链，所有的请求都会按照顺序通过链上的处理者</p></li><li><font color='red'>当程序需要使用不同的方式处理不同不同种类的请求，并且请求的类型和顺序未知的时候</font><p>请求会询问处理者能否处理，能处理才会处理，所有请求都有机会来处理</p></li><li><p>需要动态改变处理者执行顺序的时候</p></li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li><p>请求者和处理者松耦合</p><p>请求者只需要向责任链发布请求，处理者只处理自己负责的那一部分</p></li><li><p>可以控制请求处理的顺序</p></li><li><p>开闭原则。可以在不更改现有代码的情况下在程序中新增处理者</p></li></ul><h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li>责任链模式、命令模式、中介者模式和观察者模式都是用于处理请求发送者和接收者之间的不同连接方式：<ul><li>责任链，按照顺序将请求动态传递给一系列的潜在接收者</li><li>命令，发送者和请求者之间建立单向连接</li><li>中介者，放弃发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通</li><li>观察者，允许接收者动态地订阅或取消接受请求</li></ul></li><li>责任链和组合模式一起使用。一般情况下，叶组件接收到请求后，可以让请求沿着包含全体父组件的链一直传递至对象树的底部</li></ul><h3 id="开源框架的应用"><a href="#开源框架的应用" class="headerlink" title="开源框架的应用"></a>开源框架的应用</h3><ul><li>Spring Security 中的登录与认证的filter处理器链</li></ul><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>一种行为设计模式，在父类中定义好算法的框架，允许子类在不修改结构的情况下，重写算法的特定步骤。</p><font color='red'>主要就是将一些步骤延迟到子类中使用</font><h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230530103330735.png" alt="image-20230530103330735"></p><ol><li><strong>抽象类：</strong>声明算法步骤的方法，以及依次调用它们的实际模板方法。 方法可以是抽象方法，也可以有默认的实现</li><li><strong>具体类：</strong>可以重写所有的步骤，但是不能重写模板方法本身</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230530124444356.png" alt="image-20230530124444356"></p><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>将一个算法分解为多个步骤，看哪些步骤可以通用，那些步骤可以重写</li><li>创建一个抽象基类，然后定义一个模板方法和代表每个步骤的方法</li><li>需要给出部分步骤的默认实现，这样子类更简洁，更方便</li><li>为抽象基类创建子类，必须实现所有的抽象方法，并且可以重写部分步骤</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>需要控制子类的扩展情况</li><li>多个类的算法除了一些步骤不同以外，大部分的操作是相同的</li><li>需要固定算法的骨架</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>实现代码复用</li><li>实现开闭原则</li></ul><p><strong>缺点：</strong></p><ul><li>违反里氏替换原则</li><li>算法框架不容易升级，如果更改父类，所有的子类可能都需要重写方法</li></ul><h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li>工厂方法模式就是模板方法模式的一种特殊形式，模板方法模式可以通过工厂方法来获取需要调用的对象</li><li>模板方法基于继承机制，策略模式基于组合机制。模板方法模式是静态的，在类层次上的运作；策略模式是动态的，在对象层次的运作，允许在运行时切换行为</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></p><p><a href="https://www.jianshu.com/users/383970bef0a0/latest_articles">https://www.jianshu.com/users/383970bef0a0/latest_articles</a></p><p><a href="https://blog.csdn.net/kimichen123/article/">https://blog.csdn.net/kimichen123/article/</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/mingyry/a2c3ad19.html"/>
      <url>/mingyry/a2c3ad19.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p> <code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值</strong></p><blockquote><p>ThreadLocal原理</p></blockquote><p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/threadlocal-data-structure.png" alt="ThreadLocal 数据结构"></p><blockquote><p>ThreadLocal 内存泄露问题是怎么导致的？</p></blockquote><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。</p><p>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p>阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">    <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy(),</span><br><span class="line">            ThreadFactory threadFactory,        <span class="comment">// 线程工厂</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        <span class="comment">//执行Runnable</span></span><br><span class="line">        executor.execute(worker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ul><li><code>corePoolSize</code>: 核心线程数为 4。</li><li><code>maximumPoolSize</code> ：最大线程数 8</li><li><code>keepAliveTime</code> : 非核心线程的最大存活时间。</li><li><code>unit</code>: 存活时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>：拒绝策略为 <code>CallerRunsPolicy</code>。</li></ul><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h3><p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h3 id="线程池常见参数有哪些？"><a href="#线程池常见参数有哪些？" class="headerlink" title="线程池常见参数有哪些？"></a>线程池常见参数有哪些？</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421150646803.png" alt="image-20230421150646803"></p><h3 id="线程池的饱和策略有哪些？"><a href="#线程池的饱和策略有哪些？" class="headerlink" title="线程池的饱和策略有哪些？"></a>线程池的饱和策略有哪些？</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li><p>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（有界阻塞队列）：此队列按照先进先出的原则对元素进行排序。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p><p>在使用时需要定义队列的容量<code>new LinkedBlockingQueue(capacity)</code></p></li><li><p><code>SynchronousQueue</code>（同步队列） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</p><p>队列本身并不存储任何元素，非常适合于传递性场景, 比如在一个线程中使用的数据，传递给另外一个线程使用，<code>`SynchronousQueue</code> 的吞吐量高于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code>。</p></li></ul><ul><li><p><code>DelayedWorkQueue</code>（延迟无界阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p></li><li><p><code>ArrayBlockingQueue</code> 一个由<strong>数组</strong>实现的<strong>有界</strong>阻塞队列。该队列采用先进先出（FIFO）的原则对元素进行排序添加的。</p><p><code>ArrayBlockingQueue</code> 为<strong>有界且固定</strong>，其大小在构造时由构造函数来决定，确认之后就不能再改变了</p></li><li><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排列。也可以自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。</p></li></ul><h4 id="阻塞队列的对比"><a href="#阻塞队列的对比" class="headerlink" title="阻塞队列的对比"></a>阻塞队列的对比</h4><ul><li><h5 id="LinkedBlockingQueue-与-ArrayBlockingQueue-对比"><a href="#LinkedBlockingQueue-与-ArrayBlockingQueue-对比" class="headerlink" title="LinkedBlockingQueue 与 ArrayBlockingQueue 对比"></a><font color='red'>LinkedBlockingQueue 与 ArrayBlockingQueue 对比</font></h5><ul><li><font color='red'>ArrayBlockingQueue 入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</font></li><li><font color='red'>LinkedBlockingQueue 入队出队采用两把锁，入队出队互不干扰，效率较高；</font></li><li><font color='red'>二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；</font></li><li><font color='red'>LinkedBlockingQueue 如果初始化不传入初始容量，则使用最大 int 值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</font></li><li><font color='red'>ArrayBlockingQueue 在构造时需要指定容量大小；</font></li></ul></li></ul><h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421150928160.png" alt="image-20230421150928160"></p><ol><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p></li></ol><h3 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h3><ul><li><p>如果我们设置的线程池数量太小的话，如果<strong>同一时间有大量任务/请求需要处理</strong>，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至<strong>会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM</strong>。这样很明显是有问题的，CPU 根本没有得到充分利用。</p></li><li><p>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致<strong>大量的上下文切换，从而增加线程的执行时间</strong>，影响了整体执行效率。</p></li></ul><h4 id="CPU-密集任务还是-IO-密集任务"><a href="#CPU-密集任务还是-IO-密集任务" class="headerlink" title="CPU 密集任务还是 IO 密集任务"></a>CPU 密集任务还是 IO 密集任务</h4><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li><p><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。</p><p> IO 密集型就是进行网络读取，文件读取等任务</p><h3 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h3><p> <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/threadpoolexecutor-methods.png" alt="img"></p><p>上面并没有动态指定队列长度的方法，我们需要自定义长度的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><h3 id="几个常见的对比"><a href="#几个常见的对比" class="headerlink" title="几个常见的对比"></a>几个常见的对比</h3><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h4><ul><li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</li></ul><h4 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="内置线程池介绍"><a href="#内置线程池介绍" class="headerlink" title="内置线程池介绍"></a>内置线程池介绍</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 <code>nThreads</code>，这个 <code>nThreads</code> 参数是我们使用的时候自己传递的。</p><p><code>FixedThreadPool</code> 使用的是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列），队列永远不会被放满。</p><blockquote><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/FixedThreadPool.f8172448.png" alt="FixedThreadPool的execute()方法运行示意图" style="zoom:80%;" /></p><blockquote><p>为什么不推荐使用<code>FixedThreadPool</code>？</p></blockquote><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">         (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1，其他参数和 <code>FixedThreadPool</code> 相同。</p><blockquote><p><code>SingleThreadExecutor</code> 的运行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/SingleThreadExecutor.7ffd92c2.png" alt="SingleThreadExecutor的运行示意图"></p><blockquote><p>为什么不推荐使用<code>SingleThreadExecutor</code>？</p></blockquote><p><code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 一样，使用的都是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）作为线程池的工作队列。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点，就是可能会导致 OOM。</p><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><blockquote><p><code>CachedThreadPool</code> 的 <code>execute()</code> 方法的执行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/CachedThreadPool-execute.97103fbe.png" alt="CachedThreadPool的execute()方法的执行示意图" style="zoom:80%;" /></p><h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><p><code>ScheduledThreadPool</code> 用来在给定的延迟后运行任务或者定期执行任务。这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下即可。</p><p><code>ScheduledThreadPool</code> 是通过 <code>ScheduledThreadPoolExecutor</code> 创建的，使用的<code>DelayedWorkQueue</code>（延迟阻塞队列）作为线程池的任务队列。</p><p><code>ScheduledThreadPoolExecutor</code> 继承了 <code>ThreadPoolExecutor</code>，所以创建 <code>ScheduledThreadExecutor</code> 本质也是创建一个 <code>ThreadPoolExecutor</code> 线程池，只是传入的参数不相同。</p><h3 id="线程池的实战"><a href="#线程池的实战" class="headerlink" title="线程池的实战"></a>线程池的实战</h3><h4 id="1、正确声明线程池"><a href="#1、正确声明线程池" class="headerlink" title="1、正确声明线程池"></a>1、正确声明线程池</h4><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code> 类创建线程池，会有 OOM 风险。</strong></p><p><strong>使用有界队列，控制线程创建数量。</strong></p><p>避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ul><h4 id="2、监测线程池运行状态"><a href="#2、监测线程池运行状态" class="headerlink" title="2、监测线程池运行状态"></a>2、监测线程池运行状态</h4><p>可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。</p><h4 id="3、建议不同类别的业务用不同的线程池"><a href="#3、建议不同类别的业务用不同的线程池" class="headerlink" title="3、建议不同类别的业务用不同的线程池"></a>3、建议不同类别的业务用不同的线程池</h4><p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p><p>真实案例，本案例来源自：<a href="https://club.perfma.com/article/646639">《线程池运用不当的一次线上事故》</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/production-accident-threadpool-sharing-example.png" alt="案例代码概览" style="zoom:80%;" /></p><p>上面的代码可能会存在死锁的情况</p><p>假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>“死锁”</strong>。</p><h4 id="4、别忘记给线程池命名"><a href="#4、别忘记给线程池命名" class="headerlink" title="4、别忘记给线程池命名"></a>4、别忘记给线程池命名</h4><p>线程池里的线程命名通常有下面两种方式：</p><ul><li><strong>利用 guava 的 <code>ThreadFactoryBuilder</code></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure><ul><li><strong>自己实现 <code>ThreadFactor</code></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">          <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">       t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、正确配置线程池参数"><a href="#5、正确配置线程池参数" class="headerlink" title="5、正确配置线程池参数"></a>5、正确配置线程池参数</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p>主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池创建的参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                           <span class="type">long</span> keepAliveTime,  // 当线程池中空闲线程的数量超过corePoolSize时，多余的线程会在多长时间被销毁</span></span><br><span class="line"><span class="params">                           TimeUnit unit,</span></span><br><span class="line"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                           ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                           RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">     <span class="comment">// 省略...</span></span><br><span class="line"> &#125;</span><br><span class="line">execute()方法  实现Runnable</span><br><span class="line"><span class="title function_">submit</span><span class="params">()</span>方法  实现Callable</span><br></pre></td></tr></table></figure><h4 id="6、线程池使用的一些小坑"><a href="#6、线程池使用的一些小坑" class="headerlink" title="6、线程池使用的一些小坑"></a>6、线程池使用的一些小坑</h4><ul><li>线程池是可以复用的，一定不要频繁创建线程池比如一个用户请求到了就单独创建一个线程池。</li><li>使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。</li><li>线程池和 <code>ThreadLocal</code>共用，可能会导致线程从<code>ThreadLocal</code>获取到的是旧值/脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>核心思想是异步调用</p><p><code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><p><code>Future</code> 接口有 5 个方法：</p><ul><li><code>boolean cancel(boolean mayInterruptIfRunning)</code>：尝试取消执行任务。</li><li><code>boolean isCancelled()</code>：判断任务是否被取消。</li><li><code>boolean isDone()</code>：判断任务是否已经被执行完成。</li><li><code>get()</code>：等待任务执行完成并获取运算结果。</li><li><code>get(long timeout, TimeUnit unit)</code>：多了一个超时时间。</li></ul><p>FutureTask用来表示可获取结果的异步任务。FutureTask实现了Future接口，FutureTask提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。</p><p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>CompletableFuture</code> 同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。</p><p><code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p><p><code>CompletionStage</code> 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。</p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><h4 id="创建-CompletableFuture"><a href="#创建-CompletableFuture" class="headerlink" title="创建 CompletableFuture"></a>创建 CompletableFuture</h4><p>常见的创建 <code>CompletableFuture</code> 对象的方法如下：</p><ol><li><p>通过 new 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code>、<code>supplyAsync()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>;</span><br></pre></td></tr></table></figure><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</p><p><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;U&gt;</code> ，这也是一个函数式接口，<code>U</code> 是返回结果值的类型。</p></li></ol><h4 id="处理异步结算的结果"><a href="#处理异步结算的结果" class="headerlink" title="处理异步结算的结果"></a>处理异步结算的结果</h4><p>当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：</p><ul><li><p><code>thenApply()</code>：<code>thenApply()</code> 方法接受一个 <code>Function</code> 实例，用它来处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenApply()</code> 方法使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure></li></ul><p><strong>如果你不需要从回调函数中获取返回结果，可以使用 <code>thenAccept()</code> 或者 <code>thenRun()</code>。这两个方法的区别在于 <code>thenRun()</code> 不能访问异步计算的结果。</strong></p><ul><li><p><code>thenAccept()</code>：<code>thenAccept()</code> 方法的参数是 <code>Consumer&lt;? super T&gt;</code> 。它可以接收 1 个输入对象然后进行“消费”。</p></li><li><p><code>thenRun()</code>：<code>thenRun()</code> 的方法是的参数是 <code>Runnable</code> 。</p></li><li><p><code>whenComplete()</code>： <code>whenComplete()</code> 的方法的参数是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code></p><p>相对于 <code>Consumer</code> ， <code>BiConsumer</code> 可以接收 2 个输入对象然后进行“消费”。</p></li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>你可以通过 <code>handle()</code> 方法来处理任务执行过程中可能出现的抛出异常的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合-CompletableFuture"><a href="#组合-CompletableFuture" class="headerlink" title="组合 CompletableFuture"></a>组合 CompletableFuture</h4><p>可以使用 <code>thenCompose()</code> 按顺序链接两个 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span></span><br><span class="line"><span class="params">    Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenCompose()</code> 方法会使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><p>在实际开发中，这个方法还是非常有用的。比如说，我们先要获取用户信息然后再用用户信息去做其他事情。</p><p><code>thenCompose()</code> 方法类似的还有 <code>thenCombine()</code> 方法， <code>thenCombine()</code> 同样可以组合两个 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; <span class="string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;nice!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, completableFuture.get());</span><br></pre></td></tr></table></figure><p><strong>那 <code>thenCompose()</code> 和 <code>thenCombine()</code> 有什么区别呢？</strong></p><ul><li><code>thenCompose()</code> 可以链接两个 <code>CompletableFuture</code> 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li><li><code>thenCombine()</code> 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li></ul><h4 id="并行运行多个-CompletableFuture"><a href="#并行运行多个-CompletableFuture" class="headerlink" title="并行运行多个 CompletableFuture"></a>并行运行多个 CompletableFuture</h4><p>可以通过 <code>CompletableFuture</code> 的 <code>allOf()</code>这个静态方法来并行运行多个 <code>CompletableFuture</code> </p><p>我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。</p><p><strong><code>allOf()</code> 方法会等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</strong></p><p><strong><code>anyOf()</code> 方法不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</strong></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a> <a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型</title>
      <link href="/mingyry/6e088bfd.html"/>
      <url>/mingyry/6e088bfd.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-结构型"><a href="#设计模式-结构型" class="headerlink" title="设计模式-结构型"></a>设计模式-结构型</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>把一个类的接口变成客户端所期待的另一种接口，从而使原本接口不匹配而无法工作的两个类能够一起工作</p><p><strong>转换匹配，复用功能</strong></p><p>适配器分为两种：对象适配器和类适配器</p><h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>实现其中一个对象的接口，并对另一个对象进行封装</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230523084421298.png" alt="image-20230523084421298"></p><ol><li><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。</li><li><strong>客户端接口</strong> （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。</li><li><strong>服务</strong> （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</li><li><strong>适配器</strong> （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</li><li>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li></ol><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>使用继承机制：适配器同时继承两个对象的接口。仅在支持多重继承的编程语言中实现，例如c++。</p><p><strong>Java可以实现接口的同时继承类</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230523085606587.png" alt="image-20230523085606587"></p><ol><li><strong>类适配器</strong>不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建Target接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是源类Adapteee没有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2： 创建源类（Adaptee） ；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificRequest</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3： 创建适配器类（Adapter）（不适用继承而是委派）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;  </span><br><span class="line">    <span class="comment">// 直接关联被适配类  </span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span> <span class="params">(Adaptee adaptee)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能  </span></span><br><span class="line">        <span class="built_in">this</span>.adaptee.SpecificRequest();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//需要先创建一个被适配类的对象作为参数  </span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">mAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">Adaptee</span>())；</span><br><span class="line">        mAdapter.Request();</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>确保至少有两个类的接口不兼容：<ul><li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性<em>服务</em>类。</li><li>一个或多个将受益于使用服务类的<em>客户端</em>类。</li></ul></li><li>声明客户端接口， 描述客户端如何与服务交互。</li><li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li><li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li><li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li><li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>当某个类的接口和其他代码不兼容</p></li><li><p>复用多个组件时，对他们的父类进行适配器</p></li><li><p>复用一个类，想要向其添加额外的功能</p><p>一般使用类适配器来重定义部分行为</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p><ul><li>单一职责原则。</li><li>开闭原则，不修改现有代码</li></ul><p><strong>缺点</strong>：</p><ul><li>过多使用适配器，会导致系统非常凌乱，不容易进行整体的把控</li></ul><h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li>适配器模式对已有接口进行修改，装饰模式则是在不改变对象接口的前提下强化对象功能</li><li>适配器为封装对象提供不同的接口，代理为对象提供相同的接口，装饰为对象提供加强的接口</li><li>外观模式为现有对象定义了一个新接口，而适配器则会运用已有接口</li></ul><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="经典的SpringMVC之HandlerAdapter"><a href="#经典的SpringMVC之HandlerAdapter" class="headerlink" title="经典的SpringMVC之HandlerAdapter"></a>经典的SpringMVC之HandlerAdapter</h4><p>SpringMVC 内部是根据 <code>HandlerMapping</code> 将 <code>Request</code> 和 <code>Controller</code> 里面的方法对应起来的，为了方便理解，我这里把实现它的子类统称为<strong>映射处理器</strong>。</p><p>HandlerMapping 功能就是根据请求匹配到对应的 Handler，然后将找到的 Handler 和所有匹配的 HandlerInterceptor（拦截器）绑定到创建的 HandlerExecutionChain 对象上并返回。HandlerMapping 只是一个接口类，不同的实现类有不同的匹对方式，根据功能的不同我们需要在 SpringMVC 容器中注入不同的映射处理器 HandlerMapping。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6c55dc7b77d915c36517fe60c24c1937.png" alt="img"></p><p>HandlerAdapter 为一个接口，该接口内部定义了如下三个方法：</p><ul><li>supports(): 给出一个 handler,查看该 HandlerAdapter 是否支持该 handler。</li><li>handle(): 使用本 HandlerAdapter 代理执行这个 handler 中的方法。</li><li>getLastModified(): 查看该请求的 lastModified 值</li></ul><p><strong>不同请求方式和配置会得到不同的Adapter</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20210904235851738.png" alt="img"></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式，就是将一个类的抽象和它的实现区分开来，使得扩展变得更加容易</p><p>就是分离抽象部分和实现部分，然后来搭桥。但是只能抽象部分的对象去实现具体实现部分的对象</p><h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><p>当前系统有消息和消息的发送方式，消息分为普通消息和加急消息，发送方式有手机短消息和站内短消息，这种情况下，如果我们想要去扩展整个类的类型或者功能。</p><p>如果要是简单的只使用消息接口，发送方式利用继承，那样整个继承树就特别臃肿</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2062729-dc5f33faada8ad1a.png" alt="img" style="zoom:50%;" /></p><h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p>主要就是示例有两个维度的变化，可以通过桥接模式来实现</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/structure-zh-indexed.png" alt="桥接设计模式"></p><ol><li><strong>抽象部分</strong>：就是所实现的抽象的类</li><li><strong>实现部分</strong>：为实现抽象部分的所有具体的实现类的通用接口，</li><li><strong>具体实现</strong>：具体的实现的操作</li><li><strong>精确抽象</strong>：可以给抽象部分添加相应的功能</li><li><strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2062729-6234cd68508e8513.png" alt="img" style="zoom:67%;" /></p><p><strong>（1）实现部分定义的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 实现发送消息的统一接口 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageImplementor</span> &#123;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 发送消息 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> message 要发送的消息内容 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> toUser 消息发送的目的人员 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message,String toUser)</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>（2）抽象部分定义的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 抽象的消息对象 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractMessage</span> &#123;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 持有一个实现部分的对象 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">protected</span> MessageImplementor impl;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 构造方法，传入实现部分的对象  </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> impl 实现部分的对象 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">AbstractMessage</span><span class="params">(MessageImplementor impl)</span>&#123;  </span><br><span class="line">          <span class="built_in">this</span>.impl = impl;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 发送消息，转调实现部分的方法 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> message 要发送的消息内容 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> toUser 消息发送的目的人员 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message,String toUser)</span>&#123;  </span><br><span class="line">          <span class="built_in">this</span>.impl.send(message, toUser);  </span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）具体的实现发送消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 以站内短消息的方式发送消息 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">MessageSMS</span> <span class="keyword">implements</span> <span class="title class_">MessageImplementor</span>&#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> &#123;  </span><br><span class="line">          System.out.println(<span class="string">&quot;使用站内短消息的方式，发送消息&#x27;&quot;</span>+message+<span class="string">&quot;&#x27;给&quot;</span>+toUser);  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 以Email的方式发送消息 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageEmail</span> <span class="keyword">implements</span> <span class="title class_">MessageImplementor</span>&#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, String toUser)</span> &#123;  </span><br><span class="line">          System.out.println(<span class="string">&quot;使用Email的方式，发送消息&#x27;&quot;</span>+message+<span class="string">&quot;&#x27;给&quot;</span>+toUser);  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）扩展抽象的消息接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span>&#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">CommonMessage</span><span class="params">(MessageImplementor impl)</span> &#123;  </span><br><span class="line">          <span class="built_in">super</span>(impl);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> &#123;  </span><br><span class="line">          <span class="comment">//对于普通消息，什么都不干，直接调父类的方法，把消息发送出去就可以了  </span></span><br><span class="line">          <span class="built_in">super</span>.sendMessage(message, toUser);  </span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyMessage</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessage</span>&#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">UrgencyMessage</span><span class="params">(MessageImplementor impl)</span> &#123;  </span><br><span class="line">          <span class="built_in">super</span>(impl);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, String toUser)</span> &#123;  </span><br><span class="line">          message = <span class="string">&quot;加急：&quot;</span>+message;  </span><br><span class="line">          <span class="built_in">super</span>.sendMessage(message, toUser);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 扩展自己的新功能：监控某消息的处理过程 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> messageId 被监控的消息的编号 </span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 包含监控到的数据对象，这里示意一下，所以用了Object </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">watch</span><span class="params">(String messageId)</span> &#123;  </span><br><span class="line">          <span class="comment">//获取相应的数据，组织成监控的数据对象，然后返回         </span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">      &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）测试功能</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          <span class="comment">//创建具体的实现对象  </span></span><br><span class="line">          MessageImplementor impl = <span class="keyword">new</span> <span class="built_in">MessageSMS</span>();  </span><br><span class="line">          <span class="comment">//创建一个普通消息对象  </span></span><br><span class="line">          AbstractMessage m = <span class="keyword">new</span> <span class="built_in">CommonMessage</span>(impl);  </span><br><span class="line">          m.<span class="built_in">sendMessage</span>(<span class="string">&quot;请喝一杯茶&quot;</span>, <span class="string">&quot;小李&quot;</span>);         </span><br><span class="line">          <span class="comment">//创建一个紧急消息对象  </span></span><br><span class="line">          m = <span class="keyword">new</span> <span class="built_in">UrgencyMessage</span>(impl);  </span><br><span class="line">          m.<span class="built_in">sendMessage</span>(<span class="string">&quot;请喝一杯茶&quot;</span>, <span class="string">&quot;小李&quot;</span>);         </span><br><span class="line">         </span><br><span class="line">          <span class="comment">//把实现方式切换成邮件短消息，然后再实现一遍  </span></span><br><span class="line">          impl = <span class="keyword">new</span> <span class="built_in">MessageEmail</span>();  </span><br><span class="line">          m = <span class="keyword">new</span> <span class="built_in">CommonMessage</span>(impl);  </span><br><span class="line">          m.<span class="built_in">sendMessage</span>(<span class="string">&quot;请喝一杯茶&quot;</span>, <span class="string">&quot;小李&quot;</span>);  </span><br><span class="line">          m = <span class="keyword">new</span> <span class="built_in">UrgencyMessage</span>(impl);  </span><br><span class="line">          m.<span class="built_in">sendMessage</span>(<span class="string">&quot;请喝一杯茶&quot;</span>, <span class="string">&quot;小李&quot;</span>);  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>不希望抽象和实现部分采用固定的绑定关系</p></li><li><p>出现抽象部分和实现部分都是可扩展的</p></li><li><p>希望实现部分的修改不会影响正常的使用</p><p>客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分</p></li><li><p>采用继承的方法出现太多的子类</p><p>这时候就需要考虑是否可以分出两个维度来使用桥接的模式</p></li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>单一职责原则</li><li>开闭原则</li><li>减少子类个数</li><li>分离抽象和实现部分</li></ul><p><strong>缺点：</strong></p><ul><li>高内聚代码比较复杂</li></ul><h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li><strong>桥接模式</strong>和<strong>策略模式</strong>，结构相似，目的不同。<strong>桥接模式</strong>为了分离抽象部分和实现部分，使两部分可以独自变化；<strong>策略模式</strong>是封装一系列算法，使算法可以互相替换</li><li><strong>桥接模式</strong>和<strong>状态模式</strong>，状态模式目的是封装对应状态的行为，并且在内部状态改变时改变对象的行为</li></ul><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p><strong>应用程序使用JDBC驱动程序进行开发的方式</strong>。<strong>所谓驱动程序，指的是按照预先约定好的接口来操作计算机系统或者是外围设备的程序</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2062729-44747b2bcb42bd02.png" alt="img" style="zoom:67%;" /></p><blockquote><p><strong>基于JDBC的应用程序，使用JDBC的API，相当于是对数据库操作的抽象的扩展，算作桥接模式的抽象部分</strong>；而<strong>具体的接口实现是由驱动来完成的，驱动这边自然就相当于桥接模式的实现部分了</strong>。而<strong>桥接的方式，不再是让抽象部分持有实现部分，而是采用了类似于工厂的做法，通过DriverManager来把抽象部分和实现部分对接起来，从而实现抽象部分和实现部分解耦</strong>。</p></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式的目的就是让客户端不再区分操作的是组合对象还是叶子对象，而是使用一个统一的方式来操作</p><h3 id="问题的提出-1"><a href="#问题的提出-1" class="headerlink" title="问题的提出"></a>问题的提出</h3><p>输出一个用树状结构所表示的核心模型</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/problem-zh.png" alt="复杂订单的结构"></p><p>计算订单的总额，需要遍历所有的盒子和具体物品的价值，进行求和，这时候就可以使用组合模式</p><h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230602085705990.png" alt="image-20230602085705990"></p><ol><li><p><strong>组件</strong> （Component） 接口描述了树中叶子节点和容器所共有的操作</p></li><li><p><strong>叶子节点</strong> （Leaf） 是树的基本结构， 它不包含子项目</p><p>就是完成实际工作的节点，一般不再给任务推送到其他部分</p></li><li><p><strong>容器</strong> （Container）：包含叶子节点和其他容器的单位，任务到来之后会转发给子容器或者叶子节点来处理</p></li><li><p><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互</p></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><strong>组件对象的定义</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 抽象的组件对象，为组合中的对象声明接口，实现接口的缺省行为</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 示意方法，子组件对象可能有的功能方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 向组合对象中加入组件对象</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> child 被加入组合对象中的组件对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Component child)</span> &#123;</span><br><span class="line">         <span class="comment">// 缺省的实现，抛出例外，因为叶子对象没有这个功能，</span></span><br><span class="line">         <span class="comment">//或者子组件没有实现这个功能</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;对象不支持这个功能&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 从组合对象中移出某个组件对象</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> child 被移出的组件对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Component child)</span> &#123;</span><br><span class="line">         <span class="comment">// 缺省的实现，抛出例外，因为叶子对象没有这个功能，</span></span><br><span class="line">         <span class="comment">//或者子组件没有实现这个功能</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;对象不支持这个功能&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回某个索引对应的组件对象</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> index 需要获取的组件对象的索引，索引从0开始</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 索引对应的组件对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Component <span class="title function_">getChildren</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">         <span class="comment">// 缺省的实现，抛出例外，因为叶子对象没有这个功能，</span></span><br><span class="line">         <span class="comment">//或者子组件没有实现这个功能</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;对象不支持这个功能&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Composite对象的定义</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组合对象，通常需要存储子对象，定义有子部件的部件行为，</span></span><br><span class="line"><span class="comment">   * 并实现在Component里面定义的与子部件有关的操作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 用来存储组合对象中包含的子组件对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> List&lt;Component&gt; childComponents = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 示意方法，通常在里面需要实现递归的调用</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> &#123;     </span><br><span class="line">         <span class="keyword">if</span> (childComponents != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span>(Component c : childComponents)&#123;</span><br><span class="line">                <span class="comment">//递归的进行子组件相应方法的调用</span></span><br><span class="line">                c.someOperation();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Component child)</span> &#123;</span><br><span class="line">         <span class="comment">//延迟初始化</span></span><br><span class="line">         <span class="keyword">if</span> (childComponents == <span class="literal">null</span>) &#123;</span><br><span class="line">             childComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line">         &#125;</span><br><span class="line">         childComponents.add(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Component child)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (childComponents != <span class="literal">null</span>) &#123;</span><br><span class="line">             childComponents.remove(child);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> Component <span class="title function_">getChildren</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (childComponents != <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;childComponents.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> childComponents.get(index);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>叶子对象的定义</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 叶子对象，叶子对象不再包含其它子对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> extends Component &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 示意方法，叶子对象可能有自己的功能方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">someOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// do something</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>Client，就是使用Component接口来操作组合对象结构</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//定义多个Composite对象</span></span><br><span class="line">         <span class="type">Component</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>();</span><br><span class="line">         <span class="type">Component</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>();</span><br><span class="line">         <span class="type">Component</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>();</span><br><span class="line">         <span class="comment">//定义多个叶子对象</span></span><br><span class="line">         <span class="type">Component</span> <span class="variable">leaf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">         <span class="type">Component</span> <span class="variable">leaf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">         <span class="type">Component</span> <span class="variable">leaf3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">     </span><br><span class="line">         <span class="comment">//组合成为树形的对象结构</span></span><br><span class="line">         root.addChild(c1);</span><br><span class="line">         root.addChild(c2);</span><br><span class="line">         root.addChild(leaf1);</span><br><span class="line">         c1.addChild(leaf2);</span><br><span class="line">         c2.addChild(leaf3);</span><br><span class="line">     </span><br><span class="line">         <span class="comment">//操作Component对象</span></span><br><span class="line">         <span class="type">Component</span> <span class="variable">o</span> <span class="operator">=</span> root.getChildren(<span class="number">1</span>);</span><br><span class="line">         System.out.println(o);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>应用的核心模型可以用树状结构来表示。并且将结构分为两种简单元素和容器</li><li>定义一个抽象类，是简单元素和容器的父类，并且定义所实现抽象的公共方法，和其他对容器与简单元素都有意义的方法</li><li>叶子节点表示简单元素，一般负责完成任务，任务不再分配给其他部分</li><li>容器，定义增加和删除容器的内部元素的方法，也具有完成任务的方法，或者自身参与或者交给子容器和叶子节点来完成任务</li><li><strong>记住</strong>， 这些操作可在组件接口中声明。 这将会违反<em>接口隔离原则</em>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</li></ol><p><strong>安全性是指：从客户使用组合模式上看是否更安全。</strong>如果是安全的，那么不会有发生误操作的可能，能访问的方法都是被支持的功能。</p><p><strong>透明性是指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象。</strong>如果是透明的，那就是不再区分，对于客户而言，都是组件对象，具体的类型对于客户而言是透明的，是客户无需要关心的。</p><p>组合模式的透明性实现，通常的方式是：<strong>在Component中声明管理子组件的操作，并在Component中为这些方法提供缺省的实现，如果是有子对象不支持的功能，缺省的实现可以是抛出一个例外，来表示不支持这个功能。</strong></p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>你需要实现树状对象结构，可以使用组合模式</strong></li><li><strong>统一的使用组合结构中的所有对象</strong></li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><em>开闭原则</em>。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</li><li>简化了客户端调用</li><li>统一了组合对象和叶子对象</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></p><p><a href="https://www.jianshu.com/nb/4583287">https://www.jianshu.com/nb/4583287</a></p><p><a href="https://www.jianshu.com/users/383970bef0a0/latest_articles">https://www.jianshu.com/users/383970bef0a0/latest_articles</a></p><p><a href="https://blog.csdn.net/kimichen123/article/">https://blog.csdn.net/kimichen123/article/</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型</title>
      <link href="/mingyry/e712e4ca.html"/>
      <url>/mingyry/e712e4ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-创建型模式"><a href="#设计模式-创建型模式" class="headerlink" title="设计模式-创建型模式"></a>设计模式-创建型模式</h1><h2 id="7个原则"><a href="#7个原则" class="headerlink" title="7个原则"></a>7个原则</h2><p>单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】: 一个类负责一项职责。</p><p>里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 子类能够替换掉它们的父类型。</p><p>依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。</p><p>接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。使用多个专门功能的接口，而不是使用单一的总接口。</p><p>迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。</p><p>开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="类的表示"><a href="#类的表示" class="headerlink" title="类的表示"></a>类的表示</h3><p><strong>具体类</strong></p><p>具体类用矩形框表示，第一层是类名，第二次是成员变量，第三层是类所包含的方法。成员变量和方法前的访问修饰符用符号来表示</p><ul><li>+：表示public  所有类可见</li><li>-：表示private  同一类内可见  不能修饰类</li><li><h1 id="：表示protected-同一包内和所有子类可见-不能修饰类"><a href="#：表示protected-同一包内和所有子类可见-不能修饰类" class="headerlink" title="：表示protected  同一包内和所有子类可见  不能修饰类"></a>：表示protected  同一包内和所有子类可见  不能修饰类</h1></li><li>不带符号，默认default  同一包内可见</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-71b22158f5b09dffa57a123d72ec4653_720w.webp" alt="img"></p><p>一般方法后面跟着的是返回值类型或者返回值的名字</p><p><strong>抽象类</strong></p><p>同样用矩形框表示，也是三层的模式，与具体类的区别是，抽象的类和方法需要变为斜体</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-5c69cd9ff703377f7bbf37cee8199451_720w.webp" alt="img"></p><p><strong>接口</strong></p><p>矩形框表示，一共两层，第一层用接口的标识&lt;<interface>&gt;，下面是接口的名字；第二层是方法名和类型</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-e39bdff5514c38e7797848372ac51365_720w.webp" alt="img"></p><p><strong>包</strong></p><p>一个矩形框的表示</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-b421c9c15219feba7dd9cf7681070682_720w.webp" alt="img"></p><h3 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h3><p><strong>1）实现关系</strong></p><p>接口与其实现类之间的关系（<code>implements</code>）。实现关系用：空心三角加上虚线来表示</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-616c153ec74d496a811ac50c83c3653c_720w.webp" alt="img"></p><p><strong>2）泛化关系</strong></p><p>对象和对象之间的继承关系（<code>extends</code>）。泛化关系用：空心三角加上实线来表示</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-04064db11797cf36229d67407fea1b83_720w.webp" alt="img"></p><p><strong>3）关联关系</strong></p><p>一个类中包含另一个类的引用作为成员变量。关联关系用：实心箭头加上实线来表示，箭头指向的是包含的对象</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-3f331f3dc075abb4215413014688638f_720w.webp" alt="img"></p><p><strong>4）依赖关系</strong></p><p>弱关联关系，一个类利用另一个类作为<strong>该类的构造器或方法，中的局部变量、方法、或构造器的参数、方法的返回值，或者调用该类的静态方法</strong>。依赖关系用：实心箭头加上虚线来表示，箭头指向的是作为方法参数的类</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-431e044bbf26778a20dd788968e22aac_720w.webp" alt="img"></p><p><strong>5）聚合关系</strong></p><p>就是整体和部分的拥有关系，即“has a”，整体和部分是可以分离的，各自有各自的生命周期。一个部门多个员工，或者一个员工属于多个部门，员工和部门之间没有必要关系，员工可以离开部门，部门也可以清除员工。聚合关系用：空心菱形加上实线箭头表示，菱形所在的一方是整体，箭头所在的一方是部分</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-82cb160ed1566d1d04ea320575b54d5f_720w.webp" alt="img"></p><p><strong>6）组合关系</strong></p><p>整体和部分的包含关系，即“contains a”，整体和部分不可分离，部分不能共享，并且整体的生命周期关系着部分的生命周期。整体可以控制部分的生命周期。组合关系用：实心菱形加上实线箭头表示，实心菱形所在的一方是整体，实线箭头所在的一方是部分。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>工厂方法模式</strong>是一种创建型设计模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p><p><strong>工厂方法模式的本质：延迟到子类来选择实现</strong></p><p>工厂方法定义了一个方法，且必须使用该方法代替通过直接调用构造函数来创建对象（ <code>new</code>操作符）的方式。子类可重写该方法来更改将被创建的对象所属类。</p><p><strong>识别方法：</strong>工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。</p><h3 id="工厂方法模式结构"><a href="#工厂方法模式结构" class="headerlink" title="工厂方法模式结构"></a>工厂方法模式结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230515171449040.png" alt="image-20230515171449040"></p><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p><p>注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p><p>注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p></li></ol><h3 id="工厂方法伪代码"><a href="#工厂方法伪代码" class="headerlink" title="工厂方法伪代码"></a>工厂方法伪代码</h3><p>以下示例演示了如何使用<strong>工厂方法</strong>开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230515171613468.png" alt="image-20230515171613468"></p><p>基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。</p><p>如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。</p><p>如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。</p><p>你可以使用此方法开发其他 UI 组件。 不过，每向对话框中添加一个新的工厂方法， 你就离<strong>抽象工厂</strong>模式更近一步。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供</span></span><br><span class="line"><span class="comment">// 该方法的实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">abstract</span> Dialog is</span><br><span class="line">    <span class="comment">// 创建者还可提供一些工厂方法的默认实现。</span></span><br><span class="line">    <span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务</span></span><br><span class="line">    <span class="comment">// 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span></span><br><span class="line">    <span class="comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span></span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 调用工厂方法创建一个产品对象。</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">        <span class="comment">// 现在使用产品。</span></span><br><span class="line">        okButton.onClick(closeDialog)</span><br><span class="line">        okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品需提供产品接口的各种实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// 根据 Windows 样式渲染按钮。</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// 绑定本地操作系统点击事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">        <span class="comment">// 返回一个按钮的 HTML 表述。</span></span><br><span class="line">    method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">        <span class="comment">// 绑定网络浏览器的点击事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    field dialog: Dialog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序根据当前配置或环境设定选择创建者的类型。</span></span><br><span class="line">    method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;错误！未知的操作系统。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口进行。</span></span><br><span class="line">    <span class="comment">// 只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子类传递给客户端。</span></span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.initialize()</span><br><span class="line">        dialog.render()</span><br></pre></td></tr></table></figure><h3 id="工厂方法实现方式"><a href="#工厂方法实现方式" class="headerlink" title="工厂方法实现方式"></a>工厂方法实现方式</h3><ol><li><p>让<strong>所有产品都遵循同一接口</strong>。该接口必须声明对所有产品都有意义的方法。</p></li><li><p>在创建类中添加一个<strong>空的工厂方法</strong>。该方法的<strong>返回类型必须遵循通用的产品接口</strong>。</p></li><li><p>在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。</p><p>你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p><p>工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 <code>switch</code>分支运算符， 用于选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。</p></li><li><p>现在，为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。</p></li><li><p>如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。</p><p>例如，设想你有以下一些层次结构的类。基类 <code>邮件</code>及其子类 <code>航空邮件</code>和 <code>陆路邮件</code> ；  <code>运输</code>及其子类 <code>飞机</code>, <code>卡车</code>和 <code>火车</code> 。 <code>航空邮件</code>仅使用 <code>飞机</code>对象， 而 <code>陆路邮件</code>则会同时使用 <code>卡车</code>和 <code>火车</code>对象。你可以编写一个新的子类 （例如 <code>火车邮件</code> ） 来处理这两种情况，但是还有其他可选的方案。客户端代码可以给 <code>陆路邮件</code>类传递一个参数， 用于控制其希望获得的产品。</p></li><li><p>如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。</p></li></ol><h3 id="Java工厂方法模式代码示例"><a href="#Java工厂方法模式代码示例" class="headerlink" title="Java工厂方法模式代码示例"></a>Java工厂方法模式代码示例</h3><h4 id="生成跨平台的-GUI-元素"><a href="#生成跨平台的-GUI-元素" class="headerlink" title="生成跨平台的 GUI 元素"></a><strong>生成跨平台的 GUI 元素</strong></h4><p>在本例中，按钮担任产品的角色， 对话框担任创建者的角色。</p><p>不同类型的对话框需要其各自类型的元素。 因此我们可为每个对话框类型创建子类并重写其工厂方法。</p><p>现在， 每种对话框类型都将对合适的按钮类进行初始化。 对话框基类使用其通用接口与对象进行交互， 因此代码更改后仍能正常工作。</p><p>具体实现参考： <a href="https://refactoringguru.cn/design-patterns/factory-method/java/example">https://refactoringguru.cn/design-patterns/factory-method/java/example</a></p><h3 id="工厂方法模式适合应用场景"><a href="#工厂方法模式适合应用场景" class="headerlink" title="工厂方法模式适合应用场景"></a>工厂方法模式适合应用场景</h3><ul><li>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</li></ul><blockquote><p>工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。</p><p>例如， 如果需要向应用中添加一种新产品， 你只需要开发新的<strong>创建者子类</strong>， 然后<strong>重写其工厂方法</strong>即可。</p></blockquote><ul><li>如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。</li></ul><blockquote><p>继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时，框架如何辨识出该子类？</p><p>解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。</p><p>让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 <code>圆形按钮</code>Round­Button子类来继承标准的 <code>按钮</code>Button类。 但是， 你需要告诉 <code>UI框架</code>UIFramework类使用新的子类按钮代替默认按钮。</p><p>为了实现这个功能， 你可以根据基础框架类开发子类 <code>圆形按钮 UI</code>UIWith­Round­Buttons ， 并且重写其 <code>create­Button</code>创建按钮方法。 基类中的该方法返回 <code>按钮</code>对象， 而你开发的子类返回 <code>圆形按钮</code>对象。 现在， 你就可以使用 <code>圆形按钮 UI</code>类代替 <code>UI框架</code>类。 就是这么简单！</p></blockquote><ul><li>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</li></ul><blockquote><p>在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。</p><p>让我们思考复用现有对象的方法：</p><ol><li>首先， 你需要创建存储空间来存放所有已经创建的对象。</li><li>当他人请求一个对象时， 程序将在对象池中搜索可用对象。</li><li>… 然后将其返回给客户端代码。</li><li>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。</li></ol><p>这些代码可不少！而且它们必须位于同一处，这样才能确保重复代码不会污染程序。</p><p>可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是<strong>新对象</strong>， 其无法返回现有实例。</p><p>因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。</p></blockquote><ul><li>当一个类不知道它所需要的对象的类时</li></ul><blockquote><p>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</p></blockquote><ul><li>当一个类希望通过其子类来指定创建对象时</li></ul><blockquote><p>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></blockquote><ul><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h3 id="工厂方法模式优缺点"><a href="#工厂方法模式优缺点" class="headerlink" title="工厂方法模式优缺点"></a>工厂方法模式优缺点</h3><p><strong>优点：</strong></p><ul><li>可以避免创建者和具体产品之间的紧密耦合。</li><li><em>单一职责原则</em>。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li><li><em>开闭原则</em>。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li><li><em>依赖倒置原则</em>。不能让高层组件依赖于低层组件，而且不管高层组件还是低层组件，都应该依赖于抽象。</li></ul><p><strong>缺点：</strong></p><ul><li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有</li></ul><h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li>在许多设计工作的初期都会使用<strong>工厂方法模式</strong> （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用<strong>抽象工厂模式</strong>、 <strong>原型模式</strong>或<strong>生成器模式</strong> （更灵活但更加复杂）。</li><li>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</li><li>你可以同时使用<strong>工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配</strong>。</li><li>原型并不基于继承， 因此没有继承的缺点。 另一方面， <em>原型</em>需要对被复制对象进行复杂的初始化。 <strong>工厂方法基于继承， 但是它不需要初始化步骤</strong>。</li><li>工厂方法是<strong>模板方法模式</strong>的一种特殊形式。 同时， <em>工厂方法</em>可以作为一个大型<em>模板方法</em>中的一个步骤。</li></ul><h3 id="开源架构中的使用"><a href="#开源架构中的使用" class="headerlink" title="开源架构中的使用"></a>开源架构中的使用</h3><h4 id="jdbc的工厂模式"><a href="#jdbc的工厂模式" class="headerlink" title="jdbc的工厂模式"></a>jdbc的工厂模式</h4><p>获取数据库连接的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection conn=DriverManager.getConnection(<span class="string">&quot;jdbc:microsoft:sqlserver://localhost:8080; DatabaseName=DB;user=user;password=&quot;</span><span class="number">123</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">Statement statement=conn.createStatement();</span></span><br><span class="line"><span class="string">ResultSet rs=statement.executeQuery(&quot;</span>select * from UserInfo<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="Elasticsearch中QueryBuilder工厂模式"><a href="#Elasticsearch中QueryBuilder工厂模式" class="headerlink" title="Elasticsearch中QueryBuilder工厂模式"></a>Elasticsearch中QueryBuilder工厂模式</h4><p>Es定义了一个QueryBuilders工厂类，返回不同的Builder</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p><blockquote><p>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类</p><p>解决：每个工厂只能创建一类产品</p></blockquote><p>允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。</p><blockquote><p>如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。</p></blockquote><h3 id="抽象工厂模式结构"><a href="#抽象工厂模式结构" class="headerlink" title="抽象工厂模式结构"></a>抽象工厂模式结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230530093528066.png" alt="image-20230530093528066"></p><ol><li><strong>抽象产品</strong>（Abstract Product）为构成系列产品的一组不同但相关的产品声明接口。</li><li><strong>具体产品</strong>（Concrete Product) 是抽象产品的多种不同类型实现。所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</li><li><strong>抽象工厂</strong>（Abstract Factory）接口声明了一组创建各种抽象产品的方法。</li><li><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。 这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/example.png" alt="抽象工厂模式示例的类图"></p><p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外，你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。</p><p>抽象工厂接口声明一系列构建方法，客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统，并负责生成符合该操作系统风格的 UI 元素。</p><p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。</p><p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。</p><p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span></span><br><span class="line"><span class="comment">// 品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span></span><br><span class="line"><span class="comment">// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span></span><br><span class="line"><span class="comment">// 行实例化。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">    method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">    method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品由相应的具体工厂创建。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 根据 Windows 样式渲染按钮。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 根据 macOS 样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span></span><br><span class="line"><span class="comment">// 品之间才能够正确地进行交互。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 根据 Windows 样式渲染复选框。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 根据 macOS 样式渲染复选框。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂和产品</span></span><br><span class="line"><span class="comment">// 这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">    <span class="keyword">private</span> field button: Button</span><br><span class="line">    <span class="keyword">private</span> field checkbox: Checkbox</span><br><span class="line">    constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">        <span class="built_in">this</span>.factory = factory</span><br><span class="line">    method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">        <span class="built_in">this</span>.check = factory.createCheckbox()</span><br><span class="line">    method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">        button.paint()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span></span><br><span class="line"><span class="comment">// 始化阶段）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">            <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;错误！未知的操作系统。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>以不同的产品类型与产品变体为维度绘制矩阵。</li><li>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</li><li>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</li><li>为每种产品变体实现一个具体工厂类。</li><li>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</li><li>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</li></ol><h3 id="Java抽象工厂模式代码示例"><a href="#Java抽象工厂模式代码示例" class="headerlink" title="Java抽象工厂模式代码示例"></a>Java抽象工厂模式代码示例</h3><h4 id="跨平台-GUI-组件系列及其创建方式"><a href="#跨平台-GUI-组件系列及其创建方式" class="headerlink" title="跨平台 GUI 组件系列及其创建方式"></a>跨平台 GUI 组件系列及其创建方式</h4><p>在本例中， 按钮和复选框将被作为产品。 它们有两个变体： macOS 版和 Windows 版。</p><p>抽象工厂定义了用于创建按钮和复选框的接口。 而两个具体工厂都会返回同一变体的两个产品。</p><p>客户端代码使用抽象接口与工厂和产品进行交互。 同样的代码能与依赖于不同工厂对象类型的多种产品变体进行交互。</p><p>具体实现：<a href="https://refactoringguru.cn/design-patterns/abstract-factory/java/example">https://refactoringguru.cn/design-patterns/abstract-factory/java/example</a></p><h3 id="抽象工厂模式适合应用场景"><a href="#抽象工厂模式适合应用场景" class="headerlink" title="抽象工厂模式适合应用场景"></a>抽象工厂模式适合应用场景</h3><ul><li>如果<strong>代码需要与多个不同系列的相关产品交互</strong>， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</li></ul><blockquote><p>抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。</p></blockquote><ul><li>如果你有一个基于一组<strong>抽象方法</strong>的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。</li></ul><blockquote><p>在设计良好的程序中， <em>每个类仅负责一件事</em>。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</p></blockquote><ul><li><p>一个系统不要求依赖产品类实例如何被创建、组合和表达，这点也是所有工厂模式应用的前提。</p></li><li><p>这个系统有多个系列产品，而系统中只消费其中某一系列产品</p></li><li><p>系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现</p></li></ul><h3 id="抽象工厂模式优缺点"><a href="#抽象工厂模式优缺点" class="headerlink" title="抽象工厂模式优缺点"></a>抽象工厂模式优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>你可以确保同一工厂生成的产品相互匹配。</li><li>你可以避免客户端和具体产品代码的耦合。</li><li><em>单一职责原则</em>。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li><li><em>开闭原则</em>。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</li></ul><h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li>在许多设计工作的<strong>初期都会使用工厂方法模式</strong> （较为简单， 而且可以更方便地通过子类进行定制）， 随后<strong>演化为使用抽象工厂模式、 原型模式或生成器模式</strong> （更灵活但更加复杂）。</li><li>生成器重点关注如何<strong>分步生成复杂对象</strong>。 抽象工厂<strong>专门用于生产一系列相关对象</strong>。 <em>抽象工厂</em>会马上返回产品， <em>生成器</em>则允许你在获取产品前执行一些额外构造步骤。</li><li>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</li><li><strong>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。</strong></li><li>你可以将<strong>抽象工厂和桥接模式</strong>搭配使用。 如果由<em>桥接</em>定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下，抽象工厂*可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li><li>抽象工厂、生成器和原型都可以用单例模式来实现。</li></ul><h3 id="开源框架经典案例"><a href="#开源框架经典案例" class="headerlink" title="开源框架经典案例"></a>开源框架经典案例</h3><h4 id="JDBC抽象工厂实现"><a href="#JDBC抽象工厂实现" class="headerlink" title="JDBC抽象工厂实现"></a>JDBC抽象工厂实现</h4><p>java.sql.Connection这个接口，经常使用jdbc的程序员应该都知道这个接口和他下面的几个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">//提供一个执行对象</span></span><br><span class="line">    Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//提供一个支持预编译的执行对象</span></span><br><span class="line">    PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">    <span class="comment">//提供一个支持存储过程的执行对象</span></span><br><span class="line">    CallableStatement <span class="title function_">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看的出来Connection就是一个经典的抽象工厂，Statement, PreparedStatement, CallableStatement是这个抽象工厂提供的三个抽象产品，其中Driver起到Client的作用我们只需要把Driver注册DriverManager就可以为我们生成需要的Connection每次操作数据库只需要使用Java提供的这套接口就可以而不需要考虑我们使用的是什么SQL数据库。</p><h4 id="Spring类的抽象工厂"><a href="#Spring类的抽象工厂" class="headerlink" title="Spring类的抽象工厂"></a>Spring类的抽象工厂</h4><p>Spring的抽象工厂，这里的经典例子是循环依赖的例子，那就是spring其实比较典型的是AbstractBeanFactory, 因为在Spring容器中，对于单例来说，有且只有一个，如果涉及到循环依赖，那怎么解决的？答案就是三级缓存。那三级缓存里面的三个缓存其实就是工厂产品，用来存放各个阶段创建的bean，保证spring容器正确启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">singletonFactories ： 单例对象工厂的cache</span><br><span class="line">earlySingletonObjects ：提前曝光的单例对象的Cache</span><br><span class="line">singletonObjects：单例对象的cache</span><br></pre></td></tr></table></figure><h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><p>生成器模式，能够分步骤的创建复杂的对象。同时也允许使用相同的创建代码来创建不同类型和形式的对象</p><p>隐藏对象的建造过程和细节，用户在不知道对象的具体建造细节的情况下就可以创建复杂度的对象</p><p>本质：<strong>分离整体构建算法和部件构造。</strong></p><blockquote><p>例子：买汽车</p><ol><li><p>工厂（建造者）：负责制造汽车</p></li><li><p>汽车购买者（用户）：不需要知道具体的实现细节，只需要告知需要的类型和内存，就直接获得汽车</p></li></ol></blockquote><h3 id="生成器模式UML图"><a href="#生成器模式UML图" class="headerlink" title="生成器模式UML图"></a>生成器模式UML图</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230515164146266.png" alt="image-20230515164146266"></p><ol><li><p><strong>生成器</strong> （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</p></li><li><p><strong>具体生成器</strong> （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</p><p>可以增加构建的步骤，都是靠具体生成器来控制。</p></li><li><p><strong>产品</strong> （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</p><p>产品之间是无关联的</p></li><li><p><strong>主管</strong> （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用<strong>特定</strong>的产品配置。</p><p>里面有规定好的步骤和参数来利用生成器创建指定型号的产品</p></li><li><p><strong>客户端</strong> （Client） 必须将某个生成器对象与主管类关联。 </p><p>一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 </p><p>但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器。</p><blockquote><p>一般情况是：</p><p>new 主管类(具体生成器)，然后利用主管类的construct(参数)来构建具体生成器的参数，然后用具体生成器来返回产品</p><p>第二种情况：</p><p>new 主管类()，利用方法changeBuilder1(具体生成器1)，来给具体生成器1设置参数，然后返回产品1。</p><p>这个的好处是，可以再次传入不同的生成器来返回不同的产品</p><p>方法changeBuilder2(具体生成器2)，来给具体生成器2设置参数，然后返回产品2。</p></blockquote></li></ol><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （Car）——及其相应的使用手册 （Manual）。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/example-zh.png" alt="生成器模式结构示例"></p><p>汽车是一个复杂的对象，有很多的种类，因此，可以利用生成器模式，将汽车生成的公共部分提取到单独的生成器类中，根据具体的汽车生成器来构建具体的汽车类型。</p><p>此外需要根据汽车类型来配套汽车使用手册，也是同样的建造模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。</span></span><br><span class="line"><span class="comment">// 下面的两个产品尽管没有同样的接口，但却相互关联。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line">    <span class="comment">// 根据不同型号的汽车（运动型轿车、SUV 和敞篷车）</span></span><br><span class="line">    <span class="comment">// 来设置不同的功能的启用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">    <span class="comment">// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成器接口声明了创建产品对象不同部件的方法。</span></span><br><span class="line"><span class="comment">// 里面一般都是汽车生产的公共方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(……)</span></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(……)</span></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(……)</span></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(……)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。</span></span><br><span class="line"><span class="comment">// 你的程序中可能会有多个以不同方式实现的生成器变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field car:Car</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个新的生成器实例必须包含一个在后续组装过程中使用的空产品对象。</span></span><br><span class="line">    constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset（重置）方法可清除正在生成的对象。</span></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有生成步骤都会与同一个产品实例进行交互。</span></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 设置汽车座位的数量。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 安装指定的引擎。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 安装行车电脑。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 安装全球定位系统。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能</span></span><br><span class="line">    <span class="comment">// 会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中</span></span><br><span class="line">    <span class="comment">// 声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的</span></span><br><span class="line">    <span class="comment">// 准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾</span></span><br><span class="line">    <span class="comment">// 调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确</span></span><br><span class="line">    <span class="comment">// 调用重置方法后再去处理之前的结果。</span></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">        <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span></span><br><span class="line"><span class="comment">// 汽车和汽车手册不是相同接口的产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">    <span class="keyword">private</span> field manual:Manual</span><br><span class="line"></span><br><span class="line">    constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.reset()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">        <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setSeats</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 添加关于汽车座椅功能的文档。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setEngine</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 添加关于引擎的介绍。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setTripComputer</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 添加关于行车电脑的介绍。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">setGPS</span><span class="params">(……)</span> is</span><br><span class="line">        <span class="comment">// 添加关于 GPS 的介绍。</span></span><br><span class="line"></span><br><span class="line">    method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">        <span class="comment">// 返回使用手册并重置生成器。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时会很有帮助。</span></span><br><span class="line"><span class="comment">// 由于客户端可以直接控制生成器，所以严格意义上来说，主管类并不是必需的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">    <span class="comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span></span><br><span class="line">    <span class="comment">// 过这种方式改变最新组装完毕的产品的最终类型。主管可使用同样的生成步</span></span><br><span class="line">    <span class="comment">// 骤创建多个产品变体。</span></span><br><span class="line">    method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        builder.reset()</span><br><span class="line">        builder.setSeats(<span class="number">2</span>)</span><br><span class="line">        builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">        builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">        builder.setGPS(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果</span></span><br><span class="line"><span class="comment">// 将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"></span><br><span class="line">    method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">        <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line"></span><br><span class="line">        <span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">        director.constructSportsCar(builder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和</span></span><br><span class="line">        <span class="comment">// 产品的存在，也不会对其产生依赖。</span></span><br><span class="line">        <span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p><a href="https://refactoringguru.cn/design-patterns/builder/java/example">https://refactoringguru.cn/design-patterns/builder/java/example</a></p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol><li><p>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。</p></li><li><p>在基本生成器接口中声明这些步骤。</p></li><li><p>为每个形式的产品创建具体生成器类， 并实现其构造步骤。</p><p>不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。</p></li><li><p>考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式。</p></li><li><p>客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。</p></li><li><p>只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>需要生产的产品对象有复杂的内部结构，这些产品对象的制造过程相似</p></li><li><p>避免“重叠构造函数(telescoping constructor)” 的出现</p><p>生成器模式让你可以分步骤生成对象</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><font color='red'>单一职责原则</font>。可以将复杂构造代码从产品的业务逻辑中分离出来</li><li>增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。</li><li>生成不同形式的产品时， 你可以复用相同的制造代码。</li></ul><p><strong>缺点：</strong></p><ul><li>代码整体复杂程度增加</li><li>如果产品差异性较大，则不适合使用生成器模式</li></ul><h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul><li><font color='red'>生成器模式</font>关注分布生成复杂对象，<font color='red'>抽象工厂</font>专门用于生产一系列相关对象</li><li>复杂的组合模式可以利用生成器模式来构建</li><li>抽象工厂、生成器和原型度可以用单利模式来实现</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></p><p><a href="https://www.jianshu.com/users/383970bef0a0/latest_articles">https://www.jianshu.com/users/383970bef0a0/latest_articles</a></p><p><a href="https://blog.csdn.net/kimichen123/article/">https://blog.csdn.net/kimichen123/article/</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发控制</title>
      <link href="/mingyry/a860421b.html"/>
      <url>/mingyry/a860421b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java并发控制"><a href="#Java并发控制" class="headerlink" title="Java并发控制"></a>Java并发控制</h2><h3 id="Volatile-关键词"><a href="#Volatile-关键词" class="headerlink" title="Volatile 关键词"></a>Volatile 关键词</h3><p>两个作用：</p><ol><li>保证变量的可见性：当我们将变量声明为<code>volatile</code>，这个变量是不稳定的，每次使用需要到主内存中进行读取</li><li>禁止指令重排序：当我们将变量声明为<code>volatile</code>，在对这个变量进行读写操作时，会通过插入特定的内存屏障来禁止指令重排序</li></ol><h4 id="利用双重校验锁来实现单例模式"><a href="#利用双重校验锁来实现单例模式" class="headerlink" title="利用双重校验锁来实现单例模式"></a>利用双重校验锁来实现单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 给类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); 一般分为三步执行：</span><br><span class="line">    <span class="number">1.</span> 为uniqueInstance 分配内存空间</span><br><span class="line">    <span class="number">2.</span> 初始化uniqueInstance</span><br><span class="line">    <span class="number">3.</span> 将uniqueInstance指向分配的内存地址</span><br><span class="line">如果没有禁止指令重排序，可能指令的执行顺序变为<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>，一个线程执行了<span class="number">1</span>，<span class="number">3</span>，另一个线程在判断对象是否为空时，得到uniqueInstance不为空，直接返回，但此时uniqueInstance还没有被初始化</span><br></pre></td></tr></table></figure><p><code>volatile</code>不能够保证原子性</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>共享资源每次只能有一个线程在使用，其他线程阻塞，用完后再将资源分配给其他线程，悲观锁通常用于写比较多的情况下（多写场景），避免频繁失败和重试影响性能</p><p><code>synchronized</code>和<code>ReentrantLock</code>等独占锁都是悲观锁的思想</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>在Java6之前属于<strong>重量级锁</strong>，Java6之后对其进行改进，引入了优化如自旋锁，偏向锁，轻量级锁等技术来减少锁的开销，提升了效率</p><h4 id="如何使用synchronized？"><a href="#如何使用synchronized？" class="headerlink" title="如何使用synchronized？"></a>如何使用synchronized？</h4><p>使用方式一般有三种：</p><h5 id="修饰实例方法（锁当前对象实例）"><a href="#修饰实例方法（锁当前对象实例）" class="headerlink" title="修饰实例方法（锁当前对象实例）"></a>修饰实例方法（锁当前对象实例）</h5><p>给当前对象实例加锁，进入同步代码块前要获得 <strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修饰静态方法（锁当前类）"><a href="#修饰静态方法（锁当前类）" class="headerlink" title="修饰静态方法（锁当前类）"></a>修饰静态方法（锁当前类）</h5><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码块前要获取 <strong>当前class的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态<code>synchronized</code>和非静态<code>synchronized</code>的方法之间的调用是<strong>非互斥的</strong>，意思是，线程A调用一个实例对象的非静态<code>synchronized</code>方法，线程B调用这个实例对象所属类的静态<code>synchronized</code>方法，是允许的，不会发生互斥</p><h5 id="修饰代码块（锁指定对象或者类）"><a href="#修饰代码块（锁指定对象或者类）" class="headerlink" title="修饰代码块（锁指定对象或者类）"></a>修饰代码块（锁指定对象或者类）</h5><ul><li><code>synchronized(object)</code>表示进入同步代码块前要获取 <strong>给定对象的锁</strong></li><li><code>synchronized(类.class)</code>表示进入同步代码块前要获取 <strong>给定Class的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;  <span class="comment">// 给当前对象加锁</span></span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饿汉式单例模式的实现："><a href="#饿汉式单例模式的实现：" class="headerlink" title="饿汉式单例模式的实现："></a>饿汉式单例模式的实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    饿汉式：</span></span><br><span class="line"><span class="comment">    类加载时即创建对象，线程安全</span></span><br><span class="line"><span class="comment">    优点：执行效率高</span></span><br><span class="line"><span class="comment">    确定：类加载时就初始化，浪费内存资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newInstance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式单例模式的实现："><a href="#懒汉式单例模式的实现：" class="headerlink" title="懒汉式单例模式的实现："></a>懒汉式单例模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(newInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    newInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 该方法不是原子性操作，会出现线程不安全</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">1.分配内存空间</span></span><br><span class="line"><span class="comment">2.执行方法构造，初始化内存</span></span><br><span class="line"><span class="comment">3.把对象指向内存空间</span></span><br><span class="line"><span class="comment">A-&gt; 1，3，2</span></span><br><span class="line"><span class="comment">B-&gt;此时进入，没执行到2，会直接返回，出现线程不安全</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法不能用synchronized进行修饰"><a href="#构造方法不能用synchronized进行修饰" class="headerlink" title="构造方法不能用synchronized进行修饰"></a>构造方法不能用synchronized进行修饰</h4><h4 id="synchronized-的JVM实现"><a href="#synchronized-的JVM实现" class="headerlink" title="synchronized 的JVM实现"></a>synchronized 的JVM实现</h4><ul><li>代码块同步：通过使用monitorenter和monitorexit指令来实现的</li><li>同步方法：ACC_SYNCHRONIZED实现的</li><li>二者本质都是对monitor对象监视器的获取</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/-----3.svg" alt="img" style="zoom: 67%;" /></p><p>四种情况：</p><ul><li><p>无锁状态：线程A访问同步代码块，当前没有锁，将利用CAS将偏向锁设置为线程A</p></li><li><p>偏向锁状态：</p><ul><li><p>线程A继续访问同步代码块，直接获取锁</p></li><li><p>线程B访问代码块，当前偏向锁为线程A，将偏向锁升级为轻量级的锁</p></li><li><p>偏向锁的撤销：</p><ul><li><p>对象是不可偏向状态</p><ol><li>不需要撤销</li></ol></li><li><p>对象是可偏向状态</p><ol><li><p>MarkWord 中指向的线程不存活</p><ol><li>允许重偏向：退回到可偏向但未偏向的状态</li><li>不允许重偏向：变为无锁状态</li></ol></li><li><p>MarkWord 中的线程存活</p><ol><li><p>线程ID指向的线程仍然拥有锁</p><ol><li>升级为轻量级锁，将 mark word 复制到线程栈中</li></ol></li><li><p>不再拥有锁</p><ol><li><p>允许重偏向：退回到可偏向但未偏向的状态</p></li><li><p>不允许重偏向：变为无锁状态</p></li></ol></li></ol></li></ol></li></ul></li></ul></li><li><p>轻量级锁：</p><ul><li>利用CAS来获取轻量级锁</li><li>如果当前线程获取轻量级锁失败，尝试自旋来获取锁，当自旋次数达到临界值(threshold)，轻量级锁会升级为重量级锁</li><li>解锁时，如果成功，替换对象头，如果失败，锁升级为重量级的锁</li></ul></li><li>重量级锁：利用操作系统的互斥量（mutex）来实现</li></ul><h4 id="synchronized是不公平的锁"><a href="#synchronized是不公平的锁" class="headerlink" title="synchronized是不公平的锁"></a>synchronized是不公平的锁</h4><ul><li>CAS乐观锁不公平</li><li>进入重量级锁的线程不会直接进入等待队列，而是会自旋获取锁</li></ul><h4 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h4><ul><li>volatile 线程同步的轻量级的实现，性能优于 synchronized</li><li>volatile 只能用于变量，synchronized可以修饰方法和代码块</li><li>voliatile 能保证数据的可见性，synchronized关键字两者都能保证</li><li>voliatile 解决变量在多个线程之间的可见性，synchronized解决的是多个线程之间访问资源的同步性</li></ul><h4 id="synchronized实现两个线程交替打印奇偶数"><a href="#synchronized实现两个线程交替打印奇偶数" class="headerlink" title="synchronized实现两个线程交替打印奇偶数"></a>synchronized实现两个线程交替打印奇偶数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OddEvenPrinter</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> initCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">printer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= limit) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;打印：&quot;</span> + ++count);</span><br><span class="line">                    monitor.notify();</span><br><span class="line">                    <span class="keyword">if</span>(count &lt;= limit)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printer</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printer</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.sleep(<span class="number">1</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>实现了Lock接口，是一个<strong>可重入且独占式</strong>的锁，比<code>synchronized</code>关键字更加灵活，更强大，主要增加的功能有，轮询、超时、中断、公平锁和非公平锁、选择性通知等高级功能</p><p>其底层是由AQS来实现的</p><h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><div class="table-container"><table><thead><tr><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>都是可重入锁</td><td>可重入锁指的是线程可以再次获取自己的内部锁</td></tr><tr><td>实现依赖于API（需要lock()，unlock()配合try/finally来实现的）</td><td>实现依赖于JVM（没有暴露给我们）</td></tr><tr><td>增加了高级功能</td></tr></tbody></table></div><ul><li><strong>等待可中断</strong>：能够中断等待锁的机制</li><li>可<strong>实现公平锁</strong>：</li><li>可实现<strong>选择性通知</strong>：需要借助<code>Condition</code>接口和<code>newCondition</code>方法</li></ul><p>关于<code>Condition</code>接口的补充</p><blockquote><p>Condition 是 JDK1.5之后才有的，可以实现多路通知功能，在一个锁对象中可以创建对各Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而实现有选择性的进行线程通知，在调度线程上更加灵活，使用await()进行等待，使用singal()/singalAll()进行唤醒</p></blockquote><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。JDK 1.8 引入了性能更好的读写锁 <code>StampedLock</code></p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称<code>AbstractQueuedSynchronizer</code>，抽象队列同步器</p><p>AQS为构建锁和同步器提供了一些通用功能的实现，因此AQS能简单且高效地构造出应用广泛的大量的同步器，比如，<code>ReentrantLock</code>，<code>Semaphore</code>，<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code></p><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><ul><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是基于<strong>CLH锁</strong>实现</li></ul><h4 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h4><p>是对自旋锁的一种改进，一个虚拟的双向队列（即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。</p><p>AQS的核心原理图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/CLH.png" alt=""></p><p>AQS使用int成员变量<code>state</code>表示同步状态，通过内置的<strong>线程等待队列</strong>来完成获取资源线程的排队工作</p><p><a href="https://javaguide.cn/java/concurrent/reentrantlock.html">从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队</a></p><h3 id="CountDownLatch-有什么用？"><a href="#CountDownLatch-有什么用？" class="headerlink" title="CountDownLatch 有什么用？"></a>CountDownLatch 有什么用？</h3><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><h4 id="CountDownLatch-的原理是什么？"><a href="#CountDownLatch-的原理是什么？" class="headerlink" title="CountDownLatch 的原理是什么？"></a>CountDownLatch 的原理是什么？</h4><p><code>CountDownLatch</code> 是共享锁的一种实现，它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>，直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。然后，<code>CountDownLatch</code> 会自旋 CAS 判断 <code>state == 0</code>，如果 <code>state == 0</code> 的话，就会释放所有等待的线程，<code>await()</code> 方法之后的语句得到执行。</p><h4 id="用过-CountDownLatch-么？什么场景下用的？"><a href="#用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="用过 CountDownLatch 么？什么场景下用的？"></a>用过 CountDownLatch 么？什么场景下用的？</h4><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><p>伪代码是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有没有可以改进的地方呢？</strong></p><p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p>可以用来控制同时访问特定资源的线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为1时，信号量退化为排它锁</p><p>信号量有两种模式：</p><ul><li>公平模式：调用<code>acquire()</code>方法的顺序就是获取许可证的顺序，遵循FIFO</li><li>非公平模式：抢占式</li></ul><p>信号量适用于资源有明确访问数量限制的场景比如限流（仅限于单机模式，但是实际项目中推荐使用Redis+Lua来做限流）</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，认为共享资源每次访问的适合不会出现问题，等出现问题再回退</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值加一。当线程A要更新数据值时，在读取数据的同时会读取<code>version</code>值，在提交更新时，若读取的version的值与当前数据库中的<code>version</code>值相等时才更新，否则重试更新操作</p><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>全称为Compare And Swap（比较与交换），用于实现乐观锁。CAS是一个原子操作，底层依赖于一条CPU的原子指令</p><p>CAS涉及到三个操作数：</p><ul><li>V：要更新的变量值</li><li>E：预期值</li><li>N：拟写入的新值</li></ul><p>当且仅当V的值等于E时，CAS通过原子方式用新值N来更新V的值。如果不等，说明已经有其他线程更新V，则当前线程放弃更新</p><p>Java没有直接实现CAS，而是通过C++内联汇编的形式实现的（JNI调用）</p><h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul><li>ABA问题：<ul><li>如果V读取A但是被其他线程修改为B又修改回A，则不能保证当前值没有被更改过</li><li>解决办法：加上版本号或者时间戳</li></ul></li><li>循环时间长开销大：<ul><li>CAS经常需要自旋操作来进行重试，如果不成功就一致循环执行直到成功。如果长时间不成功，会给CPU带来非常大的执行开销</li></ul></li><li>只能保证一个共享变量的原子操作：<ul><li>引用<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作</li></ul></li></ul><h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><p>具有原子/原子操作特征的类</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>基本类型：</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code> ：布尔型原子类</li></ul></li><li><p>数组类型：</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code> ：引用类型数组原子类</li></ul></li><li><p>引用类型：</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code> ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></li><li><p>对象属性修改类型：</p><ul><li><p><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</p><p><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</p><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</p></li></ul></li></ul><h4 id="AtomicInteger-类常用方法"><a href="#AtomicInteger-类常用方法" class="headerlink" title="AtomicInteger 类常用方法"></a>AtomicInteger 类常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>  <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span>  <span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span>  <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect,<span class="type">int</span> update)</span>  <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span>  <span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/mingyry/91e798bc.html"/>
      <url>/mingyry/91e798bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>抽象了线程和主内存之间的关系</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/jmm.png" alt="JMM(Java 内存模型)" style="zoom:80%;" /></p><ul><li>主内存：所有线程创建的实例对象都存放在主内存中，不管该实例的本地方法还是方法中的本地变量（也称局部变量）</li><li>本地内存：每个线程都有一个私有内存来存放共享变量的副本，并且每个线程都只能访问自己的本地内存，无法访问其他线程的本地内存</li></ul><h3 id="并发编程的三个特性"><a href="#并发编程的三个特性" class="headerlink" title="并发编程的三个特性"></a>并发编程的三个特性</h3><ul><li>原子性：一次或者多次操作，要么全部执行，要么都不执行，利用Synchronized以及各种Lock实现原子性</li><li>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值</li><li>有序性：由于指令重排序问题，在多线程中，指令可能不会保证语义一致，<code>volatile</code>关键词可以禁止指令进行重排序优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机</title>
      <link href="/mingyry/18701caa.html"/>
      <url>/mingyry/18701caa.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-虚拟机"><a href="#JVM-虚拟机" class="headerlink" title="JVM 虚拟机"></a>JVM 虚拟机</h1><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="JVM监控的工具（JVM的相关指令）"><a href="#JVM监控的工具（JVM的相关指令）" class="headerlink" title="JVM监控的工具（JVM的相关指令）"></a>JVM监控的工具（JVM的相关指令）</h3><div class="table-container"><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps【选项 】 [主机ip或域名]</td><td>输出JVM中运行的<strong>进程状态信息</strong></td></tr><tr><td>jstack 【选项】 【进程ID】</td><td>查看某个Java进程内的<strong>线程堆栈信息</strong></td></tr><tr><td>jmap【选项】【进程ID】</td><td>查看堆内存的使用状况并且生成堆转储快照</td></tr><tr><td>jhat</td><td>用于分析heapdump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td>jstat 【选项】 【进程ID】 [间隔时间 ] [查询次数]</td><td>用于查看各个功能和区域的统计信息（如：类加载、编译相关信息统计，各个内存区域GC概况和统计）主要内存信息统计</td></tr><tr><td>jinfo 【选项】【进程ID】</td><td>查看和调整JVM启动和运行参数。</td></tr><tr><td>jconsole</td><td>javaGUI监控工具，可以以图形化的形式显示各种数据，并可以通过远程连接监控远程的服务器的jvm进程</td></tr><tr><td>Linux下的top</td><td>查看当前所有进程的使用情况，CPU占有率，内存使用情况，服务器负载状态等参数</td></tr><tr><td>Visual VM:多合一故障处理工具</td><td>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></td></tr></tbody></table></div><ul><li><strong><code>jps</code></strong>：类似于ps命令，-l（输出主类的全名，如果是jar包，输出Jar路径），-v（输出虚拟机进程启动时JVM参数），-m（输出传递给Java进程main()函数的参数）</li><li><p><strong>jstat -gc PID</strong>：查看即时内存使用情况、垃圾回收统计信息，用于分析GC情况</p></li><li><p><strong>heapdump</strong>：</p><ul><li><p>概念：<br>heapdump，又被称为堆转存文件，是一个java进程在某个时间点上的内存快照。</p></li><li><p>解释：<br>具有很多种类型；<br>总体上heapdump在触发快照的时候都保存了java对象和类的信息。<br>通常在写heapdump文件前会触发一次FullGC，则该文件保存的都是FullGC后留下来的对象信息。</p><p>| 信息                      | 说明                                           |<br>| ————————————- | ——————————————————————— |<br>| 对象信息                  | 类、成员变量、直接量以及引用值                 |<br>| 类信息                    | 类加载器、名称、超类、静态成员                 |<br>| Garbage Collections Roots | JVM可达的对象                                  |<br>| 线程栈以及本地变量        | 获取快照时的线程栈信息，以及局部变量的详细信息 |</p></li></ul></li><li><p><strong><code>jhat</code></strong>: 访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p></li></ul><h3 id="利用监控工具调优"><a href="#利用监控工具调优" class="headerlink" title="利用监控工具调优"></a>利用监控工具调优</h3><p>监控工具作用：</p><ul><li><p>堆信息查看<br>查看堆空间大小分配（年轻代、老年代、持久态分配）；<br>提供即时的垃圾回收功能；<br>垃圾监控；<br>查看堆内类、对象信息查看（类型、数量等）；<br>对象引用情况查看；<br><strong>可解决：年轻代、老年代大小划分是否合理、内存泄露、垃圾回收算法设置是否合理。</strong></p></li><li><p>线程监控<br>线程信息监控：系统线程数量；<br>线程状态监控：各线程都处于什么状态下；<br>Dump线程详细情况：线程内部运行情况；<br>死锁检查；</p></li><li>热点分析<br>CPU热点：检查系统哪方面占用CPU时间较长；<br>内存热点：检查哪些对象在系统中数量最大；<br>明确热点问题，有针对性的进行系统的瓶颈查找和系统优化。</li><li>快照<br>快照是系统运行到某一时刻的一个定格。<br>依赖快照可以根据系统运行时刻、对象（或类、线程）的不同，快速找到问题。</li><li>内存泄漏<br>内存泄漏一般可以理解为系统资源（堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收，从而导致新的资源分配请求无法完成，引起系统错误。</li></ul><h3 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h3><h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><ol><li><p>显式指定对内存<code>–Xms</code>和<code>-Xmx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure></li></ol><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><ol><li><p>显式新生代内存大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br><span class="line">或者</span><br><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>-XX:MaxTenuringThreshold</p><p>新生代中对象存活次数，默认15。(若对象在eden区，经历一次MinorGC后还活着，则被移动到Survior区，年龄加1。以后，对象每次经历MinorGC，年龄都加1。达到阀值，则移入老年代)</p></li></ul><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况</p></blockquote><ol><li><p>显式指定各比值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</span><br><span class="line">例如：4，表示新生代：老年代=1：4</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio（幸存代）--- 设置两个 Survivor 区和 eden 的比值</span><br><span class="line">例如：8，表示两个Survivor:Eden=2：8</span><br></pre></td></tr></table></figure></li><li><p>显式指定永久代/元空间的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）</p></li><li><p>Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p></li></ul><h4 id="垃圾回收器相关"><a href="#垃圾回收器相关" class="headerlink" title="垃圾回收器相关"></a>垃圾回收器相关</h4><p>垃圾收集器的选取: </p><p>cms相对于g1来说，g1实现更加复杂，如卡表，卡表维护，同样的程序使用g1会比cms多消耗20%的内存和额外的执行负载。第二:选择收集器三大指标:延迟，吞吐量，内存占用。内存占用就不说了，再来说一下延迟，cms是标记-清除算法，标记了直接清除掉就ok，g1是标记-整理，每次清除都需要整理，所以说cms更加适用在B/S系统中，但是cms标记-清除带来的缺点就是产生内存碎片，不过可以通过jvm参数实现当达到一定数量的内存碎片进行一次整理。关于浮动垃圾，可以预留内存空间供用户线程使用。相对于g1来说，jdk官方推荐，region分区、可预测停顿模型、按收益动态确定回收集。所以说cms目前在很多大厂都有在使用的</p><p>在小内存4G左右且应用响应优先cms优于g1，在大内存8G应用g1有更大的优势，以及ZGC则应用于更大内存应用中。</p><h5 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h5><div class="table-container"><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>-XX：UseSerialGC</td><td>设置串行收集器</td></tr><tr><td>-XX：UseParallelGC</td><td>设置<strong>并行</strong>收集器</td></tr><tr><td>-XX：UseParallelOldGC</td><td>设置并行老年代收集器</td></tr><tr><td>-XX：UseConcMarkSweepGC</td><td>设置<strong>CMS并发</strong>收集器</td></tr></tbody></table></div><h5 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：PrintGC</td><td>开启打印gc信息</td></tr><tr><td>-XX：PrintGCDetails</td><td>打印gc详细信息</td></tr><tr><td>-XX：PrintGCTimeStamps</td><td>打印gc所经历时间的详细信息</td></tr><tr><td>-Xloggc：filename</td><td>将gc日志输出到文件</td></tr></tbody></table></div><h5 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：ParallelGCThreads = n</td><td>设置并行收集器收集时使用的CPU数</td></tr><tr><td>-XX：MaxGCPauseMillis = n</td><td>设置并行收集最大暂停时间</td></tr><tr><td>-XX：GCTimeRatio = n</td><td>设置垃圾回收时间占程序运行时间的百分比</td></tr></tbody></table></div><h5 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：CMSIncrementalMode</td><td>设置为增量模式。适用于单CPU情况</td></tr><tr><td>-XX：ParallelGCThreads = n</td><td>设置并发收集器年轻代收集方式为并发收集时，使用的CPU数。并发收集线程数</td></tr></tbody></table></div><h5 id="IDEA中的JVM的配置："><a href="#IDEA中的JVM的配置：" class="headerlink" title="IDEA中的JVM的配置："></a>IDEA中的JVM的配置：</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8d350bc15c0e47059d858f27621d11ea.png" alt="在这里插入图片描述"></p><h3 id="编译器与运行期的优化"><a href="#编译器与运行期的优化" class="headerlink" title="编译器与运行期的优化"></a>编译器与运行期的优化</h3><h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4><ul><li>java语言的编译期就是一段不确定的操作过程：<br>它可能指前端编译器把java文件转变成class字节码文件的过程，也可以指虚拟机后端运行期间编译器（JIT，Just In Time Compiler）把字节码变成机器码的过程。</li><li>它可以分为三类编译过程：<br>前端编译：把.java文件转变为.class文件<br>后端编译：把字节码（.class文件）转变为机器码<br>静态提前编译：直接把.java文件编译成本地机器代码</li></ul><h5 id="编译器的编译过程——前端编译（java→class）"><a href="#编译器的编译过程——前端编译（java→class）" class="headerlink" title="编译器的编译过程——前端编译（java→class）"></a>编译器的编译过程——前端编译（java→class）</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/9d9bc90f84514762a2a8da30b11bb2a9.png" alt="在这里插入图片描述"></p><p><strong>字节码生成</strong><br>javac编译的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外进行少量的代码添加和转换工作。</p><h4 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h4><p>java最初是通过解释器（interpreter）进行解释执行的。当虚拟机发现某方法或代码块的运行很频繁时，会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，运行时，虚拟机会将这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）</p><p><strong>解释器与即时编译器</strong> 区别</p><div class="table-container"><table><thead><tr><th>区别</th><th>解释器</th><th>即时编译器</th></tr></thead><tbody><tr><td>作用</td><td>将字节码解释为机器码，下次遇到相同的字节码，还会进行重复解释</td><td>字节码解释为机器码，存入Code Cache，下次遇到相同的字节码，不再编译直接解释</td></tr><tr><td>特点</td><td>将字节码解释为所有平台通用的机器码</td><td>根据平台类型，生成平台特定的机器码</td></tr></tbody></table></div><h5 id="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"><a href="#为何HotSpot虚拟机要使用解释器与编译器并存的框架？" class="headerlink" title="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"></a>为何HotSpot虚拟机要使用解释器与编译器并存的框架？</h5><p>HotSpot采用解释器与编译器并存的框架，是因为两者皆有优势。</p><ul><li>解释器：<br>逐条转换，保留源代码；<br>程序员可以快速启动和执行，消耗内存小；（成本低，后期效率低）</li><li>编译器：<br>一次性转换，不保留源代码；<br>随着代码频繁执行会将代码编译成本地机器码；（成本高、后期效率高）</li><li>解释器与编译器配合使用：<br>当程序需要迅速启动和执行的时候，解释器可以率先发挥作用，省去编译时间，立即执行；<br>程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以提高执行效率；<br>当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之可以使用编译执行提升效率。</li></ul><h2 id="JVM-调优案例"><a href="#JVM-调优案例" class="headerlink" title="JVM 调优案例"></a>JVM 调优案例</h2><h3 id="Linux排查的命令"><a href="#Linux排查的命令" class="headerlink" title="Linux排查的命令"></a>Linux排查的命令</h3><ul><li><p>```bash<br>ifconfig：查看所有网络接口的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  netstat -lntp：查看所有监听的端口</span><br></pre></td></tr></table></figure></li><li><p>```bash<br>netstat -antp：查看所有已经建立的连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  ps -ef | grep java：查看指定进程</span><br></pre></td></tr></table></figure></li><li><p>```bash<br>free -m：查看内存信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  top -H -p pid：查看指定端口内存信息</span><br></pre></td></tr></table></figure></li><li><pre><code class="lang-bash">df -h：查看各分区使用情况</code></pre></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>参考：<a href="https://blog.csdn.net/LXMXHJ/article/details/124876571">https://blog.csdn.net/LXMXHJ/article/details/124876571</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/mingyry/6d27f500.html"/>
      <url>/mingyry/6d27f500.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-类加载"><a href="#Java-类加载" class="headerlink" title="Java 类加载"></a>Java 类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>整个生命周期可以概括为7个阶段：加载、验证、准备、解析、初始化、使用和卸载。</p><p>顺序如下图所示：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:50%;" /></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载Class类型的文件主要分为三步：加载-&gt;连接-&gt;初始化，连接过程又分为三步：验证-&gt;准备-&gt;解析。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口（通过<a href="# 类加载器">类加载器和双亲委派模型</a>）</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保Class文件的字节流中的信息符合《Java虚拟机规范》的全部约束要求</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class文件格式检查）：常量池中的常量是否有不被支持的类型</li><li>元数据验证（字节码语义检查）：该类是否有父类，该类是否继承了不允许继承的类</li><li>字节码验证（程序语义检查）：函数的参数类型是否正确，对象的类型转换是否合理</li><li>符号引用验证（类的正确性检查）：类使用的字段是否存在，是否有合适的访问权限</li></ol><p>该阶段抛出的异常有：</p><ul><li><code>java.lang.IllegalAccessError</code>：访问或修改无权限的字段或者调用无权限访问的方法</li><li><code>java.lang.NoSuchFieldError</code>：访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><p><code>java.lang.NoSuchMethodError</code>：访问一个指定的方法，而该方法不存在时，抛出该异常。</p></li><li><p>……</p></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>是正式为类变量分配内存并设置类变量初始值的阶段</p><ol><li>进行内存分配的只有类变量（被<code>static</code>修饰的变量）</li><li>静态变量放在堆中而不是在永久代中</li><li>初始值一般是该数据类型下默认的零值，如果加上<code>final</code>修饰的话，在准备阶段就会被赋值成想要的值</li></ol><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>是虚拟机将常量池内的符号引用替换为直接引用的过程，就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行初始化方法<code>&lt;clinit&gt;()</code>的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码</p><p>类的初始化方法是多线程安全的，只有以下六种情况会触发类的初始化：</p><ol><li>当遇到<code>new</code>，<code>getstatic</code>，<code>putstatic</code>或者<code>invokestatic</code>这4条字节码指令时。</li><li>使用<code>java.lang.reflect</code>包中的方法对垒进行反射调用时，如<code>`Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code>等</li><li>初始化一个类， 要先初始化其父类</li><li>虚拟机启动时，需要先初始化一个要执行的主类，具有main方法的那个类</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li><li>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在JVM的生命周期中，被jvm自带的类加载器加载的类是不会被卸载的，只有我们自己定义的类加载器加载的类是可能被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载步骤</li><li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code></li><li>数组类不是通过类加载器创建的，是由JVM直接生成的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">classClass&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    privatefinalClassLoader classLoader;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载器的主要作用就是加载Java类的字节码（.class文件）到 JVM中（在内存中生成一个代表该类的Class对象）Class对象一般在元空间中</p><h4 id="类加载器的加载规则"><a href="#类加载器的加载规则" class="headerlink" title="类加载器的加载规则"></a>类加载器的加载规则</h4><p>JVM不会一次性加载所有的类，而是根据需要去动态加载。在具体用到的时候才会去加载</p><h4 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h4><ol><li><code>BootstraoClassLoader</code>（启动类加载器）：最顶层的加载器，由C++实现，没有父级，主要用来加载JDK内部和核心类库</li><li><code>ExensionClassLoader</code>（扩展类加载器）：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量所指定的路径下的所有类</li><li><code>AppClassLoader</code>（应用程序类加载器）：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li></ol><blockquote><p>:rainbow: 拓展一下：</p><ul><li><strong><code>rt.jar</code></strong> ： rt 代表“RunTime”，<code>rt.jar</code>是Java基础类库，包含Java doc里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载</li></ul></blockquote><ol><li>用户自定义的类加载器：</li></ol><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><ul><li>加载器类使用委托模型来搜索类和资源</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器</li><li>加载器实例用在试图亲自查找类或者资源前，将搜索类或者资源的任务委派给其父类的加载器</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 80%;" /></p><p>面向对象编程中，有一条经典的设计原则：组合优于继承，多用组合少用继承</p><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接/链接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ul><li>在类加载时，先判断当前类是否被加载过，已经被加载的类会直接返回，否则尝试加载</li><li>类加载器在进行类加载的时候，先不尝试加载该类，而是把请求委派给父类加载器来完成（调用父类的<code>loadClass()</code>方法），最终所有的请求都会会回到顶层的启动类加载器中</li><li>只有当父加载器无法加载该类时（它的搜索范围中没有找到所需的类），子加载器使用<code>findClass()</code>方法来加载类</li></ul><h5 id="如何判断两个java类是否相同"><a href="#如何判断两个java类是否相同" class="headerlink" title="如何判断两个java类是否相同"></a>如何判断两个java类是否相同</h5><ul><li>要看类的全类名是否相同</li><li>要看加载此类的类加载器是否一样</li></ul><h5 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h5><p>保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不会被篡改。不会出现我自定义的类加载器来加载<code>java.lang.Object</code>类</p><h5 id="打破双亲委派模型"><a href="#打破双亲委派模型" class="headerlink" title="打破双亲委派模型"></a>打破双亲委派模型</h5><p>自定义加载器需要继承<code>ClassLoader</code>。如果不想打破双亲委派模型，就重写<code>ClassLoader</code>中的<code>findClass()</code>方法，如果想要打破双亲委派模型，需要重写<code>loadClass()</code>方法</p><p>打破双亲委派模型的场景：Tomcat场景,(保证在一个tomcat上运行的多个web应用程序之间存在相同类（全限定类名一样）但具体操作不一样的类不冲突；)，  JNDI服务（java Naming and Directory Interface，java命名和目录接口），Spring（Spring对用户程序进行组织和管理，应用程序一般存放在WEB-INF目录下，由WebAppClassLoader类加载器加载；而Spring由Common类加载器或Shared类加载器加载；Spring如何加载WEB-INF下的应用程序呢？使用线程上下文类加载器。）</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收</title>
      <link href="/mingyry/55ad0fd.html"/>
      <url>/mingyry/55ad0fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-垃圾回收"><a href="#Java-垃圾回收" class="headerlink" title="Java 垃圾回收"></a>Java 垃圾回收</h2><h3 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h3><p>JDK7及以前，堆内存分为三部分：</p><ul><li>新生代内存：Eden区和两个Survivor区S0和S1</li><li>老生代</li><li>永久代</li></ul><p>JDK8之后永久代被元空间所取代，元空间使用直接内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/hotspot-heap-structure.41533631.png" alt="hotspot-heap-structure"></p><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><ul><li><p>对象优先在Eden区分配</p></li><li><p>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，如果对象放不进去S0或者S1，那么就利用<strong>分配担保机制</strong>将新生代对象提前转移到老年代中</p></li><li><p>大对象直接进入老年代</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制</p></li><li><p>长期存活的对象将进入老年代：</p><ul><li>虚拟机给每一个对象一个对象年龄（Age）计数器</li><li>现在Eden区中进行分配</li><li>经过一次Minor  GC 进入到Survivor，岁数赋值为1</li><li>每熬过一次Minor GC，Age+1</li><li>当年龄达到阈值，则放入老年代（当累积的某个年龄超过了Survivor区的50%时，取这个值和最大阈值中的小值作为阈值）</li></ul><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p></li><li><p>内存一般分配情况：</p><ul><li>新生代（1/3）：Eden：S0：S1=8：1：1</li><li>老年代（2/3）</li></ul></li></ul><h4 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h4><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集（Partial GC）：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代垃圾进行收集（eden区满时）</li><li>老年代收集（MajorGC / Old GC）：只对老年代进行垃圾收集（）</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li></ul><p>整堆收集（Full GC）：收集是整个Java堆和方法区（新生代晋升大小超过老年代的空间大小或者永久代分配空间不足，或者系统调用垃圾回收算法）</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>为了确保在Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间：只要老年代的最大可用的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC</p><h4 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p><h5 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h5><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h5 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h5><p>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h5 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h5><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><h5 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h5><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h5 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h5><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加1</li><li>当引用失效，计数器就减1</li><li>任何时候计数器为0的对象就是不可能再被使用的</li></ul><p>弊端：难以解决对象之间互相循环引用的问题</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Gc Roots 的对象为起点，向下搜索，当一个对象到 GC Roots没有任何的引用链相连的话，则证明此对象时不可用的需要被回收</p><p>作为GC Roots的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h5 id="对象可以回收就一定会回收么？"><a href="#对象可以回收就一定会回收么？" class="headerlink" title="对象可以回收就一定会回收么？"></a>对象可以回收就一定会回收么？</h5><p>回收之前需要经历两次标记，第一次时可达性分析法中不可达的对象进行标记，被判定的对象放在一个队列里进行二次标记，如果这时候还没有与其他对象建立关联，那么就被回收</p><h4 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h4><ul><li>强引用：最普遍的引用，垃圾回收器不会回收它。当内存空间不足时，只会抛出<code>OutOfMemoryError</code>错误</li><li>软引用：内存空间足够时不会回收，当内存空间不足时，会回收这些对象的内存</li><li>弱引用：一旦发现弱引用对象，不管当前内存空间足够与否，都会回收它的内存。但是垃圾收集器的线程优先级是较低的，不一定会执行的很早</li><li>虚引用：虚引用必须和引用队列使用</li></ul><h4 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h4><p>字符串常量：没有任何一个String对象引用该字符串常量时</p><h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><ul><li>该类的所有实例对象都被回收，堆中不存在该类的实例对象</li><li>加载该类的类加载器也被回收</li><li>该类对应的类对象没有再其他地方被引用，也没有再审核地方通过反射访问该类的方法</li></ul><p>这时候可以回收，不一定会回收</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>先标记出不需要回收的对象，再标记完成后统一回收掉没有被标记的对象。最基础的收集算法</p><p>问题：</p><p>​    1. 效率不足</p><ol><li>空间问题（会出现大量不连续的碎片）</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230418145507754.png" alt="image-20230418145507754"></p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中的一块。当把这一块内存使用完后，将还存活的对象复制到另一块去</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/90984624.e8c186ae.png" alt="复制算法"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代特点提出的一种标记算法，标记过程和标记-清除算法一样，但是后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/94057049.22c58294.png" alt="标记-整理算法 "></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，就是根据堆中的各个年代类选择合适的垃圾收集算法</p><h5 id="HotSpot为什么要分为新生代和老年代"><a href="#HotSpot为什么要分为新生代和老年代" class="headerlink" title="HotSpot为什么要分为新生代和老年代"></a>HotSpot为什么要分为新生代和老年代</h5><p>因为有大量对象会被直接收集，放在新生代中使用合适的垃圾收集算法可以付出少量的成本，对于存活几率比较高的对象放到老年代中，使用合适的垃圾收集算法进行处理</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现，更具具体的应用场景选择适合自己的垃圾收集器</p><h4 id="Serial（串行）-收集器"><a href="#Serial（串行）-收集器" class="headerlink" title="Serial（串行） 收集器"></a>Serial（串行） 收集器</h4><p>最基本的垃圾收集器，单线程，重点是在垃圾收集工作时需要暂停其他所有的工作线程</p><p>新生代：标记-复制，老年代：标记-整理</p><p>简单高效</p><h4 id="ParNew-收集器（Serial的多线程版本）"><a href="#ParNew-收集器（Serial的多线程版本）" class="headerlink" title="ParNew 收集器（Serial的多线程版本）"></a>ParNew 收集器（Serial的多线程版本）</h4><p>新生代：标记-复制，老年代：标记-整理</p><p>许多Server模式下的虚拟机的首要选择</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>关注点在吞吐量（高效率的利用CPU）。吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</p><p>新生代：标记-复制，老年代：标记-整理</p><p>JDK1.8的默认收集器，默认使用Parallel Scavenge + Parallel Old</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial 收集器的老年代版本，是一个单线程的收集器，和Parallel Scavenge收集器搭配使用</p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。注重用户体验的应用上使用。</p><p>第一款真正意义上的并发收集器，让垃圾收集线程和用户线程同时工作</p><p>四个步骤：</p><ul><li>初始标记：暂停所有线程，并记录下与root直接相连的对象，执行速度较快</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。此外会跟踪记录发生引用更新的地方</li><li>重新标记：为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，停顿时间一般比初始标记时间长，比并发标记时间短</li><li>并发清除：开启用户线程，同时GC线程开始堆未标记的区域做清扫</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/cms-garbage-collector.png" alt="CMS 收集器"></p><p>优点：并发回收，低停顿</p><p>缺点：对CPU资源敏感，无法处理浮动垃圾（标记之后，连接该对象的可达性链路断开，该对象称为浮动垃圾），使用的回收算法是标记-清除，会产生大量空间碎片</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征</p><ul><li>并行和并发：能够充分利用CPU和多核环境的硬件优势</li><li>分代收集：不需要其他收集器配合就能独立管理整个 GC 堆，保留了分代的概念</li><li>空间整合：整体来看基于标记-整理算法，局部基于标记-复制</li><li>可预测的停顿：一大优势，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ul><p>收集步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/g1-garbage-collector.png" alt="G1 收集器"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/mingyry/a7eb5674.html"/>
      <url>/mingyry/a7eb5674.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><strong>JDK1.8之后的运行区域:</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p>其中线程包含：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享的：</p><ul><li>堆</li><li>方法区（1.8之后移除了）换成了元空间</li><li>直接内存</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器，为了线程切换后能够恢复到正确的执行位置，因此每个线程都需要有一个独立的程序计数器</p><p>两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>多线程下，可以记录当前线程的执行位置，当线程发生切换后，能够返回到上次的运行位置</li></ul><p>注意：程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈也称为栈帧，生命周期和线程相同，每一个方法调用都会有一个对应的栈帧被压入，每一个方法调用结束后都有一个栈帧被弹出</p><p>虚拟机栈的组成如下图</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/stack-area.png" alt="Java 虚拟机栈"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>存放编译器可知的各种数据类型（boolean、int、char等）和对象引用（reference类型，它不同于对象本身（对象实际的所在内存空间在堆中），可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与次对象相关的位置）</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>用于存放方法执行过程中产生的中间计算结果。另外，临时变量也会放在操作数栈中</p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>将符号引用转换为调用方法的直接引用，当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。</p><h5 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h5><p>栈帧随着方法的调用而创建，随着方法结束而销毁。无论方法正常返回还是异常完成都算在方法的结束，因此方法必须有返回值</p><h5 id="栈中出现的错误"><a href="#栈中出现的错误" class="headerlink" title="栈中出现的错误"></a>栈中出现的错误</h5><ul><li><code>StackOverFlowError</code>：若栈的内存大小不允许动态扩展，函数调用陷入无限循环，导致栈中被压入太多的栈帧而占用太多的空间。当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，会抛出异常</li><li><code>OutOfMemoryError</code>：若栈的内存大小可以动态扩展，当虚拟机在动态扩展栈时候无法申请到足够的内存空间，则抛出异常</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为虚拟机所使用到的<strong>Native</strong>（非Java的方法，一般是c或者c++的方法）方法服务</p><p>栈内结构和虚拟机栈类似</p><p>也会出现<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>两个错误</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>此内存区域唯一目的是存放对象实例，几乎所有的对象实例以及数组都是在这里分配内存（例外：开启逃逸分析：某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存）</p><p>堆是垃圾收集器管理的主要区域，也被称为GC堆，垃圾收集的具体内容放到<a href="#Java 垃圾回收">Java垃圾回收</a></p><h5 id="堆中出现的错误"><a href="#堆中出现的错误" class="headerlink" title="堆中出现的错误"></a>堆中出现的错误</h5><p>最容易出现的是<code>OutOfMemoryError</code>错误，有几种表现形式：</p><ul><li><code>GC Overhead Limit Exceeded</code>：当JVM花费太多时间执行垃圾回收并且只能回收到很少的堆空间时，就会发生此错误</li><li><code>Java heap space</code>：创建对象时，堆内存中的空间不足以存放新创建的对象，会引发此错误</li></ul><h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p>JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的区域，目的为了避免字符串的重复创建</p><p>JDK1.7之前存放在永久代中，JDK1.7后字符串常量池和静态变量存放在Java堆中</p><p>转移的原因是因为永久代（方法区实现）的GC回收效率太低，放在堆中可以更高效的回收字符串内存</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>是JVM运行时数据区域的一块逻辑区域，是个个线程共享的内存区域</p><p>方法区存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></p><h5 id="方法区和永久代以及元空间的关系"><a href="#方法区和永久代以及元空间的关系" class="headerlink" title="方法区和永久代以及元空间的关系"></a>方法区和永久代以及元空间的关系</h5><p>类似于接口和类的关系</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p>为什么要将永久代替换为元空间：</p><ul><li>永久代有JVM设置的固定大小的上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，溢出的几率更小</li><li>元空间存放类的元数据，空间越大可加载的类越多</li><li>JDK8中虚拟机合并不需要额外设置永久代</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件中存放编译器生成的各种字面量和符合引用的常量池表</p><p>字面量就是源代码中的固定值的表示法包括整数、浮点数和字符串字面量。常见的符合引用（就是以一组符合来描述所引用的对象，并不一定是已经加载到虚拟机中的内容）包括类符合引用、字段符号引用、方法符合引用、接口方法符合引用</p><p>当常量池无法再申请到内存是会抛出<code>OutOfMemoryError</code>错误</p><blockquote><p>常量池中存放着引用，实际对象还是存放在Java 堆中</p><p>Animal an = new Animal()；</p><p>an：引用   Animal：对象</p><p>Java中都是通过引用来操作对象的</p></blockquote><h4 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时的数据区的一部分，而是通过JNI的方式在本地内存上分配的，也会出现<code>OutOfMemoryError</code>错误</p><h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><h4 id="第一步：类加载检查"><a href="#第一步：类加载检查" class="headerlink" title="第一步：类加载检查"></a>第一步：类加载检查</h4><p>虚拟机遇到一条new指令时，先检查这个指令的参数能否在运行时常量池中定位到这个类的符号引用，检查这个符号引用所代表的类是否被加载、解析和初始化过。</p><p>如果没有，则执行类加载的过程</p><h4 id="第二步：分配内存"><a href="#第二步：分配内存" class="headerlink" title="第二步：分配内存"></a>第二步：分配内存</h4><p>在类加载检查通过后，把堆中的一块确定大小的内存划分出来，分配给新生对象</p><p>分配方式：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整的情况下</li><li>原理：根据分界指针，分配内存</li><li>GC收集器：Serial，ParNew</li></ul></li><li><p>空闲列表：</p><ul><li>使用场合：堆内存不规整的情况下</li><li>原理：虚拟机维护一个列表，表中记录哪些内存块可用</li><li>GC收集器：CMS</li></ul></li><li><p>以上方式的使用取决于内存是否规整，就是GC收集器的算法使用的是<code>标记-清除</code>还是<code>标记-整理</code>，<code>标记-复制</code>内存也是规整的</p></li></ul><p>内存分配的并发解决：</p><ul><li>CAS+失败重试：乐观锁，保证分配方式的原子性</li><li>TLAB：预先为Eden区分配内存，首先在TLAB分配，分配需要空间大于TLAB则采取上述CAS进行内存分配</li></ul><h4 id="第三步：初始化零值"><a href="#第三步：初始化零值" class="headerlink" title="第三步：初始化零值"></a>第三步：初始化零值</h4><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头），保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用</p><h4 id="第四步：设置对象头"><a href="#第四步：设置对象头" class="headerlink" title="第四步：设置对象头"></a>第四步：设置对象头</h4><p>虚拟机需要对对象进行必要的设置，将对象信息存放在对象头中，例如信息有类的元数据信息、对象的哈希码、对象的GC分代年龄等信息</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6nlu6vcab7.png" alt="img"></p><h4 id="第五步：执行init方法"><a href="#第五步：执行init方法" class="headerlink" title="第五步：执行init方法"></a>第五步：执行init方法</h4><p>按照程序员的意愿进行初始化</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/f9c822367eaf5200222a8bf604629fa7.png" alt="img"></p><ol><li>对象头：存储自身运行时的数据<pre><code>类型指针（确定该对象是哪个类的实例）</code></pre></li><li>实例数据：真正存储的有效信息</li><li>对齐填充：对象大小必须是8字节的整数倍</li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。访问方式有两种：</p><ul><li><p>使用句柄：reference中存储的是对象的句柄地址，句柄中包含对象实例数据与对象类型数据的具体地址信息，优点是稳定，对象被移动只需要改变句柄中的实例数据指针就可以</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p></li><li><p>直接引用：reference中存储的直接就是对象的地址，优点是访问速度快</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/he">https://javaguide.cn/he</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/mingyry/adbd2430.html"/>
      <url>/mingyry/adbd2430.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h2 id="Redis的基本数据类型和底层数据结构"><a href="#Redis的基本数据类型和底层数据结构" class="headerlink" title="Redis的基本数据类型和底层数据结构"></a>Redis的基本数据类型和底层数据结构</h2><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB的情况和优缺点"><a href="#RDB的情况和优缺点" class="headerlink" title="RDB的情况和优缺点"></a>RDB的情况和优缺点</h3><h4 id="触发方式（自动和手动）"><a href="#触发方式（自动和手动）" class="headerlink" title="触发方式（自动和手动）"></a>触发方式（自动和手动）</h4><h4 id="命令的执行流程"><a href="#命令的执行流程" class="headerlink" title="命令的执行流程"></a>命令的执行流程</h4><h4 id="大数据情况下的RDB如何保证数据一致性"><a href="#大数据情况下的RDB如何保证数据一致性" class="headerlink" title="大数据情况下的RDB如何保证数据一致性"></a>大数据情况下的RDB如何保证数据一致性</h4><h4 id="发生快照时，Redis崩溃怎么办"><a href="#发生快照时，Redis崩溃怎么办" class="headerlink" title="发生快照时，Redis崩溃怎么办"></a>发生快照时，Redis崩溃怎么办</h4><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h3 id="AOF的情况和优缺点"><a href="#AOF的情况和优缺点" class="headerlink" title="AOF的情况和优缺点"></a>AOF的情况和优缺点</h3><h4 id="AOF的实现"><a href="#AOF的实现" class="headerlink" title="AOF的实现"></a>AOF的实现</h4><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><h5 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h5><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><h4 id="AOF重写会阻塞么"><a href="#AOF重写会阻塞么" class="headerlink" title="AOF重写会阻塞么"></a>AOF重写会阻塞么</h4><h4 id="AOF什么时候回重写"><a href="#AOF什么时候回重写" class="headerlink" title="AOF什么时候回重写"></a>AOF什么时候回重写</h4><h4 id="AOF重写时有新日志写入怎么办"><a href="#AOF重写时有新日志写入怎么办" class="headerlink" title="AOF重写时有新日志写入怎么办"></a>AOF重写时有新日志写入怎么办</h4><h4 id="AOF重写日志时，主线程什么时候被阻塞"><a href="#AOF重写日志时，主线程什么时候被阻塞" class="headerlink" title="AOF重写日志时，主线程什么时候被阻塞"></a>AOF重写日志时，主线程什么时候被阻塞</h4><h3 id="AOF和RDB混合使用"><a href="#AOF和RDB混合使用" class="headerlink" title="AOF和RDB混合使用"></a>AOF和RDB混合使用</h3><h3 id="线上优化方向"><a href="#线上优化方向" class="headerlink" title="线上优化方向"></a>线上优化方向</h3><h2 id="缓存的问题及解决办法"><a href="#缓存的问题及解决办法" class="headerlink" title="缓存的问题及解决办法"></a>缓存的问题及解决办法</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h2 id="数据库缓存一致性"><a href="#数据库缓存一致性" class="headerlink" title="数据库缓存一致性"></a>数据库缓存一致性</h2><h3 id="三种更新策略，分别作用和情况"><a href="#三种更新策略，分别作用和情况" class="headerlink" title="三种更新策略，分别作用和情况"></a>三种更新策略，分别作用和情况</h3><ol><li>旁路缓存模式<ul><li>失效：从缓存中取数据，没有则从数据库中取，然后放到缓存中</li><li>命中：直接从缓存中返回数据</li><li>更新：先更新数据库，再删除缓存</li></ul></li><li>读写穿透模式<ul><li>失效：如果没有获得数据，缓存直接从数据库自己加载数据</li><li>更新：命中缓存，更新缓存，缓存再自己更新数据库</li></ul></li><li>写回缓存模式<ul><li>所有操作都在缓存中，异步更新数据库</li></ul></li></ol><h3 id="两种解决方案（针对没有删除掉缓存）"><a href="#两种解决方案（针对没有删除掉缓存）" class="headerlink" title="两种解决方案（针对没有删除掉缓存）"></a>两种解决方案（针对没有删除掉缓存）</h3><h4 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h4><ul><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ul><p>缺点：对业务线代码造成大量的侵入，解决办法就是订阅binlog</p><h4 id="订阅binlog"><a href="#订阅binlog" class="headerlink" title="订阅binlog"></a>订阅binlog</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-cache-5.png" alt="img"></p><p>利用canal来订阅binlog</p><h2 id="缓存满了的情况"><a href="#缓存满了的情况" class="headerlink" title="缓存满了的情况"></a>缓存满了的情况</h2><h3 id="Redis设置的大小"><a href="#Redis设置的大小" class="headerlink" title="Redis设置的大小"></a>Redis设置的大小</h3><p><strong>总数据量的 15% 到 30%</strong></p><h3 id="缓存删除策略"><a href="#缓存删除策略" class="headerlink" title="缓存删除策略"></a>缓存删除策略</h3><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>周期性的抽取部分过期的key，然后执行删除：</p><ul><li>Redis设置一个定时任务serverCron()，按照一定的频率清除过期key，模式为SLOW<ul><li>SLOW规则：<ul><li>抽取20个key判断是否过期</li><li>如果没达到时间上限（执行周期*25%）并且过期key比例大于10%，则再一次进行抽样，否则结束</li></ul></li></ul></li><li>Redis每个事件循环前，会调用beforeSleep()，模式为FAST</li></ul><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>当访问一个key的时候，检查key的存活时间，如果已经过期才执行删除</p><h3 id="缓存淘汰机制（最好学会LRU算法）"><a href="#缓存淘汰机制（最好学会LRU算法）" class="headerlink" title="缓存淘汰机制（最好学会LRU算法）"></a>缓存淘汰机制（最好学会LRU算法）</h3><p>Redis在处理客户端命令的时候，检查内存是否达到设置的阈值，然后淘汰部分key，</p><h5 id="8种淘汰机制："><a href="#8种淘汰机制：" class="headerlink" title="8种淘汰机制："></a>8种淘汰机制：</h5><ol><li>noeviction：不淘汰任何key，但是内存满时，不允许写入新数据</li><li>volatile-ttl：对设置TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key，随机信息淘汰，也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对于设置了TTL的key，随机进行淘汰，也就是从db-&gt;expires中随机挑选</li><li>allkeys-lru：对全体key，基于LRU算法进行淘汰</li><li>volatile-lru：对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu：对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu：对设置了TTL的key，基于LFU算法进行淘汰</li></ol><ul><li>LRU：最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高</li><li>LFU：最少频率使用。统计每个key的访问频率，值越小淘汰优先级越高</li></ul><h2 id="Redis大key的情况"><a href="#Redis大key的情况" class="headerlink" title="Redis大key的情况"></a>Redis大key的情况</h2><h3 id="大Key对持久化的影响"><a href="#大Key对持久化的影响" class="headerlink" title="大Key对持久化的影响"></a>大Key对持久化的影响</h3><h2 id="Redis最佳实践"><a href="#Redis最佳实践" class="headerlink" title="Redis最佳实践"></a>Redis最佳实践</h2><h3 id="Redis的键值设置"><a href="#Redis的键值设置" class="headerlink" title="Redis的键值设置"></a>Redis的键值设置</h3><h4 id="优雅的key结构"><a href="#优雅的key结构" class="headerlink" title="优雅的key结构"></a>优雅的key结构</h4><ul><li>遵循基本格式：[业务名称]:[数据名]:[id]</li><li>长度不超过44字节</li><li>不包含特殊字符</li></ul><p>优点：</p><ul><li>可读性强</li><li>避免key冲突</li><li>方便管理 </li></ul><h4 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h4><ul><li><p>网络阻塞</p><p>对BigKey执行读请求 ，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</p></li><li><p>数据倾斜</p><p>BigKey所在的Redis实例内存使用率远超其他实例，无法使用数据分片</p></li><li><p>Redis阻塞</p><p>对元素较多的Hash，list，zset做运算会耗时较久</p></li><li><p>CPU压力</p><p>对BigKey做序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其他应用</p></li></ul><h4 id="如何发现BigKey"><a href="#如何发现BigKey" class="headerlink" title="如何发现BigKey"></a>如何发现BigKey</h4><ol><li><p>redis-cli —bigkeys</p><p>只能分析Top1的BigKey</p></li><li><p>SCAN进行BigKey扫描</p></li><li><p>利用第三方工具</p></li></ol><h4 id="删除BigKey"><a href="#删除BigKey" class="headerlink" title="删除BigKey"></a>删除BigKey</h4><ul><li><p>Redis3.0以下</p><p>集合遍历删除</p></li><li><p>Redis 4.0以上</p><p>UNLINK 异步删除大Key</p></li></ul><h4 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h4><ol><li><p>Hash类型的Key存储的数据太多有100万</p><p>采用分片存储，将id/100作为Key，将id%100作为field</p></li></ol><h2 id="Redis阻塞情况"><a href="#Redis阻塞情况" class="headerlink" title="Redis阻塞情况"></a>Redis阻塞情况</h2><ol><li><p>时间复杂度较高的命令：<code>ZRANGE</code>/<code>ZREVRANGE</code>，返回Zset中的排名范围的key</p></li><li><p>主线程fork()子线程时</p></li><li><p>生成RBD快照时：save命令和bgsave命令</p></li><li><p>AOF记录日志阻塞：主线程来记录日志</p></li><li><p>AOF刷盘阻塞</p></li><li><p>AOF重写阻塞</p></li><li><p>删除大key和查找大key</p></li><li><p>使用了swap内存交换：swap都是磁盘，访问太慢，相当于自断武功</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+butterfly博客搭建过程中的问题</title>
      <link href="/mingyry/8ff17a6a.html"/>
      <url>/mingyry/8ff17a6a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简单且功能强大的博客框架。支持Markdown（或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。</p><h2 id="每个目录下的网页设置"><a href="#每个目录下的网页设置" class="headerlink" title="每个目录下的网页设置"></a>每个目录下的网页设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm new page [对应目录的名字]</span><br></pre></td></tr></table></figure><p>会在对应的目录下生成一个index.md文件，但是要<strong>注意不要在archives目录下生成文件</strong>(看到其他博文中说的)</p><p>然后针对每个目录下的index.md，可以设置图片等等操作</p><p>这是index页面可以设置的属性</p><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title:   【必需】页面标题</span><br><span class="line">date:    【必需】页面创建日期</span><br><span class="line">updated:  【可选】页面更新日期</span><br><span class="line">type:【必需】标签、分类和友情链接三个页面需要配置(就是你设置的标签，分类，友链目录的名字)</span><br><span class="line">comments:【可选】显示页面评论模块(默认 true)</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords:【可选】页面关键字</span><br><span class="line">top_img:【可选】页面顶部图片</span><br><span class="line">mathjax:【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex:【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside:【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer:【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink:【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>留言板页面只需要写上内容，然后开启评论即可</p><p>音乐界面只需要关闭评论，并且将aplayer设置为true</p><h2 id="音乐盒的设置"><a href="#音乐盒的设置" class="headerlink" title="音乐盒的设置"></a>音乐盒的设置</h2><p>使用方法请参考插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> </p><p>本博客使用的是MeingJS，主要比较简单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">简单示例</span> <span class="string">(id,</span> <span class="string">server,</span> <span class="string">type)</span>  <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">%</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">进阶示例</span> <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">&quot;autoplay&quot;</span> <span class="string">&quot;mutex:false&quot;</span> <span class="string">&quot;listmaxheight:340px&quot;</span> <span class="string">&quot;preload:none&quot;</span> <span class="string">&quot;theme:#ad7a86&quot;</span><span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure><p>有关 <code>&#123;% meting %&#125;</code> 的选项列表如下:</p><div class="table-container"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div><p>如何获取网易云的id呢，需要上网页版的网易云音乐</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417110339346.png" alt="image-20230417110339346"></p><p>可以看到地址栏中出现了id和playlist，把这两个替换到对应的选项中即可</p><p>然后音乐平台选择netease</p><p>如果要是放单曲，则只需要song和对应的id即可</p><h3 id="全局aplayer的设置"><a href="#全局aplayer的设置" class="headerlink" title="全局aplayer的设置"></a>全局aplayer的设置</h3><p>如何添加全局 Aplayer 播放，请参考 <a href="https://butterfly.js.org/posts/507c070f/">这篇文章</a></p><h2 id="valine-评论设置"><a href="#valine-评论设置" class="headerlink" title="valine 评论设置"></a>valine 评论设置</h2><h3 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h3><p>如何快速开始Valiee 请参考 <a href="https://valine.js.org/quickstart.html">这篇文章</a></p><p>我们可以针对Valine进行魔改，增加他的一些功能</p><h3 id="魔改版"><a href="#魔改版" class="headerlink" title="魔改版"></a>魔改版</h3><p>首先要下载Valine.min.js文件  <a href="https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js">https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js</a></p><p>替换掉<code>themes/butterfly/source/js/Valine.min.js</code>原生 <code>js</code> 文件(如果当前目录没有就创建一个)，然后在<code>_config.butterfly.yml</code>中找到valine，将其设置为我们新生成的文件位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line"><span class="attr">option:</span></span><br><span class="line">        <span class="comment"># main_css:</span></span><br><span class="line">        <span class="comment"># main:</span></span><br><span class="line">        <span class="comment"># utils:</span></span><br><span class="line">        <span class="comment"># translate:</span></span><br><span class="line">        <span class="comment"># local_search:</span></span><br><span class="line">        <span class="comment"># algolia_js:</span></span><br><span class="line">        <span class="comment"># algolia_search:</span></span><br><span class="line">        <span class="comment"># instantsearch:</span></span><br><span class="line">        <span class="comment"># docsearch_js:</span></span><br><span class="line">        <span class="comment"># docsearch_css:</span></span><br><span class="line">        <span class="comment"># pjax:</span></span><br><span class="line">        <span class="comment"># gitalk:</span></span><br><span class="line">        <span class="comment"># gitalk_css:</span></span><br><span class="line">        <span class="comment"># blueimp_md5:</span></span><br><span class="line">    <span class="attr">valine:</span> <span class="string">/js/Valine.min.js</span></span><br></pre></td></tr></table></figure><p>然后我们寻找到<code>themes/butterfly/layout/includes/third-party/comments/</code>目录下的<code>valine.pug</code>文件  打开文件，寻找到下面的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadValine</span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initValine</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> valine = <span class="keyword">new</span> <span class="title class_">Valine</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">      <span class="attr">el</span>: <span class="string">&#x27;#vcomment&#x27;</span>,</span><br><span class="line">      <span class="attr">appId</span>: <span class="string">&#x27;#&#123;theme.valine.appId&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">appKey</span>: <span class="string">&#x27;#&#123;theme.valine.appKey&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">placeholder</span>: <span class="string">&#x27;#&#123;theme.valine.placeholder&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">avatar</span>: <span class="string">&#x27;#&#123;theme.valine.avatar&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">serverURLs</span>: <span class="string">&#x27;#&#123;theme.valine.serverURLs&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">emojiMaps</span>: !&#123;emojiMaps&#125;,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="string">&#x27;#&#123;theme.valine.pageSize&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">master</span>: <span class="string">&#x27;3451cd11a28a25de7691d4d856b929d3&#x27;</span>,   <span class="comment">//博主邮箱md5加密32位小写</span></span><br><span class="line">      <span class="attr">tagMeta</span>: [<span class="string">&quot;博主&quot;</span>, <span class="string">&quot;小伙伴&quot;</span>, <span class="string">&quot;访客&quot;</span>],     <span class="comment">//标识字段名</span></span><br><span class="line">      <span class="attr">friends</span>: [<span class="string">&#x27;b412f37e42d89e15c8aaf065934eb62e&#x27;</span>],  <span class="comment">//小伙伴邮箱Md5</span></span><br><span class="line">      <span class="attr">enableQQ</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">enableQQ</span>&#125;,</span><br><span class="line">      <span class="attr">lang</span>: <span class="string">&#x27;#&#123;theme.valine.lang&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>,</span><br><span class="line">      <span class="attr">visitor</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">visitor</span>&#125;</span><br><span class="line">    &#125;, !&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(theme.<span class="property">valine</span>.<span class="property">option</span>)&#125;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外打开<code>_config.butterfly.yml</code>, 寻找到对应的valine的目录位置，针对性的进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">JnVNUuheue1XlmfbyvgSY1Oe-gzGzoHsz</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">bVRKDRonMGGQ5U4Me0xmipvT</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="string">欢迎在博客中留言！</span></span><br><span class="line">                <span class="number">1</span><span class="string">.昵称输入QQ号可以自动识别头像和QQ邮箱</span></span><br><span class="line">                <span class="number">2</span><span class="string">.博客留言中昵称和email必须填写</span></span><br><span class="line">                <span class="number">3</span><span class="string">.欢迎留下网址方便互相回访</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">https://jnvnuuhe.lc-cn-n1-shared.com</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">nick</span>, <span class="string">mail</span>]</span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>在<code>valine.pug</code>中设置之后，你再去配置<code>_config.butterfly.yml</code> valine才会生效</p><p><strong>需要注意的是</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">placeholder:</span> <span class="string">字符串中如果包含\n则valine会启动失败，页面无评论栏</span></span><br></pre></td></tr></table></figure><p>网上推荐的解决办法是加入$&10; 这个转移符合，但是我加入也失败，希望有新的解决办法</p><h2 id="博客加载优化"><a href="#博客加载优化" class="headerlink" title="博客加载优化"></a>博客加载优化</h2><p>博客优化流程，参考<a href="https://akilar.top/posts/7c16c4bb/">https://akilar.top/posts/7c16c4bb/</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154926819.png" alt="image-20230417154926819"></p><h3 id="第一步-利用Picgo-腾讯云来作为图床"><a href="#第一步-利用Picgo-腾讯云来作为图床" class="headerlink" title="第一步 利用Picgo+腾讯云来作为图床"></a>第一步 利用Picgo+腾讯云来作为图床</h3><p>我选择利用<a href="https://cloud.tencent.com/">腾讯云</a>来存储图片</p><p>腾讯云的COS存储会给予用户免费6个月 60个G的存储空间，但是每次读写COS Bucket都会产生额外的花费，可以购买流量包，很便宜。</p><blockquote><p>注意，如果是通过外网服务器来访问腾讯云的Bucket (例如博客部署在Github pages上)，需要额外购买外网下行流量包</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153109286.png" alt="image-20230417153109286" style="zoom:80%;" /></p><p>最后就是这样都利用资源包抵扣了</p><h3 id="第二步-替换Butterfly主题中的-jsDelivr-CDN链接"><a href="#第二步-替换Butterfly主题中的-jsDelivr-CDN链接" class="headerlink" title="第二步 替换Butterfly主题中的 jsDelivr CDN链接"></a>第二步 替换Butterfly主题中的 jsDelivr CDN链接</h3><p>现在 JsDeliver已经不支持国内的访问了，很慢很慢，所以我们要替换他的链接</p><p>所以我们需要替换JsDeliver的地址，寻找到<code>themes/butterfly/_config.yml</code>中的CDN选项</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153943597.png" alt="image-20230417153943597"></p><p>首先可以将第三方js配置成unpkg，这个访问能快一些，此外，option能够自定义主题所用到的所有的cdn</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154040489.png" alt="image-20230417154040489"></p><p>cdn的选择可以参考以下博客</p><p> <a href="https://blog.zhheo.com/p/790087d9.html">Butterfly CDN链接更改指南，替换jsdelivr提升访问速度</a></p><p><a href="https://anzhiy.cn/posts/fe76.html">目前可用cdn整理</a></p><blockquote><p>注意，如果存在hexo-butterfly-tag-plugins 包，里面使用了mindmap这个挂件，他是使用 JsDeliver进行访问的，需要把这个包进行卸载，npm uninstall hexo-butterfly-tag-plugins</p><p>如果出现其他的不在主题下的js文件利用 JsDeliver 进行加速，都需要卸载其对应的包，能够加快访问速度</p></blockquote><h2 id="博客访问优化"><a href="#博客访问优化" class="headerlink" title="博客访问优化"></a>博客访问优化</h2><h3 id="第一步就是项目托管到自动部署平台上"><a href="#第一步就是项目托管到自动部署平台上" class="headerlink" title="第一步就是项目托管到自动部署平台上"></a>第一步就是项目托管到自动部署平台上</h3><p><a href="https://www.netlify.com/">Netlify</a>或者<a href="https://dash.zeabur.com/">Zeabur</a>（这个是国内开发的，但是服务器还是国外的）能够部分提高访问速度</p><h3 id="第二步：国内快速访问"><a href="#第二步：国内快速访问" class="headerlink" title="第二步：国内快速访问"></a>第二步：国内快速访问</h3><h4 id="第一种-利用Cloudflare进行反向代理"><a href="#第一种-利用Cloudflare进行反向代理" class="headerlink" title="第一种 利用Cloudflare进行反向代理"></a>第一种 利用Cloudflare进行反向代理</h4><p>CloudFlare 是通过反向代理（reverse proxy）提供网站加速服务，为站长解决了 JPG / JS / CSS 这些静态文件到 CDN 上的问题，并且通过它部署在全球各大洲的缓存结点服务器</p><h4 id="第二种-直接部署在云服务器上"><a href="#第二种-直接部署在云服务器上" class="headerlink" title="第二种 直接部署在云服务器上"></a>第二种 直接部署在云服务器上</h4><p>每个云服务器都可以部署hexo，但是都需要域名进行过备案，网上教程很多</p><h4 id="第三种-利用全站CDN进行访问加速"><a href="#第三种-利用全站CDN进行访问加速" class="headerlink" title="第三种 利用全站CDN进行访问加速"></a>第三种 利用全站CDN进行访问加速</h4><p>也需要域名进行备案，此外CDN服务一般都是付费使用的</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="/mingyry/e50d82d9.html"/>
      <url>/mingyry/e50d82d9.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Redis使用单线程的原因：</p><ol><li>使用单线程模型能带来更好的可维护性，方便开发和调试</li><li>使用单线程模型也能并发的处理客户端的请求</li><li><strong>Redis服务中运行的绝大多数操作的性能瓶颈不是CPU</strong></li></ol><p>整个Redis 的服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络I/O</p><p>Redis基于Reactor模式设计开发一套高效事件处理模型，被称作文件事件处理器</p><ul><li>文件事件处理器使用I/O多路复用来同时监听多个套接字，并根据套接字执行的任务来关联不同的事件处理器</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，对应的文件事件就会产生，这时候文件事件处理器就会调用套接字关联好的事件处理器来处理这些事件</li></ul><p>虽然文件事件处理器是单线程的，但是通过I/O多路复用程序来监听多个套接字，顺序执行每一个文件事件任务。</p><p>文件事件处理器包含4部分：</p><ul><li>多个客户端连接</li><li>IO多路复用程序</li><li>文件事件分派器（将socket关联到相应的事件处理器）</li><li>事件处理器（）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-event-handler.png" alt="文件事件处理器（file event handler）"></p><h3 id="Redis事件机制"><a href="#Redis事件机制" class="headerlink" title="Redis事件机制"></a>Redis事件机制</h3><blockquote><p>Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。</p></blockquote><h4 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h4><p>该事件库处理下面的两类事件：</p><ul><li>文件事件：用于处理Redis服务器和客户端之间的网络IO</li><li>时间事件：Redis服务器中的一些操作，需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image1.png" alt="事件管理器示意图"></p><h5 id="文件事件："><a href="#文件事件：" class="headerlink" title="文件事件："></a>文件事件：</h5><p>文件事件处理器有四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image3.png" alt="示意图" style="zoom:80%;" /></p><p>每当一个套接字socket准备好执行accept、read、write和close操作时，就会产生文件事件。</p><p>因为Redis会连接多个套接字，因此可能有多个文件事件并发出现，这时候，IO多路复用程序会将所有产生的套接字都放到同一个队列里，然后文件事件处理器会以有序、同步、单个套接字的方式处理该队列中的套接字，也就是就绪的文件事件。</p><h5 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h5><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 的时间事件的具体定义结构如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct aeTimeEvent &#123;</span><br><span class="line">    /* 全局唯一ID */</span><br><span class="line">    long long id; /* time event identifier. */</span><br><span class="line">    /* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br><span class="line">    long when_sec; /* seconds */</span><br><span class="line">    /* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span><br><span class="line">    long when_ms; /* milliseconds */</span><br><span class="line">    /* 时间处理器 */</span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    /* 事件结束回调函数，析构一些资源*/</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    /* 私有数据 */</span><br><span class="line">    void *clientData;</span><br><span class="line">    /* 前驱节点 */</span><br><span class="line">    struct aeTimeEvent *prev;</span><br><span class="line">    /* 后继节点 */</span><br><span class="line">    struct aeTimeEvent *next;</span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：</p><ul><li>如果返回值是 AE_NOMORE，那么这个事件是一个定时事件，该事件在达到后删除，之后不会再重复。</li><li>如果返回值是非 AE_NOMORE 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 <code>when</code> 属性进行更新，让这个事件在一段时间后再次达到。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，每次 Redis 会遍历整个链表，查找所有已经到达的时间事件，并且调用相应的事件处理器。</p><h3 id="引入多线程"><a href="#引入多线程" class="headerlink" title="引入多线程"></a>引入多线程</h3><p>Redis 4.0对于删除操作，加入了其他线程来进行异步处理</p><p>对于超大键值对，Redis可能会需要在释放内存空间上消耗较多的事件，这些操作就会阻塞待处理的惹怒我，将释放内存空间的工作交给后台线程异步处理。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><ul><li><code>close_file</code> 表示关闭相应文件描述符对应的文件（释放套接字、数据空间等）。<ul><li>AOF / RDB 产生的临时文件</li><li>副本数据同步过程中的临时文件（比如 RDB 文件）</li></ul></li><li><code>aof_fsync</code> 表示 AOF 刷盘<ul><li>文件追加写之后刷盘（磁盘）</li><li>文件 rewrite（重写）之后刷盘</li></ul></li><li><code>lazy_free</code> 表示惰性释放空间<ul><li>DEL 命令</li><li>FLUSHALL / FLUSHDB 命令</li></ul></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/dd09bdfc7fed48fda41310215d7cfffd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><h4 id="Redis-多线程网络模型"><a href="#Redis-多线程网络模型" class="headerlink" title="Redis 多线程网络模型"></a>Redis 多线程网络模型</h4><p>Redis单线程模式会导致系统消耗很多的CPU事件在网络I/O上从而降低吞吐量，提升Redis性能有两个方向：</p><ul><li>优化网络I/O模块</li><li>提高及其内存读写的速度</li></ul><p>而提高网络I/O的优化又有两个方向：</p><ul><li>零拷贝技术</li><li>利用多核优势</li></ul><p>零拷贝技术有局限性，Redis不好使用，因此就使用CPU多核优势</p><p>Redis引入多线程之后就是Multi-Reactors 模式，就是Main Reactor负责接收新连接，并且分发事件给Sub Reactors来独立处理，Sub Reactors处理完回复响应给客户端。基本等同于Master-Workers 模式，例如Nginx和Netty。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><a href="https://juejin.cn/post/7102780434739626014">https://juejin.cn/post/7102780434739626014</a></p><p><a href="http://remcarpediem.net/article/1aa2da89/">http://remcarpediem.net/article/1aa2da89/</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis线程模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger</title>
      <link href="/mingyry/70ccd23d.html"/>
      <url>/mingyry/70ccd23d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>访问Knife4j的文档地址：<code>http://ip:port/doc.html</code>即可查看文档</p><ul><li>在pom.xml中增加knife4j的相关依赖；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--整合Knife4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在Swagger2Config中增加一个@EnableKnife4j注解，该注解可以开启knife4j的增强功能；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger2API文档的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swagger-使用"><a href="#Swagger-使用" class="headerlink" title="Swagger 使用"></a>Swagger 使用</h2><p>所有的信息都继承于它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SwaggerProperties</span> <span class="variable">swaggerProperties</span> <span class="operator">=</span> swaggerProperties();</span><br><span class="line">        <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo(swaggerProperties))  <span class="comment">// api信息</span></span><br><span class="line">                .select() <span class="comment">// select()函数返回一个ApiSelectorBuilder实例,用来控制接口被swagger做成文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(swaggerProperties.getApiBasePackage()))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">if</span> (swaggerProperties.isEnableSecurity()) &#123;  <span class="comment">// 是否开启安全验证</span></span><br><span class="line">            docket.securitySchemes(securitySchemes())</span><br><span class="line">                    .securityContexts(securityContexts());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">(SwaggerProperties swaggerProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(swaggerProperties.getTitle())</span><br><span class="line">                .description(swaggerProperties.getDescription())</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(swaggerProperties.getContactName(), swaggerProperties.getContactUrl(), swaggerProperties.getContactEmail()))</span><br><span class="line">                .version(swaggerProperties.getVersion())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每次携带的请求头信息，开启之后才能够使用Authorize</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title function_">securitySchemes</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;SecurityScheme&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ApiKey</span> <span class="variable">apiKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiKey</span>(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">        result.add(apiKey);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置需要登录认证的路径，设置授权信息全局应用的路径</span></span><br><span class="line"><span class="comment">    defaultAuth()中通过AuthorizationScope对象的构造函数配置了作用域，在通过SecurityReference()对象和上面的鉴权方式匹配。</span></span><br><span class="line"><span class="comment">forPaths() 中放入要生效的接口路径的正则表达式，如 .forPaths(PathSelectors.regex(“^(?!auth).*$”)) 表示所有带有 auth的接口路径。此处，使用 PathSelectors.any() 表示所有接口路径都生效。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title function_">securityContexts</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;SecurityContext&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        result.add(getContextByPath(<span class="string">&quot;/*/.*&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SecurityContext <span class="title function_">getContextByPath</span><span class="params">(String pathRegex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(pathRegex))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityReference&gt; <span class="title function_">defaultAuth</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;SecurityReference&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">AuthorizationScope</span> <span class="variable">authorizationScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationScope</span>(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;accessEverything&quot;</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> <span class="title class_">AuthorizationScope</span>[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">SecurityReference</span>(<span class="string">&quot;Authorization&quot;</span>, authorizationScopes));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Swagger配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> SwaggerProperties <span class="title function_">swaggerProperties</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 每一个模块的Swagger配置</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> <span class="keyword">extends</span> <span class="title class_">BaseSwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SwaggerProperties <span class="title function_">swaggerProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SwaggerProperties.builder()</span><br><span class="line">                .apiBasePackage(<span class="string">&quot;org.javaboy.vhr&quot;</span>)</span><br><span class="line">                .title(<span class="string">&quot;vhr后台管理系统&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;vhr后台管理系统相关接口&quot;</span>)</span><br><span class="line">                .contactName(<span class="string">&quot;ywy&quot;</span>)</span><br><span class="line">                .contactEmail(<span class="string">&quot;yuwenyu_jlu@foxmail.com&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .enableSecurity(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>配置每一个模块的Swagger文档，里面包含<code>API文档生成基础路径</code>，<code>是否要启用登录认证</code>，<code>文档标题、描述、版本、联系人姓名、联系人网址、联系人邮箱</code></p></li><li><p>使用Swagger之前需要在SpringSecurityConfig中进行配置，主要目的是将Swagger的所有静态资源和Swagger登录界面允许无权限访问</p></li><li><p>Swagger的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;HrController&quot;, value = &quot;Hr管理&quot;)</span>  <span class="comment">// tags–表示说明 value–也是说明，可以使用tags替代</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/system/hr&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HrController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HrService hrService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;获取用户列表&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam(paramType = &quot;path&quot;, name = &quot;keywords&quot;, value = &quot;Hr对应的名字的关键词&quot;, example = &quot;root&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Hr&gt; <span class="title function_">getAllHrs</span><span class="params">(String keywords)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hrService.getAllHrs(keywords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;更新用户&quot;, notes = &quot;根据Hr对象来更新Hr&quot;)</span>  <span class="comment">//value用于方法描述 notes用于提示内容 tags可以重新分组</span></span><br><span class="line">    <span class="keyword">public</span> RespBean <span class="title function_">updateHr</span><span class="params">(<span class="meta">@RequestBody</span> Hr hr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hrService.updateHr(hr) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RespBean.ok(<span class="string">&quot;更新成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(<span class="string">&quot;更新失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;获取当前Hr对应的角色&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/roles&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">getAllRoles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roleService.getAllRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/role&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;更新当前Hr对应的角色&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RespBean <span class="title function_">updateHrRole</span><span class="params">(<span class="meta">@ApiParam(&quot;hr的id&quot;)</span> Integer hrid, <span class="meta">@ApiParam(&quot;Hr修改对应的角色ids&quot;)</span> Integer[] rids)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hrService.updateHrRole(hrid, rids)) &#123;</span><br><span class="line">            <span class="keyword">return</span> RespBean.ok(<span class="string">&quot;更新成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(<span class="string">&quot;更新失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;删除Hr&quot;, notes = &quot;根据url的id来指定删除对象&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RespBean <span class="title function_">deleteHrById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hrService.deleteHrById(id) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> RespBean.ok(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RespBean.error(<span class="string">&quot;删除失败!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ApiParam()</span> 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等）</span><br><span class="line">name–参数名</span><br><span class="line">value–参数说明</span><br><span class="line">required–是否必填</span><br><span class="line">    </span><br><span class="line"><span class="meta">@ApiModel()</span>用于类 ；表示对类进行说明，用于参数用实体类接收</span><br><span class="line">value–表示对象名</span><br><span class="line">description–描述</span><br><span class="line">    </span><br><span class="line"><span class="meta">@ApiImplicitParams()</span> 用于方法，包含多个 <span class="meta">@ApiImplicitParam</span></span><br><span class="line">name–参数ming</span><br><span class="line">value–参数说明</span><br><span class="line">dataType–数据类型</span><br><span class="line">paramType–参数类型</span><br><span class="line">example–举例说明</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用swagger需要注意的问题"><a href="#使用swagger需要注意的问题" class="headerlink" title="使用swagger需要注意的问题"></a>使用swagger需要注意的问题</h2><ul><li>对于只有一个HttpServletRequest参数的方法,如果参数小于5个，推荐使用 @ApiImplicitParams的方式单独封装每一个参数；如果参数大于5个，采用定义一个对象去封装所有参数的属性，然后使用@APiParam的方式</li><li>默认的访问地址：ip:port/swagger-ui.html#/,但是在shiro中,会拦截所有的请求，必须加上默认访问路径（比如项目中，就是ip:port/context/swagger-ui.html#/），然后登陆后才可以看到</li><li>在GET请求中，参数在Body体里面,不能使用@RequestBody。在POST请求，可以使用@RequestBody和@RequestParam，如果使用@RequestBody，对于参数转化的配置必须统一</li><li>controller必须指定请求类型，否则swagger会把所有的类型(6种)都生成出来</li><li>swagger在生产环境不能对外暴露,可以使用@Profile({“dev”, “prod”,“pre”})指定可以使用的环境</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/mingyry/119ed1dc.html"/>
      <url>/mingyry/119ed1dc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis持久化：RDB和AOF"><a href="#Redis持久化：RDB和AOF" class="headerlink" title="Redis持久化：RDB和AOF"></a>Redis持久化：RDB和AOF</h2><p>Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如Redis。导致程序响应慢。所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。</p><h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><blockquote><p>RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。</p></blockquote><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p>触发rdb持久化的方式有2种，分别是<strong>手动触发</strong>和<strong>自动触发</strong>。</p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><blockquote><p>手动触发分别对应save和bgsave命令</p></blockquote><ul><li><strong>save命令</strong>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li><li><strong>bgsave命令</strong>：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</li></ul><p>bgsave流程图如下所示</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-rdb-1.png" alt="img"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子替换旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><blockquote><p>在以下4种情况时会自动触发</p></blockquote><ul><li>redis.conf中配置<code>save m n</code>，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；</li><li>执行debug reload命令重新加载redis时也会触发bgsave操作；</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；</li></ul><h4 id="redis-conf中配置RDB"><a href="#redis-conf中配置RDB" class="headerlink" title="redis.conf中配置RDB"></a>redis.conf中配置RDB</h4><p><strong>快照周期</strong>：内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。</p><ul><li><strong>Redis中默认的周期新设置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 周期性执行条件的设置格式为</span></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的设置为：</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下设置方式为关闭RDB快照功能</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>以上三项默认信息设置代表的意义是：</p><ul><li>如果900秒内有1条Key信息发生变化，则进行快照；</li><li>如果300秒内有10条Key信息发生变化，则进行快照；</li><li>如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。</li><li><strong>其它相关配置</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line"><span class="built_in">dir</span> /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p><code>dbfilename</code>：RDB文件在磁盘上的名称。</p><p><code>dir</code>：RDB文件的存储路径。默认设置为“./”，也就是Redis服务的主目录。</p><p><code>stop-writes-on-bgsave-error</code>：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为yes，如果要关闭这个特性，指定即使出现快照错误Redis一样允许写操作，则可以将该值更改为no。</p><p><code>rdbcompression</code>：该属性将在字符串类型的数据被快照到磁盘文件时，启用LZF压缩算法。Redis官方的建议是请保持该选项设置为yes，因为“it’s almost always a win”。</p><p><code>rdbchecksum</code>：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。</p><h4 id="RDB深入理解"><a href="#RDB深入理解" class="headerlink" title="RDB深入理解"></a>RDB深入理解</h4><ul><li><strong>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？</strong></li></ul><p>RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。</p><p>在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。</p><p>举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-42.jpg" alt="img"></p><ul><li><strong>在进行快照操作的这段时间，如果发生服务崩溃怎么办</strong>？</li></ul><p>在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。<strong>Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。</strong></p><ul><li><strong>可以每秒做一次快照吗</strong>？</li></ul><p>对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。</p><p>如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。 　　 </p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-rdb-2.jpg" alt="img"></p><p>所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。</p><p>这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，<strong>如果频繁地执行全量快照，也会带来两方面的开销</strong>：</p><ul><li>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁<strong>阻塞主线程</strong>了。</li></ul><p>那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。</p><p>但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的<strong>空间开销问题</strong>。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？4.0版本中引入的RDB和AOF的混合方式。</p><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li><strong>优点</strong><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li><li>Redis加载RDB文件恢复数据要远远快于AOF方式；</li></ul></li><li><strong>缺点</strong><ul><li>RDB方式实时性不够，无法做到秒级的持久化；</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；</li><li>版本兼容RDB文件问题；</li></ul></li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决</p><h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>AOF日志采用写后日志，即<strong>先写内存，后写日志</strong>。</p><p><strong>为什么采用写后日志</strong>？</p><p>Redis要求高性能，采用后写日志有两方面好处：</p><ul><li><strong>避免额外的检查开销</strong>：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li><li>不会阻塞当前的写操作</li></ul><p>但这种方式存在潜在风险：</p><ul><li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li><li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li></ul><h4 id="如何实现AOF"><a href="#如何实现AOF" class="headerlink" title="如何实现AOF"></a>如何实现AOF</h4><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_ buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-4.jpg" alt="img"></p><p><code>Always</code>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p><code>Everysec</code>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p><code>No</code>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><ul><li><strong>三种写回策略的优缺点</strong></li></ul><p>上面的三种写回策略体现了一个重要原则：<strong>trade-off</strong>，取舍，指在性能和可靠性保证之间做取舍。</p><p>关于AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis设计与实现》中是这样说明的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</span><br><span class="line"></span><br><span class="line">这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</span><br></pre></td></tr></table></figure><h4 id="redis-conf中配置AOF"><a href="#redis-conf中配置AOF" class="headerlink" title="redis.conf中配置AOF"></a>redis.conf中配置AOF</h4><p>默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendonly参数开启AOF持久化</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF持久化的文件名，默认是appendonly.aof</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步策略</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载aof出错如何处理</span></span><br><span class="line">aof-load-truncated <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>以下是Redis中关于AOF的主要配置信息：</p><p><code>appendonly</code>：默认情况下AOF功能是关闭的，将该选项改为yes以便打开Redis的AOF功能。</p><p><code>appendfilename</code>：这个参数项很好理解了，就是AOF文件的名字。</p><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。</p><p>什么叫“真正执行”呢？还记得Linux操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中I/O队列的操作效率，应用程序提交的I/O操作请求一般是被放置在linux Page Cache中的，然后再由Linux操作系统中的策略自行决定正在写到磁盘上的时机。而Redis中有一个fsync()函数，可以将Page Cache中待写的数据真正写入到物理设备上，而缺点是频繁调用这个fsync()函数干预操作系统的既定策略，可能导致I/O卡顿的现象频繁 。</p><p>与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为everysec。</p><p><code>no-appendfsync-on-rewrite</code>：always和everysec的设置会使真正的I/O操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的Redis是没法解决的。为了尽量缓解这个情况，Redis提供了这个设置项，保证在完成fsync函数调用时，不会将这段时间内发生的命令操作放入操作系统的Page Cache（这段时间Redis还在接受客户端的各种写操作命令）。</p><p><code>auto-aof-rewrite-percentage</code>：上文说到在生产环境下，技术人员不可能随时随地使用“BGREWRITEAOF”命令去重写AOF文件。所以更多时候我们需要依靠Redis中对AOF文件的自动重写策略。Redis中对触发自动重写AOF文件的操作提供了两个设置：auto-aof-rewrite-percentage表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。</p><p><code>auto-aof-rewrite-min-size</code>：参考auto-aof-rewrite-percentage选项的介绍，auto-aof-rewrite-min-size设置项表示启动AOF文件重写操作的AOF文件最小大小。如果AOF文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage和auto-aof-rewrite-min-size只是用来控制Redis中自动对AOF文件进行重写的情况，如果是技术人员手动调用“BGREWRITEAOF”命令，则不受这两个限制条件左右。</p><h4 id="深入理解AOF重写"><a href="#深入理解AOF重写" class="headerlink" title="深入理解AOF重写"></a>深入理解AOF重写</h4><blockquote><p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。</p></blockquote><ul><li><strong>图例解释AOF重写</strong></li></ul><p>Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-1.jpg" alt="img"></p><ul><li><strong>AOF重写会阻塞吗</strong>？</li></ul><p>AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p><strong>所以aof在重写时，在fork进程时是会阻塞住主线程的。</strong></p><ul><li><strong>AOF日志何时会重写</strong>？</li></ul><p>有两个配置项控制AOF重写的触发：</p><p><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。</p><p><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p><ul><li><strong>重写日志时，有新数据写入咋整</strong>？</li></ul><p>重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）</p><p>而在bgrewriteaof子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。</p><p>最后通过修改文件名的方式，保证文件切换的原子性。</p><p>在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。</p><p><strong>总结操作</strong>：</p><ul><li>主线程fork出子进程重写aof日志</li><li>子进程重写日志完成后，主线程追加aof日志缓冲</li><li>替换日志文件</li></ul><blockquote><p>温馨提示</p><p>这里的进程和线程的概念有点混乱。因为后台的bgreweiteaof进程就只有一个线程在操作，而主线程是Redis的操作进程，也是单独一个线程。这里想表达的是Redis主进程在fork出一个后台进程之后，后台进程的操作和主进程是没有任何关联的，也不会阻塞主线程。</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-2.jpg" alt="img"></p><ul><li><strong>主线程fork出子进程的是如何复制内存数据的</strong>？</li></ul><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p><p>但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。如下图（进程1看做是主进程，进程2看做是子进程）：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-3.png" alt="img"></p><p>在主进程有数据写入时，而这个数据刚好在页c中，操作系统会创建这个页面的副本（页c的副本），即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的的页c。</p><ul><li><strong>在重写日志整个过程时，主线程有哪些地方会被阻塞</strong>？</li></ul><ol><li>fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。</li><li>主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。</li><li>子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。</li></ol><ul><li><strong>为什么AOF重写不复用原AOF日志</strong>？</li></ul><p>两方面原因：</p><ol><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li></ol><h4 id="AOF-持久化的优缺点如下："><a href="#AOF-持久化的优缺点如下：" class="headerlink" title="AOF 持久化的优缺点如下："></a>AOF 持久化的优缺点如下：</h4><p><strong>优点：</strong></p><ol><li><strong>可读性强：</strong> AOF 文件是一个追加写入的日志文件，记录了每个写操作的指令，因此具有很好的可读性。这在需要查看或恢复数据时非常有用。</li><li><strong>数据恢复：</strong> 在系统宕机后，通过重新执行 AOF 文件中的指令，可以比较容易地恢复数据。</li><li><strong>低延迟：</strong> AOF 持久化通常具有较低的延迟，因为数据写入会追加到文件末尾，不会因为随机读写引起的延迟。</li><li><strong>数据安全性：</strong> AOF 持久化可以按照一定的策略（如每秒同步一次或每次写操作都同步）进行同步，从而在某种程度上提供了数据的安全性。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>文件体积：</strong> AOF 文件通常会比 RDB 文件（另一种持久化方式）更大，因为它记录了每个写操作的指令，可能导致文件体积膨胀。</li><li><strong>写操作开销：</strong> AOF 每次写操作都需要将指令追加到文件中，这可能会引起较大的写操作开销，特别是在高写入负载情况下。</li><li><strong>数据恢复时间：</strong> 在恢复数据时，由于需要重新执行 AOF 文件中的指令，可能会导致恢复时间较长。</li><li><strong>数据损坏：</strong> 如果 AOF 文件在写入过程中发生损坏，可能会导致数据无法正确恢复。</li><li><strong>性能影响：</strong> 在同步频率较高的情况下，AOF 持久化可能对性能产生一定的影响，因为每次写操作都需要同步</li></ol><h3 id="RDB和AOF混合方式（4-0版本"><a href="#RDB和AOF混合方式（4-0版本" class="headerlink" title="RDB和AOF混合方式（4.0版本)"></a>RDB和AOF混合方式（4.0版本)</h3><blockquote><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p></blockquote><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-rdb-4.jpg" alt="img"></p><p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。</p><h4 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h4><blockquote><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p></blockquote><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-x-aof-5.png" alt="img"></p><ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul><p>那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p><h3 id="大Key对持久化的影响"><a href="#大Key对持久化的影响" class="headerlink" title="大Key对持久化的影响"></a>大Key对持久化的影响</h3><p>当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</p><p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程，都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程（主线程）：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li></ul><h4 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h4><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p><ul><li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li><li>控制Redis最大使用内存，防止fork耗时过长；</li><li>使用更牛逼的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ul><p>在线上我们到底该怎么做？</p><ul><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li><li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li><li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/mingyry/c24675b4.html"/>
      <url>/mingyry/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Select语句的执行流程"><a href="#Select语句的执行流程" class="headerlink" title="Select语句的执行流程"></a>Select语句的执行流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:80%;" /></p><ul><li>Server 层负责建立连接、分析和执行SQL语句</li><li>存储引擎层负责数据的存储和提取</li></ul><h4 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h4><p>进行身份认证和权限认证：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="第二步：查询缓存（8-0版本后移除）"><a href="#第二步：查询缓存（8-0版本后移除）" class="headerlink" title="第二步：查询缓存（8.0版本后移除）"></a>第二步：查询缓存（8.0版本后移除）</h4><p>执行查询语句时会先去查询缓存（Query Cache）里查找缓存，缓存是以key-value的形式存在的，如果查询到缓存，直接返回value给客户端</p><h4 id="第三步：解析器"><a href="#第三步：解析器" class="headerlink" title="第三步：解析器"></a>第三步：解析器</h4><ul><li>词法分析。根据输入的字符串构建SQL语法树</li><li>语法分析。根据语法规则，判断输入的SQL语句是否满足语法条件</li></ul><blockquote><p>这步不会去检查表是否存在或者表中的字段是否存在</p></blockquote><h4 id="第四步：执行SQL语句"><a href="#第四步：执行SQL语句" class="headerlink" title="第四步：执行SQL语句"></a>第四步：执行SQL语句</h4><h5 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h5><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将<code>select*</code>中的<code>*</code>替换成表上的所有的列</li></ul><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>负责将SQL语句按照最优方案去执行（选择索引的方式）</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</p><h3 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h3><ol><li>使用连接器进行身份认证和权限认证</li><li>使用解析器进行词法分析（构建SQL语法树）与语法分析（判断SQL语句是否满足语法条件）</li><li>开启事务，用于失败后回滚，记录相应的undo log</li><li>执行SQL更新语句（预处理器，优化器，执行器），同时将更新的记录写入到redo log中，但是redo log 不会立即写入磁盘，而是寻找合适的时机写入（WAL 技术）</li><li>更新语句执行完成后，开始记录该语句对应的bin log，将bin log保存到bin cache中，在事务提交时，才会刷新到磁盘中</li><li>事务提交，采用两阶段<ul><li>prepare阶段：将redo log对应的事务状态设置为prepare，将redo log写入到磁盘中</li><li>commit阶段：将bin cache中的bin log刷新到磁盘中，事务状态设置为commit</li></ul></li><li>一条更新语句执行完成</li></ol><h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><p>5.5版本之前使用MyISAM，5.5版本之后使用InnoDB</p><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><div class="table-container"><table><thead><tr><th style="text-align:left">InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td style="text-align:left">支持行级锁</td><td>仅支持表级锁</td></tr><tr><td style="text-align:left">支持外键</td><td>不支持外键</td></tr><tr><td style="text-align:left">支持事务</td><td>不提供事务支持</td></tr><tr><td style="text-align:left">支持数据库崩溃后的安全恢复</td><td>不支持安全恢复</td></tr><tr><td style="text-align:left">数据文件就是索引文件</td><td>索引文件和数据文件分离</td></tr></tbody></table></div><h3 id="MySql的数据存储"><a href="#MySql的数据存储" class="headerlink" title="MySql的数据存储"></a>MySql的数据存储</h3><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><ul><li>db.opt，存储当前数据库的默认字符集和字符效验规则</li><li>*.frm，表结构的存储文件</li><li>*.ibd，表数据的存储文件，也称为表空间文件</li></ul><h4 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom: 80%;" /></p><ol><li><strong>行（row）：</strong></li></ol><p>​        数据库的记录都是按照行来存放的，每一行有不同的行格式和存储结构</p><ol><li><p><strong>页（page）：</strong></p><p>InnoDB的数据是按照页的单位进行读写，默认每个页的大小为16KB</p></li><li><p><strong>区（extent）：</strong></p><p>当表中的数据量较大时，按照区为单位进行空间分配，每个区的大小为1MB</p></li><li><p><strong>段（segment）：</strong></p><ul><li>索引段：存放B+树的非叶子节点的集合</li><li>数据段：存放B+树叶子节点的集合</li><li>回滚段：存放回滚数据区的集合，MVCC就是利用了回滚段实现查询数据</li></ul></li></ol><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>Compact（5.1版本后使用）Dynamic和Compressed（5.5版本后使用）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"  /></p><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ol><li>变长字段长度列表：存储varchar的真实数据占用的字节数</li><li>NULL值列表：需要用整数个字节的位表示，也是逆序存放，列数不足整数个字节，高位补0<ul><li>二进制位的值为1，该列的值不为NULL</li><li>二进制位的值为0，该列的值为NULL</li></ul></li><li>记录头信息，5字节</li></ol><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ol><li>row_id：如果指定了主键或者唯一约束列，就无row_id，如果没有指定，会添加row_id，大小为6字节</li><li>trx_id：事务的id，表明该数据是由哪个事务生成的，必需存在，6字节</li><li>roll_pointer：记录上一个版本的指针。roll_pointer是必需的，7字节</li></ol><h5 id="varchar（n）的最大取值是多少"><a href="#varchar（n）的最大取值是多少" class="headerlink" title="varchar（n）的最大取值是多少"></a>varchar（n）的最大取值是多少</h5><p>MySQL规定所有列的字节长度不能超过65535个字节</p><p>1字节NULL值列表，2字节的变长字段长度列表</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>B+树索引，Hash索引，Full-Text索引</p><div class="table-container"><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Full-Text索引</td><td>Yes</td><td>Yes</td><td>No</td></tr></tbody></table></div><h5 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h5><ol><li>B+树和B树：<ul><li>B+树只有在叶子节点存储数据，B树的非叶子节点也存储数据</li><li>B+树采用双链表结构，可以使用基于范围的顺序查找</li><li>B+树的搜索更加稳定，必须要搜索到叶子节点</li></ul></li><li>B+树和二叉树<ul><li>B+树的高度一般在3~4层，二叉树的高度太高，因此B+树所进行的磁盘I/O操作比较少</li></ul></li><li>B+树和Hash索引<ul><li>Hash索引在等值查询时比较快，但是不适合进行范围查询</li></ul></li></ol><h4 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h4><p>聚簇索引（主键索引）和二级索引（辅助索引）</p><ul><li>聚簇索引：B+树的叶子节点存放的是实际数据</li><li>二级索引：B+树的叶子节点存放的是主键值而不是实际数据</li></ul><h4 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h4><p>主键索引、唯一索引、普通索引、前缀索引</p><ul><li>主键索引：创建表时，将主键字段作为主键索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>唯一索引：建立在唯一字段上的索引，一个表可以有多个唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> <span class="keyword">unique</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> INDEX [索引名] <span class="keyword">ON</span> [表名] (表的列名)</span><br></pre></td></tr></table></figure><ul><li>普通索引：建立在普通字段上的索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><ul><li>前缀索引：建立在字段类型为char、varchar、binary、varbinary列上，使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h4 id="按照字段个数分类"><a href="#按照字段个数分类" class="headerlink" title="按照字段个数分类"></a>按照字段个数分类</h4><p>单列索引、联合索引（复合索引）</p><p>联合索引：将多个字段组合成一个索引</p><ul><li>当遇到范围查询时，联合索引就会停止匹配</li><li>等值查询时，联合索引能够被优化，改变索引先后的顺序</li><li>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>在联合索引的遍历过程中，对联合索引所包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><h5 id="索引区分度（区分度-column字段的不同值的个数-表的总行数）"><a href="#索引区分度（区分度-column字段的不同值的个数-表的总行数）" class="headerlink" title="索引区分度（区分度=column字段的不同值的个数/表的总行数）"></a>索引区分度（区分度=column字段的不同值的个数/表的总行数）</h5><p>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到</p><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="需要创建索引的情况"><a href="#需要创建索引的情况" class="headerlink" title="需要创建索引的情况"></a>需要创建索引的情况</h4><ul><li>字段有唯一性限制</li><li>经常在<code>WHERE</code>查询条件的字段，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段，这样在查询时不需要再去排序</li></ul><h4 id="不需要创建索引的情况"><a href="#不需要创建索引的情况" class="headerlink" title="不需要创建索引的情况"></a>不需要创建索引的情况</h4><ul><li><code>WHERE</code>,<code>GROUP BY</code>,<code>ORDER BY</code>里面用不到的字段</li><li>字段中存在大量的重复数据，如果某个值出现在表中的数据行的百分比很高时，一般会忽略索引，进行全表扫描（一般查询的结果集超过了总行数的25%，就没必要走索引了）</li><li>表数据太少</li><li>经常更新的字段不需要创建索引，电商项目的用户余额</li></ul><h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h3><ul><li>前缀索引优化：目的是减少索引字段的大小</li><li>覆盖索引优化：所查询的列在索引表中直接找到，避免回表</li><li>主键索引最好是自增的：插入新记录的时候不需要重新移动数据</li><li>索引最好是NOT NULL：null导致优化器做索引选择时比较复杂，此外null会导致产生NULL值列表</li></ul><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul><li>使用左或者左右模糊匹配，<code>like %XX</code>或者<code>like %xx%</code></li><li>在查询条件中对索引列进行了函数，计算，隐式类型转换</li><li><p>联合索引不遵循最左匹配原则</p><ul><li>如果联合索引（a,b,c）查询是a=1，b=2，c=3，则会走索引；如果没有a，b=2，c=3，则不会走索引</li><li>特殊情况：a=1，c=3，这种情况其实是，a走索引，c的话根据索引下推，来筛选符合c条件的记录</li></ul></li><li><p>WHERE子句中OR前面使用索引，后面不使用索引，前面索引失效</p></li></ul><h3 id="面试额外问题"><a href="#面试额外问题" class="headerlink" title="面试额外问题"></a>面试额外问题</h3><h4 id="MySQL单表不要超过2000W行么？"><a href="#MySQL单表不要超过2000W行么？" class="headerlink" title="MySQL单表不要超过2000W行么？"></a>MySQL单表不要超过2000W行么？</h4><p>索引结构不会影响单表最大行数，2000W也只是推荐值，超过这个值会导致B+树的层级过高，影响查询的性能</p><h4 id="MySQL使用like-“-x”，索引一定失效么"><a href="#MySQL使用like-“-x”，索引一定失效么" class="headerlink" title="MySQL使用like “%x”，索引一定失效么"></a>MySQL使用like “%x”，索引一定失效么</h4><p>不一定，如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，会走全扫描二级索引树（type=index）</p><h4 id="count的性能"><a href="#count的性能" class="headerlink" title="count的性能"></a>count的性能</h4><p>count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</p><p>count(1)：表示1这个表达式不为NULL的记录有多少个，其实就是统计表中有多少个记录，此外读取记录时不会读取任何的字段值</p><p>count(*) = count(1) &gt; count(主键字段) 在执行时，如果表中存在二级索引，优化器会选择使用二级索引进行扫描</p><h5 id="大表count-的优化"><a href="#大表count-的优化" class="headerlink" title="大表count(*)的优化"></a>大表count(*)的优化</h5><ol><li>近似值：使用show table status 或者 explain命令来估算</li><li>使用额外表来保存计数值</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>A-原子性：事务是最小的执行单位，不允许分割，要么全部完成，要么全部不完成（利用undo log 来保证）</li><li>I-隔离性：并发访问数据库，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的（锁机制和MVCC来保证）</li><li>D-持久性：事务处理结束后，对数据的修改是永久的，系统故障也不会丢失（利用redo log 来保证）</li><li>C-一致性：事务操作前和操作后，数据保持一致</li></ul><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读取另一个事务未提交的数据，并且另一个事务进行了回滚操作</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片" style="zoom:80%;" /></p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>A读取数据，B也读取数据，A先修改，B后修改，A的修改被丢失</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务多次读取同一个数据，另一个事务将数据进行了修改，该事务两次读取的数据不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:80%;" /></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取某个范围的数据，另一个事务插入数据，该事务所读取的范围不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交，指一个事务没有提交时，它做的变更就能够让其他事务所读取</li><li>读已提交，允许读取并发事务已经提交的数据</li><li>可重复读，一个事务在执行过程中看到的数据跟这个事务启动时看到的数据时一致的</li><li>串行化，会对记录加上读写锁，最高的隔离级别</li></ul><p>各个隔离级别所克服的问题</p><ul><li><p>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</p></li><li><p>在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</p></li><li><p>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</p></li><li><p>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</p></li></ul><p>MySQL的默认隔离级别是<code>可重复读</code>，但是很大程度上解决了幻读现象，解决方案为：</p><ul><li>针对快照读(select 语句)，通过MVCC方式解决幻读</li><li>针对当前读(select … for update 等语句)，通过锁（next-key lock）的方式解决幻读</li></ul><h3 id="MVCC（多版本并发控制的实现）"><a href="#MVCC（多版本并发控制的实现）" class="headerlink" title="MVCC（多版本并发控制的实现）"></a>MVCC（多版本并发控制的实现）</h3><p>MVCC通过Read View、undo log、隐藏字段中的 trx_id（最后一次更新该记录的事务id）和 roll_pointer（指向旧版本的记录）来实现的</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:80%;" /></p><p>整个记录的示意图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:80%;" /></p><p>在创建Read View 后，记录中的trx_id被划分为三种情况：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:80%;" /></p><ol><li>记录的 trx_id 小于 Read View中的<code>min_trx_id</code>的值，表示该版本的记录是在创建Read View前已经提交的事务生成的，所以该版本的记录对当前事务可见</li><li>记录的 trx_id 大于 Read View中的<code>max_trx_id</code>的值，表示该版本的记录是在创建Read View后才启动的事务所生成的，因此该版本的记录不可见</li><li>如果记录的 trx_id 在 Read View的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在m_ids 列表中：<ul><li>如果在<code>m_ids</code>列表中，说明生成该版本的事务还未提交，因此该版本的记录<strong>不可见</strong></li><li>如果不在<code>m_ids</code>列表中，说明生成该版本的事务已被提交，因此该版本的记录<strong>可见</strong></li></ul></li></ol><p>如果当前记录的版本对当前事务不可见，那么事务会沿着undo log的链条，利用roll_pointer寻找旧版本的记录，找到符合Read View版本的记录</p><h3 id="MySQL完全解决幻读了么？"><a href="#MySQL完全解决幻读了么？" class="headerlink" title="MySQL完全解决幻读了么？"></a>MySQL完全解决幻读了么？</h3><p>没有</p><ol><li>当事务A查询记录不存在，但是它更新这条记录，就会看到另一个事务所插入的数据</li><li>A事务快照读，B事务插入一个数据并且提交，A事务在进行当前读，发现读取到了B事务提交的数据，发生了幻读</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h3><ol><li><p>全局锁：整个数据库只有只读状态</p></li><li><p>表级锁：</p><ul><li><p>表锁：读锁和写锁</p></li><li><p>元数据锁：MDL读锁和MDL写锁，对表执行CRUD操作时，防止其他线程对这个表结构做变更</p></li><li><p>意向锁：意向共享锁和意向独占锁时表级锁，会与表锁发生冲突，不会与行级锁发生冲突</p><p>表锁和行锁满足：读读共享，读写互斥，写写互斥</p></li><li><p>AUTO-INC锁：不指定主键值时，自增给主键赋值</p></li></ul></li><li><p>行级锁：</p><ul><li>Record Lock，记录锁，锁住一条记录，记录锁有S锁（共享锁）和X锁（读写锁）之分</li><li>Gap Lock，间隙锁，锁定一个范围，不包含记录本身，两个事务之间的间隙锁互相兼容</li><li>Next-Key Lock，临键锁，记录锁+间隙锁</li></ul></li></ol><h3 id="MySQL加锁过程"><a href="#MySQL加锁过程" class="headerlink" title="MySQL加锁过程"></a>MySQL加锁过程</h3><p>MySQL加锁过程</p><ol><li>原则：<ul><li>前开后闭区间，基本单位，next-key lock</li><li>查找过程中访问到的对象才能加锁</li></ul></li><li>优化1：索引上的等值查询，给唯一索引加锁时，临键锁退化成记录锁</li><li>优化2：索引上的等值查询，没访问到时，向右遍历时且最后一个值不满足等值条件时，退化为间隙锁</li><li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul><li>当查询的记录<strong>存在</strong>，临键锁会退化成记录锁</li><li>当查询的记录<strong>不存在</strong>，临键锁退化成间隙锁，查找id=2的例子如下：</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%B4%E9%9A%99%E9%94%81.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><ul><li>查询范围{大于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&gt;15的例子如下，如果是id&gt;=15，那么id=15的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E15.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>查询范围{小于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&lt;5的例子如下，如果是id&lt;=5，那么id=5的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E5.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h4><p>当进行等值查询时，不仅为唯一索引加锁，还要对主键索引加锁，但是只对符合查询条件的主键索引加记录锁</p><ul><li>当查询记录{存在}，间隙锁加临键锁，并且给主键索引加记录锁，例如查找age=22的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>当查询记录{不存在}，只加间隙锁，例如查找age=25的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h4><p>所使用的索引所加的锁都是next-key lock，不会退化成间隙锁或记录锁，符合查询条件的主键索引都加入记录锁</p><p>例如查询 age&gt;=22的例子如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h4><p>如果没有走索引，就会走全表扫描，对全表的记录都加锁</p><p>可以开启安全更新模式，将<code>sql_safe_updates</code>设置为1</p><h3 id="记录锁-间隙锁可以防止删除操作而导致的幻读么"><a href="#记录锁-间隙锁可以防止删除操作而导致的幻读么" class="headerlink" title="记录锁+间隙锁可以防止删除操作而导致的幻读么"></a>记录锁+间隙锁可以防止删除操作而导致的幻读么</h3><p>可以</p><h3 id="MySQL-死锁了怎么办"><a href="#MySQL-死锁了怎么办" class="headerlink" title="MySQL 死锁了怎么办"></a>MySQL 死锁了怎么办</h3><p>死锁需要四种必要条件：互斥，持有并等待，不能抢占，循环等待</p><p>MySQL有两种策略来{打破循环等待}：</p><ul><li>设置事务等待锁的超时时间：默认50秒，超时后事务主动回滚，锁释放</li><li>开启主动死锁检测：发现死锁后，主动回滚死锁链条中的某一个事务</li></ul><h3 id="导致死锁的原因"><a href="#导致死锁的原因" class="headerlink" title="导致死锁的原因"></a>导致死锁的原因</h3><p>一般为A和B事务都加入了间隙锁，因为间隙锁相互兼容，下一步的插入需要获取插入意向锁就互相等待了</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h3><ul><li>插入时，记录主键值，回滚时则删除主键对应记录</li><li>删除时，记录这条记录的所有内容，回滚时，将内容组成的记录插入回表中</li><li>更新时，记录被更新列的旧值，回滚时，更新回旧值</li></ul><h4 id="undo-log-什么时候刷盘的（持久化到磁盘）"><a href="#undo-log-什么时候刷盘的（持久化到磁盘）" class="headerlink" title="undo log 什么时候刷盘的（持久化到磁盘）"></a>undo log 什么时候刷盘的（持久化到磁盘）</h4><p>undo log和数据页的刷盘策略一样，都是通过redo log来保证持久化</p><p>InnoDB存储引擎设计了缓冲池（Buffer Pool）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><ul><li>当读取数据时，如果数据存在缓冲池中，客户端会直接读取缓冲池中的数据</li><li>当修改数据时，如果数据存在缓冲池中，将数据所在页标记为脏页，脏页不会立即写入磁盘，而是寻找合适机会再写入</li></ul><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h3><p>因为Buffer Pool是基于内存的，万一断电重启，脏页数据就会丢失</p><p>为了防止上述问题，当一条记录需要更新的时候，存储引擎会先更新内存（同时标记为脏页），然后将本次修改以redo log的形式记录下来</p><p>WAL技术：写操作不是立即写到磁盘上，而是先写日志，然后寻找合适的时间再写入到磁盘中</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><h4 id="redo-log的具体操作"><a href="#redo-log的具体操作" class="headerlink" title="redo log的具体操作"></a>redo log的具体操作</h4><p>redo log是物理页，记录某个数据页做了什么修改，在事务提交时，先将redo log 持久化到磁盘中</p><p>redo log使用的好处：</p><ol><li>实现事务的持久性，让MySQL有了崩溃恢复的能力</li><li>将写操作从{随机写}变成{顺序写}，提高了MySQL写入磁盘的性能</li></ol><p>但是redo log 不是直接写入磁盘，而是通过自己的缓存 redo log buffer 持久化到磁盘 redo log buffer默认大小16MB，可以调整它的大小来让MySQL能够处理【大事务】时不需要写入磁盘</p><h4 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h4><ul><li>MySQL正常关闭时</li><li>redo log buffer 中的写入量大于redo log buffer内存空间的一半时</li><li>后台线程每隔1s，就将redo log buffer 持久化到磁盘（崩溃可能会丢失1秒事务的数据）</li><li>每次事务提交时，都将缓存在redo log buffer 的redo log 持久化到磁盘</li></ul><h4 id="什么时候会刷脏页？有几种场景："><a href="#什么时候会刷脏页？有几种场景：" class="headerlink" title="什么时候会刷脏页？有几种场景："></a>什么时候会刷脏页？有几种场景：</h4><ol><li><code>redo log</code>写满了，要刷脏页。这种情况要尽量避免的。因为出现这种情况时，整个系统就不能再接受更新啦，即所有的更新都必须堵住。</li><li>内存不够了，需要新的内存页，就要淘汰一些数据页，这时候会刷脏页</li></ol><blockquote><p>InnoDB 用缓冲池（buffer pool）管理内存,而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须<strong>将脏页先刷到磁盘</strong>，变成干净页后才能复用。</p></blockquote><ol><li>MySQL 认为<strong>系统空闲</strong>的时候，也会刷一些脏页</li><li>MySQL 正常关闭时，会把内存的脏页都 flush 到磁盘上</li></ol><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><h4 id="redo-log日志满了怎么办"><a href="#redo-log日志满了怎么办" class="headerlink" title="redo log日志满了怎么办"></a>redo log日志满了怎么办</h4><p>redo log日志满了，MySQL不会执行新的更新操作，会被阻塞（并发量大的系统，需要设置适当的redo log的大小），引擎会标记干净页，对旧的redo log记录进行擦除</p><h3 id="bin-log日志"><a href="#bin-log日志" class="headerlink" title="bin log日志"></a>bin log日志</h3><p>是MySQL在Server层实现的日志，所有的存储引擎都可以使用</p><h4 id="redo-log-和-bin-log的区别"><a href="#redo-log-和-bin-log的区别" class="headerlink" title="redo log 和 bin log的区别"></a>redo log 和 bin log的区别</h4><div class="table-container"><table><thead><tr><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>InnoDB存储引擎实现的日志</td><td>MySQL的Server层实现的日志，所有引擎都可以使用</td></tr><tr><td>物理日志</td><td>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中</td></tr><tr><td>循环写</td><td>追加写，写满一个文件，会创建一个新的文件</td></tr><tr><td>用于故障恢复</td><td>备份恢复和主从复制</td></tr></tbody></table></div><h4 id="bin-log的刷盘时机"><a href="#bin-log的刷盘时机" class="headerlink" title="bin log的刷盘时机"></a>bin log的刷盘时机</h4><p>事务执行过程中，先把日志写到 bin log cache（Server 层的 cache），事务提交的时候，再把 bin log cache 写到 bin log 文件中。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的过程："><a href="#主从复制的过程：" class="headerlink" title="主从复制的过程："></a>主从复制的过程：</h4><ol><li><p>写入bin log：</p><p>主库收到客户端提交的事务请求后，利用bin log线程写入bin log，提交事务，更新本地存储数据</p></li><li><p>同步bin log：</p><p>从库创建专门的I/O线程，连接从库的log dump线程，接受主库的bin log日志，再把日志写入到relay log暂存日志中，返回复制成功的响应</p></li><li><p>回放bin log：</p><p>从库创建一个回放bin log的线程，读取relay log暂存日志，回放bin log中的更新存储引擎中的数据，实现主从一致性</p></li></ol><p>一般写操作在主库中，读操作在从库中，一般从库2个，备份库一个</p><h4 id="主从复制的模型"><a href="#主从复制的模型" class="headerlink" title="主从复制的模型"></a>主从复制的模型</h4><ul><li>同步复制：所有从库都复制成功返回响应才完成线程</li><li>异步复制：不会等待bin log 同步到各从库，就返回客户端的结果，当主库宕机，数据就会丢失</li><li>半同步复制：不需要等待所有从库都返回响应，只需要一个从库响应就可以，<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li></ul><h3 id="两阶段提交的意义"><a href="#两阶段提交的意义" class="headerlink" title="两阶段提交的意义"></a>两阶段提交的意义</h3><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>- </p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven3.1</title>
      <link href="/mingyry/d1df8b0a.html"/>
      <url>/mingyry/d1df8b0a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Maven的两大功能"><a href="#Maven的两大功能" class="headerlink" title="Maven的两大功能"></a>Maven的两大功能</h3><ol><li><p>构建</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java源程序编译成*.class字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包：<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个Maven工程经过打包操作生成的jar包或者war包存入Maven的本地仓库</li><li>部署：<ul><li>部署jar包：把一个jar包部署到Nexus私服服务器上</li><li>部署war包：借助相关Maven插件（例如cargo），将war包部署到Tomcat服务器上</li></ul></li></ul></li><li><p>依赖</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar包的下载：使用Maven之后，jar包会从规范的远程仓库下载到本地</li><li>jar包之间的依赖：通过依赖的传递性自动完成</li><li>jar包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul></li><li><p>Maven的工作机制</p></li></ol><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208095706353.png" alt="image-20230208095706353"></p><h3 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h3><ol><li>关注Maven的核心配置文件：conf/settings.xml，修改本地仓库，防止体积太大拖慢c盘运行速度。</li></ol><p>​    <localRepository>D:\maven-repository</localRepository></p><ol><li>配置镜像仓库，使Maven下载jar包更快</li><li>配置Maven工程的基础JDK版本，一般使用JDK1.8</li><li>配置Maven的环境变量 MAVEN_HOME</li></ol><h3 id="使用Maven的步骤"><a href="#使用Maven的步骤" class="headerlink" title="使用Maven的步骤"></a>使用Maven的步骤</h3><h4 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h4><ol><li>根据Maven的坐标找到本地仓库中对应的jar包</li></ol><p>​    使用三个『向量』在『Maven的仓库』中<strong>唯一的定位</strong>到一个『jar』包。</p><ul><li>groupId：公司或组织的 id</li><li>artifactId：一个项目或者是项目中的一个模块的 id</li><li>version：版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的jar包在Maven本地仓库中的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><ol><li>Maven自动生成的pom.xml解读</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>Maven的核心概念：POM</p><ul><li>含义：Project Object Model。项目对象模型。和POM类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</li><li>模型化思想：POM表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事务抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</li><li>对应的配置文件：POM理念体现在Maven工程根目录下pom.xml这个配置文件中。所以这个pom.xml配置文件就是Maven工程的核心配置文件。其实学习Maven就是学习这个文件怎么配置，各个配置有什么用</li></ul></li><li><p>Maven核心概念：约定的目录结构</p><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208102035142.png" alt="image-20230208102035142"></p></li></ol><ul><li>约定目录结构的意义：为了让构建过程尽可能自动化完成，所以必须约定目录结构的作用</li><li>约定大于配置：Maven对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建Maven工程后，还需要针对各个目录的位置进行详细的配置，肯定非常麻烦。</li></ul><p>​       目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码</p><h4 id="执行Maven的构建命令"><a href="#执行Maven的构建命令" class="headerlink" title="执行Maven的构建命令"></a>执行Maven的构建命令</h4><ol><li><p>要求</p><p>运行Maven中的构建操作相关的命令时，必须进入到pom.xml所在的目录。</p></li><li><p>清理操作</p><p>mvn clean      删除target目录</p></li><li><p>编译操作</p><p>主程序编译：mvn compile</p><p>测试程序编译： mvn test-compile</p><p>主程序编译结果存放目录：target/classes</p><p>测试程序编译结果存放目录：target/test-classes</p></li><li><p>测试操作</p><p>mvn test </p><p>测试报告存放目录：target/surefire-reports</p></li><li><p>打包操作</p><p>mvn package</p><p>打包的结果——jar包，存放的目录：target</p></li><li><p>安装操作</p><p>mvn install</p><p>安装是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据他的坐标生成的。</p><p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ol><h4 id="Maven中的依赖问题"><a href="#Maven中的依赖问题" class="headerlink" title="Maven中的依赖问题"></a>Maven中的依赖问题</h4><ol><li><p>依赖范围：</p><p>标签的位置：dependencies/dependency/scope</p><p>标签的可选值：compile/test/provided/system/runtime/import</p><p>结论：</p><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“服务器上已经有了，你就别带啦！”</p></li><li><p>依赖的传递性：</p><ul><li>概念：A依赖B，B依赖C，那么在A没有配置对C的依赖的情况下，A里面能不能直接使用C？</li><li>传递的原则：在A依赖B，B依赖C的前提下，C是否能够传递到A，取决于B依赖C时使用的依赖范围。<ul><li>B依赖C时使用<strong>compile</strong>范围：可以传递</li><li>B依赖C时使用<strong>test</strong>或<strong>provided</strong>范围：不能传递，所以需要这样的jar包时，就必须在需要的地方明确配置依赖才可以。</li></ul></li></ul></li><li><p>依赖的排除</p><ul><li><p>概念：当A依赖B，B依赖C而且C可以传递到A的时候，A不想要C，需要在A里面把C排除掉。而往往这种情况都是为了避免jar包之间的冲突。</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img027.2faff879.png" alt="img">所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><ul><li><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用excludes标签配置依赖的排除  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="Maven继承"><a href="#Maven继承" class="headerlink" title="Maven继承"></a>Maven继承</h4><ul><li><p>概念：</p><p>Maven工程之间，A工程继承B工程</p><ul><li>B工程：父工程</li><li>A工程：子工程</li></ul><p>本质上是A工程的pom.xml中的配置继承了B工程中pom.xml的配置</p></li><li><p>作用：</p><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个project下面，创建了很多个module。</li><li>每一个module都需要配置自己的依赖信息。</li></ul><p>它的需求是：</p><ul><li>在每一个module中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同jar包，他们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的jar包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的jar包；又能够将以往的经验沉淀下来，节约时间和精力。</p></li><li><p>操作：</p><ul><li><p>创建父工程：只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p></li><li><p>创建模块工程：需要进入 pro03-maven-parent 工程的根目录，然后运行 mvn archetype:generate 命令来创建模块工程。</p></li><li><p>下面 modules 和 module 标签是聚合功能的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;  </span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro04-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro05-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro06-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure></li><li><p>解读子工程的pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置依赖的统一管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子工程中引用那些被父工程管理的依赖：关键点：省略版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中升级依赖信息的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>在父工程中声明自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h4><p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><blockquote><p>概念的对应关系：</p><p>从继承角度看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合角度看：</p><ul><li>总工程</li><li>模块工程</li></ul></blockquote><ol><li><p>好处</p><ul><li>一键执行Maven命令：很多构建命令都可以在“总工程”中一键执行</li><li>配置聚合之后，各个模块工程会在总工程中展示以一个列表，让项目中的各个模块一目了然。</li></ul></li><li><p>聚合的配置：在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Maven其他核心概念"><a href="#Maven其他核心概念" class="headerlink" title="Maven其他核心概念"></a>Maven其他核心概念</h3><ol><li>生命周期：在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li><li>插件和目标：<ul><li>插件：Maven的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。</li><li>目标：一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</li></ul></li><li>仓库：<ul><li>本地仓库：在当前电脑上，为电脑上所有的Maven工程服务</li><li>远程仓库：官方或者其他组织维护的 Maven 仓库</li></ul></li></ol><p>​    Maven 远程仓库可以分为：</p><p>​        <strong>中央仓库</strong> ：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a href="https://search.maven.org/">查询地址open in new window</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</p><p>​        <strong>私服</strong> ：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</p><p>​        <strong>其他的公共仓库</strong> ：有一些公共仓库是未来加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</p><p><strong>Maven 依赖包寻找顺序：</strong></p><ol><li><p>先去本地仓库找寻，有的话，直接使用。</p></li><li><p>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</p></li><li><p>远程仓库没有找到的话，会报错。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/mingyry/bae4ff13.html"/>
      <url>/mingyry/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h2><blockquote><p>一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：</p></blockquote><ul><li>读写性能优异<ul><li>Redis能读的速度是110000次/s,写的速度是81000次/s。</li></ul></li><li>数据类型丰富<ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li>原子性<ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li>丰富的特性<ul><li>Redis支持 publish/subscribe, 通知, key 过期等特性。</li></ul></li><li>持久化<ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li>发布订阅<ul><li>Redis支持发布/订阅模式</li></ul></li><li>分布式<ul><li>Redis Cluster</li></ul></li></ul><h3 id="Redis和Memcached的比较"><a href="#Redis和Memcached的比较" class="headerlink" title="Redis和Memcached的比较"></a>Redis和Memcached的比较</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ol><li>都是基于内存的数据库。</li><li>都有过期策略</li><li>性能都较好</li></ol><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><div class="table-container"><table><thead><tr><th></th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据类型</td><td>不仅支持K/V，还支持多种数据类型（list，set，zset，hash等）</td><td>仅支持K/V数据类型</td></tr><tr><td>持久化</td><td>可以把内存中的数据持久化到磁盘中</td><td>仅在内存中</td></tr><tr><td>灾难恢复机制</td><td>有</td><td>无</td></tr><tr><td>数据转移</td><td>在内存使用完后，将不用的数据放到磁盘中</td><td>内存使用完毕，会报异常</td></tr><tr><td>集群模式</td><td>原生支持cluster模式</td><td>没有原生集群模式，需要客户端帮助</td></tr><tr><td>线程</td><td>单线程的IO多路复用（6.0后针对网络数据的读写引入了多线程）</td><td>多线程，非阻塞IO复用</td></tr><tr><td>额外功能</td><td>发布订阅模型、Lua 脚本、事务等功能</td><td>没有额外功能</td></tr><tr><td>删除策略</td><td>惰性删除和定期删除</td><td>惰性删除</td></tr></tbody></table></div><h3 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h3><h4 id="旁路缓存模式（Cache-Aside-Pattern）"><a href="#旁路缓存模式（Cache-Aside-Pattern）" class="headerlink" title="旁路缓存模式（Cache Aside Pattern）"></a>旁路缓存模式（Cache Aside Pattern）</h4><p>适合读请求较多的情况</p><p><strong>读：</strong></p><ul><li>从Cache中读取数，读取到直接返回</li><li>Cache中读取不到，从数据库中读取数据，直接返回</li><li>数据库再把数据放到Cache中</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/cache-aside-read.png" alt="img"></p><p><strong>写：</strong></p><ul><li>先写入数据库</li><li>再删除Cache中对应的缓存</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/cache-aside-write.png" alt="img"></p><p><strong>如果先删除缓存再更新数据库：</strong></p><p>会造成 <strong>数据库（DB）和缓存（Cache）数据不一致</strong></p><blockquote><p>请求A 先删除缓存， 然后在更新数据库，在A更新数据库的过程中</p><p>请求B 查询缓存，查询数据库，然后将缓存的值更新为旧值</p><p>这时A 更新好数据库，数据库值变为新值。出现了数据库和缓存不一致</p></blockquote><p>虽然先更新数据库再删除缓存也会出现不一致，但是缓存的操作比较快速，能够减少这种情况</p><h5 id="该模式的缺点："><a href="#该模式的缺点：" class="headerlink" title="该模式的缺点："></a>该模式的缺点：</h5><ul><li>首次请求的数据不在缓存中</li><li>写操作比较频繁的话，缓存中的数据会一直被删除</li></ul><h4 id="读写穿透模式（Read-Write-Through-Pattern）"><a href="#读写穿透模式（Read-Write-Through-Pattern）" class="headerlink" title="读写穿透模式（Read/Write Through Pattern）"></a>读写穿透模式（Read/Write Through Pattern）</h4><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p>但是日常开发过程中比较少见，因为Redis并没有将缓存写入到DB的功能</p><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 db。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/write-through.png" alt="img"></p><p><strong>读(Read Through)：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/read-through.png" alt="img"></p><h4 id="异步缓存写入模式（Write-Behind-Pattern）"><a href="#异步缓存写入模式（Write-Behind-Pattern）" class="headerlink" title="异步缓存写入模式（Write Behind Pattern）"></a>异步缓存写入模式（Write Behind Pattern）</h4><p><strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p><p>造成的问题就是如果机器宕机，那么未被更新到DB的所有内容都将丢失</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p><div class="table-container"><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table></div><h3 id="基础数据结构详解"><a href="#基础数据结构详解" class="headerlink" title="基础数据结构详解"></a>基础数据结构详解</h3><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><blockquote><p>String是redis中最基本的数据类型，一个key对应一个value。</p></blockquote><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><ul><li><strong>图例</strong></li></ul><p>下图是一个String类型的实例，其中键为hello，值为world</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-3.png" alt="img"></p><ul><li><strong>命令使用</strong></li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>GET</td><td>获取存储在给定键中的值</td><td>GET name</td></tr><tr><td>SET</td><td>设置存储在给定键中的值</td><td>SET name value</td></tr><tr><td>DEL</td><td>删除存储在给定键中的值</td><td>DEL name</td></tr><tr><td>INCR</td><td>将键存储的值加1</td><td>INCR key</td></tr><tr><td>DECR</td><td>将键存储的值减1</td><td>DECR key</td></tr><tr><td>INCRBY</td><td>将键存储的值加上整数</td><td>INCRBY key amount</td></tr><tr><td>DECRBY</td><td>将键存储的值减去整数</td><td>DECRBY key amount</td></tr></tbody></table></div><ul><li><strong>命令执行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr counter</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100</span><br><span class="line">(<span class="built_in">integer</span>) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr counter</span><br><span class="line">(<span class="built_in">integer</span>) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>实战场景</p><ul><li><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li><li><p><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p><p>用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数</p></li><li><strong>session</strong>：常见方案spring session + redis实现session共享</li><li><strong>分布式锁</strong>：利用SETNX 实现简易的分布式锁</li></ul></li></ul><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><blockquote><p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p></blockquote><p>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</p><ul><li><p><strong>图例</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-5.png" alt="img" style="zoom:67%;" /></p></li><li><p><strong>命令使用</strong></p></li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>RPUSH</td><td>将给定值推入到列表右端</td><td>RPUSH key value</td></tr><tr><td>LPUSH</td><td>将给定值推入到列表左端</td><td>LPUSH key value</td></tr><tr><td>RPOP</td><td>从列表的右端弹出一个值，并返回被弹出的值</td><td>RPOP key</td></tr><tr><td>LPOP</td><td>从列表的左端弹出一个值，并返回被弹出的值</td><td>LPOP key</td></tr><tr><td>LRANGE</td><td>获取列表在给定范围上的所有值</td><td>LRANGE key 0 -1</td></tr><tr><td>LINDEX</td><td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td><td>LINDEX key index</td></tr></tbody></table></div><ul><li>使用列表的技巧<ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul></li><li><strong>命令执行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist -1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 10        <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li>实战场景<ul><li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li><li><strong>消息队列</strong>：不咋好用，Redis5.0提出Stream作为消息队列，但是没有专业的消息队列好用</li></ul></li></ul><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><blockquote><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p></blockquote><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><ul><li><strong>图例</strong></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-7.png" alt="img"></p><ul><li><strong>命令使用</strong></li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>SADD</td><td>向集合添加一个或多个成员</td><td>SADD key value</td></tr><tr><td>SCARD</td><td>获取集合的成员数</td><td>SCARD key</td></tr><tr><td>SMEMBERS</td><td>返回集合中的所有成员</td><td>SMEMBERS key member</td></tr><tr><td>SISMEMBER</td><td>判断 member 元素是否是集合 key 的成员</td><td>SISMEMBER key member</td></tr></tbody></table></div><p>其它一些集合操作，请参考这里<a href="https://www.runoob.com/redis/redis-sets.html">https://www.runoob.com/redis/redis-sets.html</a></p><ul><li><strong>命令执行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ul><li><p>实战场景</p><ul><li><p><strong>需要存放的数据不能重复的场景</strong></p><ul><li><p><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</p><p><code>SCARD</code>（获取集合数量），来存放对应的评论或者视频的点赞的用户的id</p></li></ul></li></ul></li></ul><ul><li><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p><ul><li><p>共同好友（交集），好友推荐（差集），共同关注（交集）等</p><p><code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</p></li></ul></li><li><p><strong>需要随机获取数据源中的元素的场景</strong></p><ul><li><p>抽奖系统、随机点名</p><p><code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景），<code>`SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）</p></li></ul></li></ul><h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><blockquote><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p></blockquote><ul><li><strong>图例</strong></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-4.png" alt="img"></p><ul><li><strong>命令使用</strong></li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>HSET</td><td>添加键值对</td><td>HSET hash-key sub-key1 value1</td></tr><tr><td>HGET</td><td>获取指定散列键的值</td><td>HGET hash-key key1</td></tr><tr><td>HGETALL</td><td>获取散列中包含的所有键值对</td><td>HGETALL hash-key</td></tr><tr><td>HDEL</td><td>如果给定键存在于散列中，那么就移除这个键</td><td>HDEL hash-key sub-key1</td></tr></tbody></table></div><ul><li><strong>命令执行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget user user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line"><span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email2 xiaohao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">5) <span class="string">&quot;name2&quot;</span></span><br><span class="line">6) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">7) <span class="string">&quot;email2&quot;</span></span><br><span class="line">8) <span class="string">&quot;xiaohao@163.com&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>实战场景</p><ul><li><p><strong>缓存</strong>： 能直观，相比string更节省空间，维护缓存信息，如用户信息，视频信息，购物车信息等。</p><p><code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）</p></li></ul></li></ul><h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><blockquote><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p></blockquote><p>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：</p><ol><li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li><li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li></ol><ul><li><strong>图例</strong></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-8.png" alt="img" style="zoom:67%;" /></p><ul><li><strong>命令使用</strong></li></ul><div class="table-container"><table><thead><tr><th>命令</th><th>简述</th><th>使用</th></tr></thead><tbody><tr><td>ZADD</td><td>将一个带有给定分值的成员添加到有序集合里面</td><td>ZADD zset-key 178 member1</td></tr><tr><td>ZRANGE</td><td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td><td>ZRANGE zset-key 0-1 withccores</td></tr><tr><td>ZREM</td><td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td><td>ZREM zset-key member1</td></tr></tbody></table></div><p>更多命令请参考这里 <a href="https://www.runoob.com/redis/redis-sorted-sets.html">https://www.runoob.com/redis/redis-sorted-sets.html</a></p><ul><li><strong>命令执行</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>实战场景</p><ul><li><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><ul><li><p>各种排行榜</p><p><code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><p>Redis中只保存排行榜需要展示的数据，具体的数据还是要去对应的数据库中查询</p><p>zSet可以对多个zSet进行组合排序，来求一些多时间或者多角色的排序</p></li></ul></li></ul></li></ul><h2 id="3种特殊类型"><a href="#3种特殊类型" class="headerlink" title="3种特殊类型"></a>3种特殊类型</h2><h3 id="HyperLogLogs（基数统计）"><a href="#HyperLogLogs（基数统计）" class="headerlink" title="HyperLogLogs（基数统计）"></a>HyperLogLogs（基数统计）</h3><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构！</p></blockquote><ul><li><strong>什么是基数？</strong></li></ul><p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p><ul><li><strong>HyperLogLogs 基数统计用来解决什么问题</strong>？</li></ul><p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p><ul><li><strong>它的优势体现在哪</strong>？</li></ul><p>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p><ul><li><strong>相关命令使用</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key1 a b c d e f g h i<span class="comment"># 创建第一组元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key1<span class="comment"># 统计元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; pfadd key2 c j k l m e g a<span class="comment"># 创建第二组元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key2</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; pfmerge key3 key1 key2<span class="comment"># 合并两组：key1 key2 -&gt; key3 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount key3</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br></pre></td></tr></table></figure><ul><li><p>实战场景：</p><ul><li><p>基于Redis统计UV（独立访客），统计一天内访问某站点的用户数</p><ul><li><p><code>PV(页面浏览量)</code>数据不去重，<code>UV</code>数据需要去重</p></li><li><p>先将访问页面的每个用户id添加到<code>HyperLogLogs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure></li><li><p>统计指定页面的UV</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="Bitmap-（位存储）"><a href="#Bitmap-（位存储）" class="headerlink" title="Bitmap （位存储）"></a>Bitmap （位存储）</h3><blockquote><p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p></blockquote><ul><li><strong>用来解决什么问题</strong>？</li></ul><p>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</p><p>如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p><ul><li><strong>相关命令使用</strong></li></ul><p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>查看某一天是否有打卡！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>统计操作，统计打卡的天数！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><ul><li><p>实战场景：</p><p><a href="https://blog.csdn.net/u011957758/article/details/74783347">https://blog.csdn.net/u011957758/article/details/74783347</a></p></li></ul><h3 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial (地理位置)"></a>geospatial (地理位置)</h3><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了! 这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p></blockquote><h4 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h4><blockquote><p>添加地理位置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p><strong>规则</strong></p><p>两级无法直接添加，我们一般会下载城市数据(这个网址可以查询 GEO： <a href="http://www.jsons.cn/lngcode)！">http://www.jsons.cn/lngcode)！</a></p><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span><br><span class="line">(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span><br></pre></td></tr></table></figure><h4 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h4><blockquote><p>获取指定的成员的经度和纬度</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city taiyuan manjing</span><br><span class="line">1) 1) <span class="string">&quot;112.54999905824661255&quot;</span></span><br><span class="line">   1) <span class="string">&quot;37.86000073876942196&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;118.75999957323074341&quot;</span></span><br><span class="line">   1) <span class="string">&quot;32.03999960287850968&quot;</span></span><br></pre></td></tr></table></figure><p>获得当前定位, 一定是一个坐标值!</p><h4 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h4><blockquote><p>如果不存在, 返回空</p></blockquote><p>单位如下</p><ul><li>m</li><li>km</li><li>mi 英里</li><li>ft 英尺</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city taiyuan shenyang m</span><br><span class="line"><span class="string">&quot;1026439.1070&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city taiyuan shenyang km</span><br><span class="line"><span class="string">&quot;1026.4391&quot;</span></span><br></pre></td></tr></table></figure><h4 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h4><blockquote><p>附近的人 ==&gt; 获得所有附近的人的地址, 定位, 通过半径来查询</p></blockquote><p>获得指定数量的人</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">4) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist</span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;864.9816&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;118.75999957323074341&quot;</span></span><br><span class="line">      2) <span class="string">&quot;32.03999960287850968&quot;</span></span><br></pre></td></tr></table></figure><p>参数 key 经度 纬度 半径 单位 [显示结果的经度和纬度] [显示结果的距离] [显示的结果的数量]</p><h4 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h4><blockquote><p>显示与指定成员一定半径范围内的其他成员</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city taiyuan 1000 km</span><br><span class="line">1) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">2) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">3) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city taiyuan 1000 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;112.54999905824661255&quot;</span></span><br><span class="line">      2) <span class="string">&quot;37.86000073876942196&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;514.2264&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure><p>参数与 georadius 一样</p><h4 id="geohash-较少使用"><a href="#geohash-较少使用" class="headerlink" title="geohash(较少使用)"></a>geohash(较少使用)</h4><blockquote><p>该命令返回11个字符的hash字符串</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash china:city taiyuan shenyang</span><br><span class="line">1) <span class="string">&quot;ww8p3hhqmp0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wxrvb9qyxk0&quot;</span></span><br></pre></td></tr></table></figure><p>将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近</p><h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><blockquote><p>geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> china:city</span><br><span class="line">zset</span><br></pre></td></tr></table></figure><p>查看全部元素 删除指定的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 withscores</span><br><span class="line"> 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;4040115445396757&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;4054133997236782&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;manjing&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;4066006694128997&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;4068216047500484&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;shenyang&quot;</span></span><br><span class="line">1)  <span class="string">&quot;4072519231994779&quot;</span></span><br><span class="line">2)  <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">3)  <span class="string">&quot;4154606886655324&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city manjing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">4) <span class="string">&quot;shenyang&quot;</span></span><br><span class="line">5) <span class="string">&quot;shengzhen&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Stream数据类型"><a href="#Stream数据类型" class="headerlink" title="Stream数据类型"></a>Stream数据类型</h3><p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p><p>美团技术团队的一篇文章，<a href="https://tech.meituan.com/2016/07/01/mq-design.html">消息队列设计精要</a> 中的图</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-1.png" alt="img"></p><p><strong>Redis考虑的设计</strong></p><ul><li>消息ID的序列化生成</li><li>消息遍历</li><li>消息的阻塞和非阻塞读取</li><li>消息的分组消费</li><li>未完成消息的处理</li><li>消息队列监控</li><li>…</li></ul><p>Redis Stream 是一种超轻量MQ，并没有完全实现消息队列所有设计要点</p><h4 id="Stream详解"><a href="#Stream详解" class="headerlink" title="Stream详解"></a>Stream详解</h4><ul><li>Stream的结构设计</li><li>生产和消费<ul><li>基本的增删查改</li><li>单一消费者的消费</li><li>消费组的消费</li></ul></li><li>监控状态</li></ul><h4 id="Stream的结构"><a href="#Stream的结构" class="headerlink" title="Stream的结构"></a>Stream的结构</h4><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-2.png" alt="img"></p><p>上图解析：</p><ul><li><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</li><li><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><code>pending_ids</code> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li></ul><p>此外我们还需要理解两点：</p><ul><li><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</li><li><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</li></ul><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>消息队列相关命令：</p><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h4 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h4><p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从Stream头部读取两条消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 2 streams codehole 0-0</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851486781-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;30&quot;</span></span><br><span class="line">      2) 1) 1527851493405-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;yurui&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;29&quot;</span></span><br><span class="line"><span class="comment"># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams codehole $</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $</span><br><span class="line"><span class="comment"># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span></span><br><span class="line">127.0.0.1:6379&gt; xadd codehole * name youming age 60</span><br><span class="line">1527852774092-0</span><br><span class="line"><span class="comment"># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span></span><br><span class="line"><span class="comment"># 而且还显示了一个等待时间，这里我们等待了93s</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527852774092-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;youming&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;60&quot;</span></span><br><span class="line">(93.11s)</span><br></pre></td></tr></table></figure><p>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</p><p>block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread block 1000 count 1 streams codehole $</span><br><span class="line">(nil)</span><br><span class="line">(1.07s)</span><br></pre></td></tr></table></figure><h4 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h4><ul><li><strong>消费组消费图</strong></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-3.png" alt="img"></p><p>相关命令：</p><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息</li></ul><p><strong>创建消费组</strong></p><p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create codehole cg1 0-0  <span class="comment">#  表示从头开始消费</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># $表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略</span></span><br><span class="line">127.0.0.1:6379&gt; xgroup create codehole cg2 $</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; xinfo stream codehole  <span class="comment"># 获取Stream信息</span></span><br><span class="line"> 1) length</span><br><span class="line"> 2) (<span class="built_in">integer</span>) 3  <span class="comment"># 共3个消息</span></span><br><span class="line"> 3) radix-tree-keys</span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 5) radix-tree-nodes</span><br><span class="line"> 6) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 7) <span class="built_in">groups</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 2  <span class="comment"># 两个消费组</span></span><br><span class="line"> 9) first-entry  <span class="comment"># 第一个消息</span></span><br><span class="line">10) 1) 1527851486781-0</span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;30&quot;</span></span><br><span class="line">11) last-entry  <span class="comment"># 最后一个消息</span></span><br><span class="line">12) 1) 1527851498956-0</span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;xiaoqian&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xinfo <span class="built_in">groups</span> codehole  <span class="comment"># 获取Stream的消费组信息</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg1&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组还没有消费者</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组没有正在处理的消息</span></span><br><span class="line">2) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg2&quot;</span></span><br><span class="line">   3) consumers  <span class="comment"># 该消费组还没有消费者</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 0</span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组没有正在处理的消息</span></span><br></pre></td></tr></table></figure><p><strong>消费组消费</strong></p><p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;号表示从当前消费组的last_delivered_id后面开始读</span></span><br><span class="line"><span class="comment"># 每当消费者读取一条消息，last_delivered_id变量就会前进</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851486781-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;30&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851493405-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;yurui&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;29&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 2 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851498956-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;xiaoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;1&quot;</span></span><br><span class="line">      2) 1) 1527852774092-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;youming&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;60&quot;</span></span><br><span class="line"><span class="comment"># 再继续读取，就没有新消息了</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 那就阻塞等待吧</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole &gt;</span><br><span class="line"><span class="comment"># 开启另一个窗口，往里塞消息</span></span><br><span class="line">127.0.0.1:6379&gt; xadd codehole * name lanying age 61</span><br><span class="line">1527854062442-0</span><br><span class="line"><span class="comment"># 回到前一个窗口，发现阻塞解除，收到新消息了</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527854062442-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;lanying&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;61&quot;</span></span><br><span class="line">(36.54s)</span><br><span class="line">127.0.0.1:6379&gt; xinfo <span class="built_in">groups</span> codehole  <span class="comment"># 观察消费组信息</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg1&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1  <span class="comment"># 一个消费者</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 5  <span class="comment"># 共5条正在处理的信息还有没有ack</span></span><br><span class="line">2) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg2&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># 消费组cg2没有任何变化，因为前面我们一直在操纵cg1</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 如果同一个消费组有多个消费者，我们可以通过xinfo consumers指令观察每个消费者的状态</span></span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1  <span class="comment"># 目前还有1个消费者</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 5  <span class="comment"># 共5条待处理消息</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 418715  <span class="comment"># 空闲了多长时间ms没有读取消息了</span></span><br><span class="line"><span class="comment"># 接下来我们ack一条消息</span></span><br><span class="line">127.0.0.1:6379&gt; xack codehole cg1 1527851486781-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1</span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 4  <span class="comment"># 变成了5条</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 668504</span><br><span class="line"><span class="comment"># 下面ack所有消息</span></span><br><span class="line">127.0.0.1:6379&gt; xack codehole cg1 1527851493405-0 1527851498956-0 1527852774092-0 1527854062442-0</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1</span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># pel空了</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 745505</span><br></pre></td></tr></table></figure><h4 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h4><p>Stream提供了XINFO来实现对服务器信息的监控，可以查询：</p><h4 id="Stream深入理解"><a href="#Stream深入理解" class="headerlink" title="Stream深入理解"></a>Stream深入理解</h4><h5 id="Stream用在什么样场景"><a href="#Stream用在什么样场景" class="headerlink" title="Stream用在什么样场景"></a>Stream用在什么样场景</h5><p>可用作时通信等，大数据分析，异地数据备份等</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-4.png" alt="img"></p><p>客户端可以平滑扩展，提高处理能力</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-5.png" alt="img"></p><h5 id="消息ID的设计"><a href="#消息ID的设计" class="headerlink" title="消息ID的设计"></a>消息ID的设计</h5><p>由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>可以通过multi批处理，来验证序号的递增：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg one</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg two</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg three</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg four</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg five</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) <span class="string">&quot;1553441006884-0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1553441006884-1&quot;</span></span><br><span class="line">3) <span class="string">&quot;1553441006884-2&quot;</span></span><br><span class="line">4) <span class="string">&quot;1553441006884-3&quot;</span></span><br><span class="line">5) <span class="string">&quot;1553441006884-4&quot;</span></span><br></pre></td></tr></table></figure><p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p><p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p><p><strong>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！</strong></p><h5 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h5><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>消费者处理完毕了消息需要使用命令 XACK 完成告知消息处理完成</p><p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。</p><h5 id="消费者彻底宕机后如何转移给其它消费者处理"><a href="#消费者彻底宕机后如何转移给其它消费者处理" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理"></a>消费者彻底宕机后如何转移给其它消费者处理</h5><p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法<strong>XCLAIM</strong>来实现，需要<strong>设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h5 id="Dead-Letter，死信问题"><a href="#Dead-Letter，死信问题" class="headerlink" title="Dead Letter，死信问题"></a>Dead Letter，死信问题</h5><p>如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除队列中的消息</span></span><br><span class="line">127.0.0.1:6379&gt; XDEL mq 1553585533795-1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查看队列中再无此消息</span></span><br><span class="line">127.0.0.1:6379&gt; XRANGE mq - +</span><br><span class="line">1) 1) <span class="string">&quot;1553585533795-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;msg&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1553585533795-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;msg&quot;</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意本例中，并没有删除Pending中的消息因此你查看Pending，消息还会在。可以执行XACK标识其处理完毕！</p></blockquote><h2 id="Redis底层结构"><a href="#Redis底层结构" class="headerlink" title="Redis底层结构"></a>Redis底层结构</h2><p>redis底层设计：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-2-2.png" alt="img"></p><ul><li><strong>对象设计机制</strong>: 对象结构(redisObject)</li><li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li></ul><h3 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h3><h4 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h4><p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>下图对应上面的结构</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-1.png" alt="img"></p><p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p><ul><li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1 <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2 <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3 <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4 <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 注意：版本2.6后不再使用. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象</li></ul><p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p><p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p><p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><h4 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h4><blockquote><p>那么Redis是如何处理一条命令的呢？</p></blockquote><p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p><ul><li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li><li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li><li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li><li>返回数据结构的操作结果作为命令的返回值。</li></ul><p>比如现在执行LPOP命令：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-3.png" alt="img"></p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><blockquote><p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p></blockquote><p><strong>redis预分配的值对象如下</strong>：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-4.png" alt="img"></p><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等自勉之的内存数据结构</p></blockquote><p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p><ul><li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li><li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li><li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li><li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li></ul><p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的</p><h4 id="引用计数以及对象的消毁"><a href="#引用计数以及对象的消毁" class="headerlink" title="引用计数以及对象的消毁"></a>引用计数以及对象的消毁</h4><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li><li>当新创建一个对象时，它的refcount属性被设置为1；</li><li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li><li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-2-3.png" alt="img"></p><p>底层数据结构部分：</p><ul><li>简单动态字符串 - sds</li><li>压缩列表 - ZipList</li><li>快表 - QuickList</li><li>字典/哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList</li></ul><h4 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h4><p>Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p><ul><li><strong>SDS的总体概览</strong>如下图:</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-3.png" alt="img"></p><p>其中<code>sdshdr</code>是头部, <code>buf</code>是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 <code>&quot;数据&quot; + &quot;\0&quot;</code>是为所谓的buf。</p><p>通过上图我们可以看到，SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-2.png" alt="img"></p><p>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li></ul><h5 id="为什么使用SDS"><a href="#为什么使用SDS" class="headerlink" title="为什么使用SDS"></a>为什么使用SDS</h5><blockquote><p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p></blockquote><ul><li><strong>常数复杂度获取字符串长度</strong></li></ul><p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p><ul><li><strong>杜绝缓冲区溢出</strong></li></ul><p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p><ul><li><strong>减少修改字符串的内存重新分配次数</strong></li></ul><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p><p>1、<code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p><p>2、<code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p><ul><li><strong>二进制安全</strong></li></ul><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p><ul><li><strong>兼容部分 C 字符串函数</strong></li></ul><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h&gt;</code> 中的一部分函数。</p><h4 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h4><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p><p>整个ziplist在内存中的存储格式如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-6.png" alt="img"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h5 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h5><p>一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p><p><code>prevlen</code>：前一个entry的大小；</p><p><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</p><p><code>entry-data</code>：真是用于存储entry表示的数据；</p><h5 id="为什么ZipList特别省内存"><a href="#为什么ZipList特别省内存" class="headerlink" title="为什么ZipList特别省内存"></a>为什么ZipList特别省内存</h5><blockquote><p>所以只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p></blockquote><ul><li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li><li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li><li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li></ul><p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p><h5 id="ziplist的缺点"><a href="#ziplist的缺点" class="headerlink" title="ziplist的缺点"></a>ziplist的缺点</h5><p>最后我们再看看它的一些缺点：</p><ul><li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li><li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节. <strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>. 虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算. 但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了. 之所以说这是一个蛋疼问题, 是因为, 这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li></ul><h4 id="快表-QuickList"><a href="#快表-QuickList" class="headerlink" title="快表 - QuickList"></a>快表 - QuickList</h4><p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p><h5 id="quicklist内存布局图"><a href="#quicklist内存布局图" class="headerlink" title="quicklist内存布局图"></a>quicklist内存布局图</h5><p>quicklist的内存布局图如下所示:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-4.png" alt="img"></p><p>quicklist有自己的优点， 也有缺点， 对于使用者来说, 其使用体验类似于线性数据结构， list作为最传统的双链表, 结点通过指针持有数据， 指针字段会耗费大量内存。 ziplist解决了耗费内存这个问题， 但引入了新的问题： 每次写操作整个ziplist的内存都需要重分配。 quicklist在两者之间做了一个平衡， 并且使用者可以通过自定义<code>quicklist.fill</code>, 根据实际业务情况, 经验主义调参。</p><h4 id="字典-哈希表-Dict"><a href="#字典-哈希表-Dict" class="headerlink" title="字典/哈希表 - Dict"></a>字典/哈希表 - Dict</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><strong>哈希表结构定义</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于 size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure><p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="type">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="type">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure><p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p><p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-13.png" alt="img"></p><h5 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h5><ul><li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line"><span class="built_in">hash</span> = dict-&gt;<span class="built_in">type</span>-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span></span><br><span class="line">index = <span class="built_in">hash</span> &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><ul><li><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</li><li><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</li></ul><p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p><p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p><p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p><ul><li><strong>触发扩容的条件</strong>：</li></ul><p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p><p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p><p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p><ul><li><strong>渐近式 rehash</strong></li></ul><p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p><h4 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h4><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p><p>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</p><h5 id="intset结构"><a href="#intset结构" class="headerlink" title="intset结构"></a>intset结构</h5><p>首先看源码结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p><p><code>length</code> 代表其中存储的整数的个数</p><p><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p><h5 id="内存布局图"><a href="#内存布局图" class="headerlink" title="内存布局图"></a>内存布局图</h5><p>其内存布局如下图所示</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-8.png" alt="img"></p><p>我们可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p><h4 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h4><p>作为有序列表 (Zset) 的使用。</p><p>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p><p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-9.png" alt="img"></p><p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-10.png" alt="img"></p><ul><li><strong>skiplist与平衡树、哈希表的比较</strong></li></ul><p>来源于：<a href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p>查找单个key，skiplist和平衡树的时间复杂度都为<strong>O(log n)</strong>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p><p>跳表的删除和添加的时间复杂度都为O(log n)</p><p>从算法实现难度上来比较，skiplist比平衡树要简单得多</p><h2 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h2><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><p>Redis 的 <code>EXPIRE</code> 命令可以指定一个键的过期时间，当达到过期时间后，Redis 会自动删除该键。</p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PERSIST</code></td><td><code>PERSIST key-name</code>—移除键的过期时间</td></tr><tr><td><code>TTL</code></td><td><code>TTL key-name</code>—查看给定键距离过期还有多少秒</td></tr><tr><td><code>EXPIRE</code></td><td><code>EXPIRE key-name seconds</code>—让给定键在指定的秒数之后过期</td></tr><tr><td><code>EXPIREAT</code></td><td><code>EXPIREAT key-name timestamp</code>—将给定键的过期时间设置为给定的 UNIX 时间戳</td></tr><tr><td><code>PTTL</code></td><td><code>PTTL key-name</code>—查看给定键距离过期时间还有多少毫秒（这个命令在 Redis 2.6 或以上版本可用）</td></tr><tr><td><code>PEXPIRE</code></td><td><code>PEXPIRE key-name milliseconds</code>—让给定键在指定的毫秒数之后过期（这个命令在 Redis 2.6 或以上版本可用）</td></tr><tr><td><code>PEXPIREAT</code></td><td><code>PEXPIREAT key-name timestamp-milliseconds</code>—将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间（这个命令在 Redis 2.6 或以上版本可用）</td></tr></tbody></table></div><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。</strong></p><h3 id="过期检查"><a href="#过期检查" class="headerlink" title="过期检查"></a>过期检查</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-expired-dictionary.png" alt="redis过期字典"></p><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>对Key的删除：</p><ol><li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>Redis采用的是定期删除+惰性/懒汉式删除</p><p>惰性删除：在访问或者修改key之前，检查key是否过期</p><p>定期删除：从过期字典中随机抽取20个Key，检查这20个Key是否过期，并删除已过期的key。如果已过期的key超过25%，则继续重复抽取20个Key，继续循环。</p><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。00</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术之 CDN</title>
      <link href="/mingyry/238ee950.html"/>
      <url>/mingyry/238ee950.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络技术之-CDN"><a href="#网络技术之-CDN" class="headerlink" title="网络技术之 CDN"></a>网络技术之 CDN</h1><p>文章来源：<a href="https://gitee.com/turnon/blog/blob/master/source/_posts/13.%E7%BD%91%E7%BB%9C/03.%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/02.CDN.md">https://gitee.com/turnon/blog/blob/master/source/_posts/13.%E7%BD%91%E7%BB%9C/03.%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/02.CDN.md</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-d4ab223ee51aaeaa24c85271721de10e_720w.webp" alt="img"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h3><p>CDN(<strong>Content Delivery Network</strong>)，即<strong>内容分发网络</strong>。</p><p>CDN 是一个全球性的代理服务器分布式网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。CDN 的 DNS 解析会告知客户端连接哪台服务器。CDN 的关键技术主要有内容存储和分发技术。</p><h3 id="CDN-的优缺点"><a href="#CDN-的优缺点" class="headerlink" title="CDN 的优缺点"></a>CDN 的优缺点</h3><ul><li>优点<ul><li><strong>访问加速</strong> - 由于 CDN 就近服务，大大降低了网络传播时延，所以自然提高了访问速度。</li><li><strong>降低负载</strong> - 如果 CDN 已经能获取数据，那么就不必请求源站，这自然降低了源站（服务器）的负载。</li></ul></li><li>缺点<ul><li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li><li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li><li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li></ul></li></ul><h2 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h2><p>CDN 的基本原理是：</p><ul><li>广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中；</li><li>在用户访问网站时，实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息来选择最佳缓存服务器；</li><li>然后，将用户的请求重新导向最佳的缓存服务器上，由缓存服务器直接响应用户请求。</li></ul><p>CDN 网络架构主要由两大部分，分为<strong>中心</strong>和<strong>边缘</strong>两部分：</p><ul><li>中心指 CDN 网管中心和 DNS 重定向解析中心，负责全局负载均衡，设备系统安装在管理中心机房；</li><li>边缘主要指异地节点，CDN 分发的载体，主要由 Cache 和负载均衡器等组成。</li></ul><p>CDN 是一个策略性部署的整体系统，包括<strong>分布式存储</strong>、<strong>负载均衡</strong>、<strong>内容管理</strong>和<strong>网络请求的重定向</strong>４个要件。</p><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>CDN 网络将存储资源分布到各个地理位置、各个网段。存储系统作为 CDN 系统密不可分的一部分，将 CDN 分发的文件和数据库表记录内容存储起来，提供持续服务。存储系统采用三级存储架构，包括核心存储、CDN 服务节点分布式缓存和终端本地缓存。任意一个点的存储崩溃或失效，并不影响系统服务的可用性。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/201212182141328438.jpg" alt="clip_image002[4]"></p><p>如 CDN 系统在 5 大运营商（中国电信、中国网通、中国铁通、中国移动、中国联通）以及 2 大专有网络（中国教育和科研计算机网、中国科技网）都布有 CDN 节点。<strong>这样就消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。</strong></p><h3 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h3><p>内容管理和全局的网络流量管理(Traffic Management)是 CDN 的核心所在。<strong>通过用户就近性和服务器负载的判断，CDN 确保内容以一种极为高效的方式为用户的请求提供服务</strong>。总的来说，内容服务基于<strong>缓存服务器</strong>，也称作<strong>代理缓存(Surrogate)</strong>，它位于网络的边缘，距用户仅有”一跳”(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于 CDN 服务提供商的数据中心）的一个透明镜像。这样的架构使得 CDN 服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。据统计，采用 CDN 技术，能处理整个网站页面的 70%～ 95％的内容访问量，减轻服务器的压力，提升了网站的性能和可扩展性。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>CDN 负载均衡系统实现 CDN 的<strong>内容路由功能</strong>。它的作用是将用户的请求导向整个 CDN 网络中的最佳节点。最佳节点的选定可以根据多种策略，例如<strong>距离最近</strong>、<strong>节点负载最轻</strong>等。负载均衡系统是整个 CDN 的核心，负载均衡的准确性和效率直接决定了整个 CDN 的效率和性能。通常负载均衡可以分为两个层次：<strong>全局负载均衡（GSLB）和\本地负载均衡（SLB）</strong>。</p><h3 id="网络请求的重定向"><a href="#网络请求的重定向" class="headerlink" title="网络请求的重定向"></a>网络请求的重定向</h3><p>当用户访问了使用 CDN 服务的资源时，DNS 域名服务器通过 CNAME 方式将最终域名请求重定向到 CDN 系统中的智能 DNS 负载均衡系统。<strong>智能 DNS 负载均衡系统通过一组预先定义好的策略（如内容类型、地理区域、网络负载状况等），将当时能够最快响应用户的节点地址提供给用户，使用户可以得到快速的服务</strong>。</p><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.cnblogs.com%2Fskynet%2Farchive%2F2012%2F12%2F18%2F2824141.html">CDN-内容推送网络</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F39028766">闲话 CDN</a></li></ul></blockquote><h2 id="CDN-访问流程"><a href="#CDN-访问流程" class="headerlink" title="CDN 访问流程"></a>CDN 访问流程</h2><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/201212182141332832.jpg" alt="clip_image003[4]"></p><ol><li>用户在浏览器中访问域名，域名解析的请求被发往网站的 DNS 域名解析服务器；</li><li>由于网站的 DNS 域名解析服务器对此域名的解析设置了 CNAME，请求被指向 CDN 网络中的智能 DNS 负载均衡系统；</li><li>智能 DNS 负载均衡系统对域名进行智能解析，将响应速度最快的节点 IP 返回给用户；浏览器在得到速度最快节点的 IP 地址以后，向 CDN 节点发出访问请求；</li><li>由于是第一次访问，CDN 节点将回到源站取用户请求的数据并发给用户；</li><li>当有其他用户再次访问同样内容时，CDN 将直接将数据返回给客户，完成请求/服务过程。</li></ol><p>同时，它还与分布在不同地点的所有 CDN 节点保持通信，搜集各节点的健康状态，确保不将用户的请求分配到任何一个已经不可用的节点上。</p><blockquote><p>参考：</p><ul><li><a href="https://gitee.com/link?target=https%3A%2F%2Fwww.cnblogs.com%2Fskynet%2Farchive%2F2012%2F12%2F18%2F2824141.html">CDN-内容推送网络</a></li><li><a href="https://gitee.com/link?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F39028766">闲话 CDN</a></li></ul></blockquote><h2 id="推送和拉取"><a href="#推送和拉取" class="headerlink" title="推送和拉取"></a>推送和拉取</h2><p>CDN 服务有推送和拉取两种方式：</p><h3 id="CDN-推送"><a href="#CDN-推送" class="headerlink" title="CDN 推送"></a>CDN 推送</h3><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p><p>优点在于节省源站带宽，提前将要分发的内容放到 CDN 节点上了，当某个流量高峰来临时，不会把你的源站带宽占满（源站还要留点带宽提供动态 HTML 啊）。</p><p>缺点是需要针对 CDN 做接口开发，在被分发内容生成时主动上传给 CDN。</p><h3 id="CDN-拉取"><a href="#CDN-拉取" class="headerlink" title="CDN 拉取"></a>CDN 拉取</h3><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p><p><a href="https://gitee.com/link?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTime_to_live">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p><p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p><p>优点在于实现简单。</p><blockquote><p>参考：<a href="https://gitee.com/link?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000000119794">推送式与拉取式 CDN 服务的优劣问题</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-面试相关</title>
      <link href="/mingyry/f35148c1.html"/>
      <url>/mingyry/f35148c1.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-面试相关"><a href="#计算机网络-面试相关" class="headerlink" title="计算机网络-面试相关"></a>计算机网络-面试相关</h2><h3 id="TCP-IP-网络模型有哪几层？"><a href="#TCP-IP-网络模型有哪几层？" class="headerlink" title="TCP/IP 网络模型有哪几层？"></a>TCP/IP 网络模型有哪几层？</h3><p>TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421104307197.png" alt="image-20230421104307197"></p><p>每一层的封装格式：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421104347421.png" alt="image-20230421104347421" style="zoom:67%;" /></p><h3 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-f744dc30445c9b5b449f7f5f64f3fb4f_720w.webp" alt="https://zhuanlan.zhihu.com/p/144358305"></p><h3 id="键入网址到网页显示，背后会进行哪些技术步骤？"><a href="#键入网址到网页显示，背后会进行哪些技术步骤？" class="headerlink" title="键入网址到网页显示，背后会进行哪些技术步骤？"></a>键入网址到网页显示，背后会进行哪些技术步骤？</h3><ol><li><p>浏览器做的第一步工作是解析 URL，而生成发送给 <code>Web</code> 服务器的请求信息。</p></li><li><p>利用DNS<strong>查询服务器域名对应的 IP 地址</strong></p></li><li>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421104752208.png" alt="image-20230421104752208"></p><ol><li><p>利用 TCP 或 UDP 进行数据传输</p><ul><li>TCP 传输数据之前，要先三次握手建立连接</li></ul></li><li><p>委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p><ul><li>源地址IP，即是客户端输出的 IP 地址；</li><li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p></li><li><p>接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>（MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>）。</p><p><code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p></li><li><p><strong>网卡</strong>会将包转为电信号，通过网线发送出去。</p></li><li><p>通过交换机将网络包<strong>原样</strong>转发到目的地</p><p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p></li><li><p>到达路由器，并且再次转发到下一个路由器或者目标主机</p></li><li><p>服务器 与 客户端互相拆解包</p><ul><li><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p></li><li><p>客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面</p></li></ul></li></ol><h3 id="说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="说一下一次完整的HTTP请求过程包括哪些内容？"></a>说一下一次完整的HTTP请求过程包括哪些内容？</h3><p>DNS域名解析 —&gt; 发起TCP的3次握手 —&gt; 建立TCP连接后发起http请求 —&gt; 服务器响应http请求，浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） —&gt; 浏览器对页面进行渲染呈现给用户。</p><h3 id="“请问公网服务器的-Mac-地址是在什么时机通过什么方式获取到的？我看-ARP-获取-Mac-地址只能获取到内网机器的-Mac-地址吧？”"><a href="#“请问公网服务器的-Mac-地址是在什么时机通过什么方式获取到的？我看-ARP-获取-Mac-地址只能获取到内网机器的-Mac-地址吧？”" class="headerlink" title="“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 ARP 获取 Mac 地址只能获取到内网机器的 Mac 地址吧？”"></a>“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 ARP 获取 Mac 地址只能获取到内网机器的 Mac 地址吧？”</h3><p>在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p><p>转发的过程中，源 IP 地址和目标 IP 地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p><h3 id="GET-和-POST-的区别，你知道哪些？"><a href="#GET-和-POST-的区别，你知道哪些？" class="headerlink" title="GET 和 POST 的区别，你知道哪些？"></a>GET 和 POST 的区别，你知道哪些？</h3><ol><li>get是获取数据，post是修改数据</li><li>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</li><li>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</li><li>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li>本质区别：GET是幂等的，而POST不是幂等的</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://interviewguide.cn/">https://interviewguide.cn/</a>    </p><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命名规范</title>
      <link href="/mingyry/1761bce2.html"/>
      <url>/mingyry/1761bce2.html</url>
      
        <content type="html"><![CDATA[<h1 id="java命名规范"><a href="#java命名规范" class="headerlink" title="java命名规范"></a>java命名规范</h1><h2 id="Java-中的命名规范"><a href="#Java-中的命名规范" class="headerlink" title="Java 中的命名规范"></a>Java 中的命名规范</h2><p><strong>类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">约束</th><th style="text-align:center">例</th></tr></thead><tbody><tr><td style="text-align:center">项目名</td><td style="text-align:center">全部小写，多个单词用中划线分隔‘-’</td><td style="text-align:center">spring-cloud</td></tr><tr><td style="text-align:center">包名</td><td style="text-align:center">全部小写</td><td style="text-align:center">com.alibaba.fastjson</td></tr><tr><td style="text-align:center">类名</td><td style="text-align:center">单词首字母大写</td><td style="text-align:center">Feature, ParserConfig,DefaultFieldDeserializer</td></tr><tr><td style="text-align:center">变量名</td><td style="text-align:center">首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td><td style="text-align:center">password, userName</td></tr><tr><td style="text-align:center">常量名</td><td style="text-align:center">全部大写，多个单词，用’_’分隔</td><td style="text-align:center">CACHE_EXPIRED_TIME</td></tr><tr><td style="text-align:center">方法</td><td style="text-align:center">同变量</td><td style="text-align:center">read(), readObject(), getById()</td></tr></tbody></table></div><h2 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h2><p><strong>包名</strong>统一使用<strong>小写</strong>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace 不需要使用任何分割）。包名统一使用单数形式，如果类名有复数含义，则可以使用复数形式。</p><p>包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀名</th><th style="text-align:center">例</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">indi（或 onem ）</td><td style="text-align:center">indi.发起者名.项目名.模块名.……</td><td style="text-align:center">个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright 主要属于发起者。</td></tr><tr><td style="text-align:center">pers</td><td style="text-align:center">pers.个人名.项目名.模块名.……</td><td style="text-align:center">个人项目，指个人发起，独自完成，可分享的项目，copyright 主要属于个人</td></tr><tr><td style="text-align:center">priv</td><td style="text-align:center">priv.个人名.项目名.模块名.……</td><td style="text-align:center">私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright 属于个人。</td></tr><tr><td style="text-align:center">team</td><td style="text-align:center">team.团队名.项目名.模块名.……</td><td style="text-align:center">团队项目，指由团队发起，并由该团队开发的项目，copyright 属于该团队所有</td></tr><tr><td style="text-align:center">顶级域名</td><td style="text-align:center">com.公司名.项目名.模块名.……</td><td style="text-align:center">公司项目，copyright 由项目发起的公司所有</td></tr></tbody></table></div><h2 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h2><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以 Test 结尾，如 HashMapTest。</p><p>对于一些特殊特有名词缩写也可以使用全大写命名，比如 XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中 fastjson 用 JSONObject 作为类命，而 google 则使用 JsonObjectRequest 命名，对于这种特殊的缩写，原则是统一就好。</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">约束</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">抽象类</td><td style="text-align:left">Abstract 或者 Base 开头</td><td style="text-align:left">BaseUserService</td></tr><tr><td style="text-align:left">枚举类</td><td style="text-align:left">Enum 作为后缀</td><td style="text-align:left">GenderEnum</td></tr><tr><td style="text-align:left">工具类</td><td style="text-align:left">Utils 作为后缀</td><td style="text-align:left">StringUtils</td></tr><tr><td style="text-align:left">异常类</td><td style="text-align:left">Exception 结尾</td><td style="text-align:left">RuntimeException</td></tr><tr><td style="text-align:left">接口实现类</td><td style="text-align:left">接口名+ Impl</td><td style="text-align:left">UserServiceImpl</td></tr><tr><td style="text-align:left">领域模型相关</td><td style="text-align:left">/DO/DTO/VO/DAO</td><td style="text-align:left">正例：UserDAO 反例：UserDo， UserDao</td></tr><tr><td style="text-align:left">设计模式相关类</td><td style="text-align:left">Builder，Factory 等</td><td style="text-align:left">当使用到设计模式时，需要使用对应的设计模式作为后缀，如 ThreadFactory</td></tr><tr><td style="text-align:left">处理特定功能的</td><td style="text-align:left">Handler，Predicate, Validator</td><td style="text-align:left">表示处理器，校验器，断言，这些类工厂还有配套的方法名如 handle，predicate，validate</td></tr><tr><td style="text-align:left">测试类</td><td style="text-align:left">Test 结尾</td><td style="text-align:left">UserServiceTest， 表示用来测试 UserService 类的</td></tr><tr><td style="text-align:left">MVC 分层</td><td style="text-align:left">Controller，Service，ServiceImpl，DAO 后缀</td><td style="text-align:left">UserManageController，UserManageDAO</td></tr></tbody></table></div><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p><h3 id="4-1-返回真伪值的方法"><a href="#4-1-返回真伪值的方法" class="headerlink" title="4.1 返回真伪值的方法"></a>4.1 返回真伪值的方法</h3><p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p><div class="table-container"><table><thead><tr><th style="text-align:left">位置</th><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">Prefix</td><td style="text-align:left">is</td><td style="text-align:left">对象是否符合期待的状态</td><td style="text-align:left">isValid</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">can</td><td style="text-align:left">对象<strong>能否执行</strong>所期待的动作</td><td style="text-align:left">canRemove</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">should</td><td style="text-align:left">调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td><td style="text-align:left">shouldMigrate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">has</td><td style="text-align:left">对象<strong>是否持有</strong>所期待的数据和属性</td><td style="text-align:left">hasObservers</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">needs</td><td style="text-align:left">调用方<strong>是否需要</strong>执行某个命令或方法</td><td style="text-align:left">needsMigrate</td></tr></tbody></table></div><h3 id="4-2-用来检查的方法"><a href="#4-2-用来检查的方法" class="headerlink" title="4.2 用来检查的方法"></a>4.2 用来检查的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">ensure</td><td style="text-align:left">检查是否为期待的状态，不是则抛出异常或返回 error code</td><td style="text-align:left">ensureCapacity</td></tr><tr><td style="text-align:left">validate</td><td style="text-align:left">检查是否为正确的状态，不是则抛出异常或返回 error code</td><td style="text-align:left">validateInputs</td></tr></tbody></table></div><h3 id="4-3-按需求才执行的方法"><a href="#4-3-按需求才执行的方法" class="headerlink" title="4.3 按需求才执行的方法"></a>4.3 按需求才执行的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">位置</th><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">Suffix</td><td style="text-align:left">IfNeeded</td><td style="text-align:left">需要的时候执行，不需要的时候什么都不做</td><td style="text-align:left">drawIfNeeded</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">might</td><td style="text-align:left">同上</td><td style="text-align:left">mightCreate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">try</td><td style="text-align:left">尝试执行，失败时抛出异常或是返回 error code</td><td style="text-align:left">tryCreate</td></tr><tr><td style="text-align:left">Suffix</td><td style="text-align:left">OrDefault</td><td style="text-align:left">尝试执行，失败时返回默认值</td><td style="text-align:left">getOrDefault</td></tr><tr><td style="text-align:left">Suffix</td><td style="text-align:left">OrElse</td><td style="text-align:left">尝试执行、失败时返回实际参数中指定的值</td><td style="text-align:left">getOrElse</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">force</td><td style="text-align:left">强制尝试执行。error 抛出异常或是返回值</td><td style="text-align:left">forceCreate, forceStop</td></tr></tbody></table></div><h3 id="4-4-异步相关方法"><a href="#4-4-异步相关方法" class="headerlink" title="4.4 异步相关方法"></a>4.4 异步相关方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">位置</th><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">Prefix</td><td style="text-align:left">blocking</td><td style="text-align:left">线程阻塞方法</td><td style="text-align:left">blockingGetUser</td></tr><tr><td style="text-align:left">Suffix</td><td style="text-align:left">InBackground</td><td style="text-align:left">执行在后台的线程</td><td style="text-align:left">doInBackground</td></tr><tr><td style="text-align:left">Suffix</td><td style="text-align:left">Async</td><td style="text-align:left">异步方法</td><td style="text-align:left">sendAsync</td></tr><tr><td style="text-align:left">Suffix</td><td style="text-align:left">Sync</td><td style="text-align:left">对应已有异步方法的同步方法</td><td style="text-align:left">sendSync</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">schedule</td><td style="text-align:left">Job 和 Task 放入队列</td><td style="text-align:left">schedule, scheduleJob</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">post</td><td style="text-align:left">同上</td><td style="text-align:left">postJob</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">execute</td><td style="text-align:left">执行异步方法（注：我一般拿这个做同步方法名）</td><td style="text-align:left">execute, executeTask</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">start</td><td style="text-align:left">同上</td><td style="text-align:left">start, startJob</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">cancel</td><td style="text-align:left">停止异步方法</td><td style="text-align:left">cancel, cancelJob</td></tr><tr><td style="text-align:left">Prefix or Alone</td><td style="text-align:left">stop</td><td style="text-align:left">同上</td><td style="text-align:left">stop, stopJob</td></tr></tbody></table></div><h3 id="4-5-回调方法"><a href="#4-5-回调方法" class="headerlink" title="4.5 回调方法"></a>4.5 回调方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">位置</th><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">Prefix</td><td style="text-align:left">on</td><td style="text-align:left">事件发生时执行</td><td style="text-align:left">onCompleted</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">before</td><td style="text-align:left">事件发生前执行</td><td style="text-align:left">beforeUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">pre</td><td style="text-align:left">同上</td><td style="text-align:left">preUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">will</td><td style="text-align:left">同上</td><td style="text-align:left">willUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">after</td><td style="text-align:left">事件发生后执行</td><td style="text-align:left">afterUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">post</td><td style="text-align:left">同上</td><td style="text-align:left">postUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">did</td><td style="text-align:left">同上</td><td style="text-align:left">didUpdate</td></tr><tr><td style="text-align:left">Prefix</td><td style="text-align:left">should</td><td style="text-align:left">确认事件是否可以发生时执行</td><td style="text-align:left">shouldUpdate</td></tr></tbody></table></div><h3 id="4-6-操作对象生命周期的方法"><a href="#4-6-操作对象生命周期的方法" class="headerlink" title="4.6 操作对象生命周期的方法"></a>4.6 操作对象生命周期的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">initialize</td><td style="text-align:left">初始化。也可作为延迟初始化使用</td><td style="text-align:left">initialize</td></tr><tr><td style="text-align:left">pause</td><td style="text-align:left">暂停</td><td style="text-align:left">onPause ，pause</td></tr><tr><td style="text-align:left">stop</td><td style="text-align:left">停止</td><td style="text-align:left">onStop，stop</td></tr><tr><td style="text-align:left">abandon</td><td style="text-align:left">销毁的替代</td><td style="text-align:left">abandon</td></tr><tr><td style="text-align:left">destroy</td><td style="text-align:left">同上</td><td style="text-align:left">destroy</td></tr><tr><td style="text-align:left">dispose</td><td style="text-align:left">同上</td><td style="text-align:left">dispose</td></tr></tbody></table></div><h3 id="4-7-与集合操作相关的方法"><a href="#4-7-与集合操作相关的方法" class="headerlink" title="4.7 与集合操作相关的方法"></a>4.7 与集合操作相关的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">contains</td><td style="text-align:left">是否持有与指定对象相同的对象</td><td style="text-align:left">contains</td></tr><tr><td style="text-align:left">add</td><td style="text-align:left">添加</td><td style="text-align:left">addJob</td></tr><tr><td style="text-align:left">append</td><td style="text-align:left">添加</td><td style="text-align:left">appendJob</td></tr><tr><td style="text-align:left">insert</td><td style="text-align:left">插入到下标 n</td><td style="text-align:left">insertJob</td></tr><tr><td style="text-align:left">put</td><td style="text-align:left">添加与 key 对应的元素</td><td style="text-align:left">putJob</td></tr><tr><td style="text-align:left">remove</td><td style="text-align:left">移除元素</td><td style="text-align:left">removeJob</td></tr><tr><td style="text-align:left">enqueue</td><td style="text-align:left">添加到队列的最末位</td><td style="text-align:left">enqueueJob</td></tr><tr><td style="text-align:left">dequeue</td><td style="text-align:left">从队列中头部取出并移除</td><td style="text-align:left">dequeueJob</td></tr><tr><td style="text-align:left">push</td><td style="text-align:left">添加到栈头</td><td style="text-align:left">pushJob</td></tr><tr><td style="text-align:left">pop</td><td style="text-align:left">从栈头取出并移除</td><td style="text-align:left">popJob</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">从栈头取出但不移除</td><td style="text-align:left">peekJob</td></tr><tr><td style="text-align:left">find</td><td style="text-align:left">寻找符合条件的某物</td><td style="text-align:left">findById</td></tr></tbody></table></div><h3 id="4-8-与数据相关的方法"><a href="#4-8-与数据相关的方法" class="headerlink" title="4.8 与数据相关的方法"></a>4.8 与数据相关的方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">意义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">create</td><td style="text-align:left">新创建</td><td style="text-align:left">createAccount</td></tr><tr><td style="text-align:left">new</td><td style="text-align:left">新创建</td><td style="text-align:left">newAccount</td></tr><tr><td style="text-align:left">from</td><td style="text-align:left">从既有的某物新建，或是从其他的数据新建</td><td style="text-align:left">fromConfig</td></tr><tr><td style="text-align:left">to</td><td style="text-align:left">转换</td><td style="text-align:left">toString</td></tr><tr><td style="text-align:left">update</td><td style="text-align:left">更新既有某物</td><td style="text-align:left">updateAccount</td></tr><tr><td style="text-align:left">load</td><td style="text-align:left">读取</td><td style="text-align:left">loadAccount</td></tr><tr><td style="text-align:left">fetch</td><td style="text-align:left">远程读取</td><td style="text-align:left">fetchAccount</td></tr><tr><td style="text-align:left">delete</td><td style="text-align:left">删除</td><td style="text-align:left">deleteAccount</td></tr><tr><td style="text-align:left">remove</td><td style="text-align:left">删除</td><td style="text-align:left">removeAccount</td></tr><tr><td style="text-align:left">save</td><td style="text-align:left">保存</td><td style="text-align:left">saveAccount</td></tr><tr><td style="text-align:left">store</td><td style="text-align:left">保存</td><td style="text-align:left">storeAccount</td></tr><tr><td style="text-align:left">commit</td><td style="text-align:left">保存</td><td style="text-align:left">commitChange</td></tr><tr><td style="text-align:left">apply</td><td style="text-align:left">保存或应用</td><td style="text-align:left">applyChange</td></tr><tr><td style="text-align:left">clear</td><td style="text-align:left">清除数据或是恢复到初始状态</td><td style="text-align:left">clearAll</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">清除数据或是恢复到初始状态</td><td style="text-align:left">resetAll</td></tr></tbody></table></div><h3 id="4-9-成对出现的动词"><a href="#4-9-成对出现的动词" class="headerlink" title="4.9 成对出现的动词"></a>4.9 成对出现的动词</h3><div class="table-container"><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">get 获取</td><td style="text-align:left">set 设置</td></tr><tr><td style="text-align:left">add 增加</td><td style="text-align:left">remove 删除</td></tr><tr><td style="text-align:left">create 创建</td><td style="text-align:left">destory 移除</td></tr><tr><td style="text-align:left">start 启动</td><td style="text-align:left">stop 停止</td></tr><tr><td style="text-align:left">open 打开</td><td style="text-align:left">close 关闭</td></tr><tr><td style="text-align:left">read 读取</td><td style="text-align:left">write 写入</td></tr><tr><td style="text-align:left">load 载入</td><td style="text-align:left">save 保存</td></tr><tr><td style="text-align:left">create 创建</td><td style="text-align:left">destroy 销毁</td></tr><tr><td style="text-align:left">begin 开始</td><td style="text-align:left">end 结束</td></tr><tr><td style="text-align:left">backup 备份</td><td style="text-align:left">restore 恢复</td></tr><tr><td style="text-align:left">import 导入</td><td style="text-align:left">export 导出</td></tr><tr><td style="text-align:left">split 分割</td><td style="text-align:left">merge 合并</td></tr><tr><td style="text-align:left">inject 注入</td><td style="text-align:left">extract 提取</td></tr><tr><td style="text-align:left">attach 附着</td><td style="text-align:left">detach 脱离</td></tr><tr><td style="text-align:left">bind 绑定</td><td style="text-align:left">separate 分离</td></tr><tr><td style="text-align:left">view 查看</td><td style="text-align:left">browse 浏览</td></tr><tr><td style="text-align:left">edit 编辑</td><td style="text-align:left">modify 修改</td></tr><tr><td style="text-align:left">select 选取</td><td style="text-align:left">mark 标记</td></tr><tr><td style="text-align:left">copy 复制</td><td style="text-align:left">paste 粘贴</td></tr><tr><td style="text-align:left">undo 撤销</td><td style="text-align:left">redo 重做</td></tr><tr><td style="text-align:left">insert 插入</td><td style="text-align:left">delete 移除</td></tr><tr><td style="text-align:left">add 加入</td><td style="text-align:left">append 添加</td></tr><tr><td style="text-align:left">clean 清理</td><td style="text-align:left">clear 清除</td></tr><tr><td style="text-align:left">index 索引</td><td style="text-align:left">sort 排序</td></tr><tr><td style="text-align:left">find 查找</td><td style="text-align:left">search 搜索</td></tr><tr><td style="text-align:left">increase 增加</td><td style="text-align:left">decrease 减少</td></tr><tr><td style="text-align:left">play 播放</td><td style="text-align:left">pause 暂停</td></tr><tr><td style="text-align:left">launch 启动</td><td style="text-align:left">run 运行</td></tr><tr><td style="text-align:left">compile 编译</td><td style="text-align:left">execute 执行</td></tr><tr><td style="text-align:left">debug 调试</td><td style="text-align:left">trace 跟踪</td></tr><tr><td style="text-align:left">observe 观察</td><td style="text-align:left">listen 监听</td></tr><tr><td style="text-align:left">build 构建</td><td style="text-align:left">publish 发布</td></tr><tr><td style="text-align:left">input 输入</td><td style="text-align:left">output 输出</td></tr><tr><td style="text-align:left">encode 编码</td><td style="text-align:left">decode 解码</td></tr><tr><td style="text-align:left">encrypt 加密</td><td style="text-align:left">decrypt 解密</td></tr><tr><td style="text-align:left">compress 压缩</td><td style="text-align:left">decompress 解压缩</td></tr><tr><td style="text-align:left">pack 打包</td><td style="text-align:left">unpack 解包</td></tr><tr><td style="text-align:left">parse 解析</td><td style="text-align:left">emit 生成</td></tr><tr><td style="text-align:left">connect 连接</td><td style="text-align:left">disconnect 断开</td></tr><tr><td style="text-align:left">send 发送</td><td style="text-align:left">receive 接收</td></tr><tr><td style="text-align:left">download 下载</td><td style="text-align:left">upload 上传</td></tr><tr><td style="text-align:left">refresh 刷新</td><td style="text-align:left">synchronize 同步</td></tr><tr><td style="text-align:left">update 更新</td><td style="text-align:left">revert 复原</td></tr><tr><td style="text-align:left">lock 锁定</td><td style="text-align:left">unlock 解锁</td></tr><tr><td style="text-align:left">check out 签出</td><td style="text-align:left">check in 签入</td></tr><tr><td style="text-align:left">submit 提交</td><td style="text-align:left">commit 交付</td></tr><tr><td style="text-align:left">push 推</td><td style="text-align:left">pull 拉</td></tr><tr><td style="text-align:left">expand 展开</td><td style="text-align:left">collapse 折叠</td></tr><tr><td style="text-align:left">begin 起始</td><td style="text-align:left">end 结束</td></tr><tr><td style="text-align:left">start 开始</td><td style="text-align:left">finish 完成</td></tr><tr><td style="text-align:left">enter 进入</td><td style="text-align:left">exit 退出</td></tr><tr><td style="text-align:left">abort 放弃</td><td style="text-align:left">quit 离开</td></tr><tr><td style="text-align:left">obsolete 废弃</td><td style="text-align:left">depreciate 废旧</td></tr><tr><td style="text-align:left">collect 收集</td><td style="text-align:left">aggregate 聚集</td></tr></tbody></table></div><h2 id="变量-amp-常量命名"><a href="#变量-amp-常量命名" class="headerlink" title="变量&amp;常量命名"></a>变量&amp;常量命名</h2><h3 id="5-1-变量命名"><a href="#5-1-变量命名" class="headerlink" title="5.1 变量命名"></a>5.1 变量命名</h3><p>变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。</p><p>变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo 中的布尔变量，都不要加 is(数据库中的布尔字段全都要加 is_ 前缀)。</p><h3 id="5-2-常量命名"><a href="#5-2-常量命名" class="headerlink" title="5.2 常量命名"></a>5.2 常量命名</h3><p>常量命名 CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？</p><p>常量是在作用域内保持不变的值，一般使用 final 进行修饰。一般分为三种，全局常量（public static final 修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jann Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-07 00:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">publicclass HelloWorld &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(正例)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">USER_MESSAGE_CACHE_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(反例，命名不清晰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MESSAGE_CACHE_TIME</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ERROR_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;error message&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentUserId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印 &#123;<span class="doctag">@code</span> message&#125; 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体，局部常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="keyword">final</span> String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量一般都有自己的业务含义,<strong>不要害怕长度过长而进行省略或者缩写</strong>。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。</p><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h2><ol><li>尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例：BeiJing， HangZhou  反例：validateCanShu</li><li>命名过程中尽量不要出现特殊的字符，常量除外。</li><li>尽量不要和 jdk 或者框架中已存在的类重名，也不能使用 java 中的关键字命名。</li><li>妙用介词，如 for(可以用同音的 4 代替), to(可用同音的 2 代替), from, with，of 等。如类名采用 User4RedisDO，方法名 getUserInfoFromRedis，convertJson2Map 等。</li></ol><h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="6-1-注解的原则"><a href="#6-1-注解的原则" class="headerlink" title="6.1 注解的原则"></a>6.1 注解的原则</h3><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p><ol><li>Nothing is strange 没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。</li><li>Less is more 从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据id获取信息【废话注解】</span></span><br><span class="line">getMessageById(id)</span><br></pre></td></tr></table></figure><ol><li>Advance with the time 注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</li></ol><h3 id="6-2-注解格式"><a href="#6-2-注解格式" class="headerlink" title="6.2 注解格式"></a>6.2 注解格式</h3><p>注解大体上可以分为两种，一种是 javadoc 注解，另一种是简单注解。javadoc 注解可以生成 JavaAPI 为外部用户提供有效的支持 javadoc 注解通常在使用 IDEA，或者 Eclipse 等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。</p><h4 id="a-包注解"><a href="#a-包注解" class="headerlink" title="a. 包注解"></a>a. 包注解</h4><p>包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为 package-info.java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 落地也质量检测</span></span><br><span class="line"><span class="comment"> * 1. 用来解决什么问题</span></span><br><span class="line"><span class="comment"> * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 如何实现</span></span><br><span class="line"><span class="comment"> * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：网络环境配置信息&#123;<span class="doctag">@link</span> cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum&#125;目前使用是常规速度，可以根据实际情况进行调整</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cruder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/12/7 20:3 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.mycookies.landingpagecheck;</span><br></pre></td></tr></table></figure><h4 id="b-类注接"><a href="#b-类注接" class="headerlink" title="b. 类注接"></a>b. 类注接</h4><p>javadoc 注解中，每个类都必须有注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (C), 2019-2020, Jann  balabala...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>   类创建者姓名 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>     创建日期 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>  版本号 保持对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="c-属性注解"><a href="#c-属性注解" class="headerlink" title="c. 属性注解"></a>c. 属性注解</h4><p>在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 提示信息 */</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><h4 id="d-方法注释"><a href="#d-方法注释" class="headerlink" title="d. 方法注释"></a>d. 方法注释</h4><p>在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法的详细说明，能干嘛，怎么实现的，注意事项...</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx  参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回结果的说明， 不同情况下会返回怎样的结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="e-构造方法注释"><a href="#e-构造方法注释" class="headerlink" title="e. 构造方法注释"></a>e. 构造方法注释</h4><p>在每个构造方法前面必须加上注释，注释模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法的详细说明</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx  参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：</p><ol><li>枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。</li><li>保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用 1 个空格分隔。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span>;<span class="comment">// 反例：不要使用行尾注释</span></span><br><span class="line"><span class="comment">//反例：换行符与注释之间没有缩进</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 正例：姓名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 多行注释</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 对于不同的逻辑说明，可以用空行分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java命名规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/mingyry/53d0684b.html"/>
      <url>/mingyry/53d0684b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230423090919990.png" alt="image-20230423090919990"></p><ul><li>/bin<ul><li>是Binary的缩写，目录存放着最经常使用的命令</li></ul></li><li>/home<ul><li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</li></ul></li><li>/root<ul><li>该目录为系统管理员，也称作超级权限者的用户主目录</li></ul></li><li>/lib<ul><li>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</li></ul></li><li>/etc<ul><li>所有的系统管理所需要的配置文件和子目录</li></ul></li><li>/usr<ul><li>用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</li></ul></li><li>/boot<ul><li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，<strong>自己安装的别放在这里</strong></li></ul></li><li>/tmp<ul><li>存放一些临时文件</li></ul></li><li>/mnt<ul><li>系统提供该目录是为了让用户临时挂载别的文件系统，可以将外部的存储挂载在/mnt/上</li></ul></li><li>/opt<ul><li>额外安装软件所摆放的目录。比如安装一个mysql数据库，就可以放到这个目录下。默认是空的</li></ul></li><li>/var<ul><li>存放着不断扩充的东西，将经常被修改的目录放在这个目录下。包括各种日志文件</li></ul></li></ul><h2 id="VI-VIM编辑器"><a href="#VI-VIM编辑器" class="headerlink" title="VI/VIM编辑器"></a>VI/VIM编辑器</h2><h3 id="Vim-的模式"><a href="#Vim-的模式" class="headerlink" title="Vim 的模式"></a>Vim 的模式</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>插入模式（Insert mode）\</strong>和*<em>底线命令模式（Last line mode）*</em>。</p><h4 id="1-2-1-命令模式"><a href="#1-2-1-命令模式" class="headerlink" title="1.2.1. 命令模式"></a>1.2.1. 命令模式</h4><p><strong>用户刚刚启动 vi/vim，便进入了命令模式。</strong></p><p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。</p><h4 id="1-2-2-插入模式"><a href="#1-2-2-插入模式" class="headerlink" title="1.2.2. 插入模式"></a>1.2.2. 插入模式</h4><p><strong>在命令模式下按下 <code>i</code> 就进入了输入模式。</strong></p><p>在输入模式下，你可以输入文本内容。</p><h4 id="1-2-3-底线命令模式"><a href="#1-2-3-底线命令模式" class="headerlink" title="1.2.3. 底线命令模式"></a>1.2.3. 底线命令模式</h4><p><strong>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。</strong></p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><h3 id="VIM-学习"><a href="#VIM-学习" class="headerlink" title="VIM 学习"></a>VIM 学习</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><ul><li>启 动 Vim 后，vim 在 <em>Normal</em> 模式下。</li><li>让我们进入 <em>Insert</em> 模式，请按下键 i 。(注：你会看到 vim 左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li><li>此时，你可以输入文本了，就像你用“记事本”一样。</li><li>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</li></ul><blockquote><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出) （注：:w 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong></p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) → 你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（注：退出帮助需要输入:q）</li></ul></blockquote><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><ol><li><p>各种插入模式</p><blockquote><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul></blockquote></li><li><p>简单的移动光标</p><blockquote><ul><li><code>0</code> → 数字零，到行头</li><li><code>^</code> → 到本行第一个不是 blank 字符的位置（所谓 blank 字符就是空格，tab，换行，回车等）</li><li><code>$</code> → 到本行行尾</li><li><code>g_</code> → 到本行最后一个不是 blank 字符的位置。</li><li><code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（注：如果搜索出多个匹配，可按 n 键到下一个）</li></ul></blockquote></li><li><p>拷贝/粘贴</p><p>（注：p/P 都可以，p 是表示在当前位置之后，P 表示在当前位置之前）</p><blockquote><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul></blockquote></li><li><p>Undo/Redo</p><blockquote><ul><li><code>u</code> → undo</li><li><code>&lt;C-r&gt;</code> → redo</li></ul></blockquote></li><li><p>打开/保存/退出/改变文件</p><p>(Buffer)</p><blockquote><ul><li><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li><li><code>:w</code> → 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ 不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（注：我喜欢使用:n 到下一个文件）</li></ul></blockquote></li></ol><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li><code>N&lt;command&gt;</code> → 重复某个命令 N 次</li></ol><h5 id="2-3-1-更好"><a href="#2-3-1-更好" class="headerlink" title="2.3.1. 更好"></a>2.3.1. 更好</h5><p>下面，让我们看一下 vim 是怎么重复自己的：1515G</p><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li><code>N&lt;command&gt;</code> → 重复某个命令 N 次</li></ol><p>下面是一个示例，找开一个文件你可以试试下面的命令：</p><blockquote><ul><li><code>2dd</code> → 删除 2 行</li><li><code>3p</code> → 粘贴文本 3 次</li><li><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</li><li><code>.</code> → 重复上一个命令—— 100 “desu “.</li><li><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM 多聪明啊).</li></ul></blockquote><h5 id="2-3-2-更强"><a href="#2-3-2-更强" class="headerlink" title="2.3.2. 更强"></a>2.3.2. 更强</h5><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p><ol><li><p>N<code>G</code> → 到第 N 行 （注：注意命令中的 G 是大写的，另我一般使用 : N 到第 N 行，如 :137 到第 137 行）</p></li><li><p><code>gg</code> → 到第一行。（注：相当于 1G，或 :1）</p></li><li><p><code>G</code> → 到最后一行。</p></li><li><p>按单词移动：</p><blockquote><ol><li><code>w</code> → 到下一个单词的开头。</li><li><code>e</code> → 到下一个单词的结尾。</li></ol><p>> 如果你认为单词是由默认方式，那么就用小写的 e 和 w。默认上来说，一个单词由字母，数字和下划线组成（注：程序变量）</p><p>> 如果你认为单词是由 blank 字符分隔符，那么你需要使用大写的 E 和 W。（注：程序语句）</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3101171-46f752c581d79057.jpg" alt="img"></p></blockquote></li></ol><p>下面，让我来说说最强的光标移动：</p><blockquote><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul></blockquote><p>相信我，上面这三个命令对程序员来说是相当强大的。</p><h5 id="2-3-3-更快"><a href="#2-3-3-更快" class="headerlink" title="2.3.3. 更快"></a>2.3.3. 更快</h5><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</span><br></pre></td></tr></table></figure><p>例如 <code>0y$</code> 命令意味着：</p><ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul><p>你也可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p><p>你也可以输入 <code>y2/foo</code> 来拷贝 2 个 “foo” 之间的字符串。</p><p>还有很多时间并不一定你就一定要按 y 才会拷贝，下面的命令也会被拷贝：</p><ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li><li>等等</li></ul><p>（注：可视化选择是一个很有意思的命令，你可以先按 v，然后移动光标，你就会看到文本被选择，然后，你可能 d，也可 y，也可以变大写等）</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><h5 id="4-1-在当前行上移动光标-0-fFtT"><a href="#4-1-在当前行上移动光标-0-fFtT" class="headerlink" title="4.1. 在当前行上移动光标: 0 ^ ####fFtT,`;"></a>4.1. 在当前行上移动光标: <code>0</code> <code>^</code> <code>####</code>f<code>F</code>t<code>T</code>,<code>`;</code></h5><blockquote><ul><li><code>0</code> → 到行头</li><li><code>^</code> → 到本行的第一个非 blank 字符</li><li><code>$</code> → 到行尾</li><li><code>g_</code> → 到本行最后一个不是 blank 字符的位置。</li><li><code>fa</code> → 到下一个为 a 的字符处，你也可以 fs 到下一个为 s 的字符。</li><li><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</li><li><code>3fa</code> → 在当前行查找第三个出现的 a。</li><li><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。 <img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3101171-00835b8316330c58.jpg" alt="img"></li></ul></blockquote><p>还有一个很有用的命令是 <code>dt&quot;</code> → 删除所有的内容，直到遇到双引号—— <code>&quot;。</code></p><h5 id="4-2-区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt"><a href="#4-2-区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt" class="headerlink" title="4.2. 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;"></a>4.2. 区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code></h5><p>在 visual 模式下，这些命令很强大，其命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action&gt;a&lt;object&gt;` 和 `&lt;action&gt;i&lt;object&gt;</span><br></pre></td></tr></table></figure><ul><li>action 可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</li><li>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>&#39;、</code> <code>)、</code> <code>&#125;、</code> <code>]。</code></li></ul><p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o</code>的位置。</p><blockquote><ul><li><code>vi&quot;</code> → 会选择 <code>foo</code>.</li><li><code>va&quot;</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>vi)</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>va)</code> → 会选择<code>(&quot;foo&quot;)</code>.</li><li><code>v2i)</code> → 会选择 <code>map (+) (&quot;foo&quot;)</code></li><li><code>v2a)</code> → 会选择 <code>(map (+) (&quot;foo&quot;))</code></li></ul></blockquote><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="查看IP和网关"><a href="#查看IP和网关" class="headerlink" title="查看IP和网关"></a>查看IP和网关</h3><p><strong>修改虚拟网卡Ip</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230423100128521.png" alt="image-20230423100128521" style="zoom: 80%;" /></p><p><strong>查看网关</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230423100226244.png" alt="image-20230423100226244"></p><h2 id="查看-Linux-命令帮助信息"><a href="#查看-Linux-命令帮助信息" class="headerlink" title="查看 Linux 命令帮助信息"></a>查看 Linux 命令帮助信息</h2><ul><li><strong>查看 Shell 内部命令的帮助信息 - 使用 help</strong></li><li>查看命令的简要说明 - 使用 whatis</li><li>查看命令的详细说明 - 使用 info</li><li>查看命令的位置 - 使用 which</li><li>定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径 - 使用 whereis</li><li><strong>查看命令的帮助手册（包含说明、用法等信息） - 使用 man</strong></li><li>只记得部分命令关键字 - 使用 man -k</li></ul><h3 id="命令常见用法"><a href="#命令常见用法" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1. help"></a>2.1. help</h4><blockquote><p>help 命令用于查看 Shell 内部命令的帮助信息。而对于外部命令的帮助信息只能使用 man 或者 info 命令查看。</p><p>参考：<a href="http://man.linuxde.net/help">http://man.linuxde.net/help</a></p></blockquote><h4 id="2-2-whatis"><a href="#2-2-whatis" class="headerlink" title="2.2. whatis"></a>2.2. whatis</h4><blockquote><p>whatis 用于查询一个命令执行什么功能。</p><p>参考：<a href="http://man.linuxde.net/whatis">http://man.linuxde.net/whatis</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 man 命令的简要说明</span></span><br><span class="line">$ whatis man</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看以 loca 开拓的命令的简要说明</span></span><br><span class="line">$ whatis -w <span class="string">&quot;loca*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-info"><a href="#2-3-info" class="headerlink" title="2.3. info"></a>2.3. info</h4><blockquote><p>info 是 Linux 下 info 格式的帮助指令。</p><p>参考：<a href="http://man.linuxde.net/info">http://man.linuxde.net/info</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 man 命令的详细说明</span></span><br><span class="line">$ info man</span><br></pre></td></tr></table></figure><h4 id="2-4-which"><a href="#2-4-which" class="headerlink" title="2.4. which"></a>2.4. which</h4><blockquote><p>which 命令用于查找并显示给定命令的绝对路径，环境变量 PATH 中保存了查找命令时需要遍历的目录。which 指令会在环境变量$PATH 设置的目录里查找符合条件的文件。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>参考：<a href="http://man.linuxde.net/which">http://man.linuxde.net/which</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">pwd</span> <span class="comment"># 查找命令的路径</span></span><br></pre></td></tr></table></figure><p>说明：which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># which cd</span></span><br><span class="line"><span class="built_in">cd</span>: shell built-in <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是 bash 内建的命令！但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！</p><h4 id="2-5-whereis"><a href="#2-5-whereis" class="headerlink" title="2.5. whereis"></a>2.5. whereis</h4><blockquote><p>whereis 命令用来定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径。</p><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>参考：<a href="http://man.linuxde.net/whereis">http://man.linuxde.net/whereis</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis git <span class="comment"># 将相关的文件都查找出来</span></span><br></pre></td></tr></table></figure><h4 id="2-6-man"><a href="#2-6-man" class="headerlink" title="2.6. man"></a>2.6. man</h4><blockquote><p>man 命令是 Linux 下的帮助指令，通过 man 指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。</p><p>参考：<a href="http://man.linuxde.net/man">http://man.linuxde.net/man</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ man <span class="built_in">date</span> <span class="comment"># 查看 date 命令的帮助手册</span></span><br><span class="line">$ man 3 <span class="built_in">printf</span> <span class="comment"># 查看 printf 命令的帮助手册中的第 3 类</span></span><br><span class="line">$ man -k keyword <span class="comment"># 根据命令中部分关键字来查询命令</span></span><br></pre></td></tr></table></figure><h4 id="2-7-man-要点"><a href="#2-7-man-要点" class="headerlink" title="2.7. man 要点"></a>2.7. man 要点</h4><p>在 man 的帮助手册中，可以使用 page up 和 page down 来上下翻页。</p><p>man 的帮助手册中，将帮助文档分为了 9 个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询 bash 命令，归类在 1 类中）。</p><p>man 页面的分类(常用的是分类 1 和分类 3)：</p><ol><li>可执行程序或 shell 命令</li><li>系统调用(内核提供的函数)</li><li>库调用(程序库中的函数)</li><li>特殊文件(通常位于 /dev)</li><li>文件格式和规范，如 /etc/passwd</li><li>游戏</li><li>杂项(包括宏包和规范，如 man(7)，groff(7))</li><li>系统管理命令(通常只针对 root 用户)</li><li>内核例程 [非标准]</li></ol><p>前面说到使用 whatis 会显示命令所在的具体的文档类别，我们学习如何使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ whatis <span class="built_in">printf</span></span><br><span class="line"><span class="built_in">printf</span> (1) - format and <span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">printf</span> (1p) - write formatted output</span><br><span class="line"><span class="built_in">printf</span> (3) - formatted output conversion</span><br><span class="line"><span class="built_in">printf</span> (3p) - <span class="built_in">print</span> formatted output</span><br><span class="line"><span class="built_in">printf</span> [builtins](1) - bash built-in commands, see bash(1)</span><br></pre></td></tr></table></figure><p>我们看到 printf 在分类 1 和分类 3 中都有；分类 1 中的页面是命令操作及可执行文件的帮助；而 3 是常用函数库说明；如果我们想看的是 C 语言中 printf 的用法，可以指定查看分类 3 的帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man 3 <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><h2 id="Linux-文件目录命令"><a href="#Linux-文件目录命令" class="headerlink" title="Linux 文件目录命令"></a>Linux 文件目录命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul><li><strong>切换目录 - 使用 cd</strong></li><li><strong>查看目录信息 - 使用 ls</strong></li><li><strong>显示当前目录的绝对路径 - 使用 pwd</strong></li><li><strong>树状显示目录的内容 - 使用 tree</strong></li><li><strong>创建目录 - 使用 mkdir</strong></li><li><strong>删除目录 - 使用 rmdir</strong></li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li><strong>创建空文件 - 使用 touch</strong></li><li>为文件创建连接 - 使用 ln</li><li>批量重命名 - 使用 rename</li><li>显示文件的详细信息 - 使用 stat</li><li>探测文件类型 - 使用 file</li><li><strong>设置文件或目录的权限 - 使用 chmod</strong></li><li>设置文件或目录的拥有者或所属群组 - 使用 chown</li><li>查找文件或目录 - 使用 locate</li><li><strong>在指定目录下查找文件 - 使用 find</strong></li><li>查找命令的绝对路径 - 使用 which</li><li>查找命令的程序、源代码等相关文件 - 使用 whereis</li></ul><h3 id="文件和目录通用管理"><a href="#文件和目录通用管理" class="headerlink" title="文件和目录通用管理"></a>文件和目录通用管理</h3><ul><li><strong>复制文件或目录 - 使用 cp</strong></li><li><strong>复制文件或目录到远程服务器 - 使用 scp</strong></li><li><strong>移动文件或目录 - 使用 mv</strong></li><li><strong>删除文件或目录 - 使用 rm</strong></li></ul><h3 id="命令常见用法-1"><a href="#命令常见用法-1" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><blockquote><p>cd 命令用来切换工作目录。</p><p>参考：<a href="http://man.linuxde.net/cd">http://man.linuxde.net/cd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>          <span class="comment"># 切换到用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> ~        <span class="comment"># 切换到用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> -        <span class="comment"># 切换到上一个工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ..       <span class="comment"># 切换到上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../..    <span class="comment"># 切换到上两级目录</span></span><br></pre></td></tr></table></figure><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><blockquote><p>ls 命令用来显示目录信息。</p><p>参考：<a href="http://man.linuxde.net/ls">http://man.linuxde.net/ls</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>        <span class="comment"># 列出当前目录可见文件</span></span><br><span class="line"><span class="built_in">ls</span> -l     <span class="comment"># 列出当前目录可见文件详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -la    <span class="comment"># 列出所有文件（包括隐藏）的详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -lh    <span class="comment"># 列出详细信息并以可读大小显示文件大小</span></span><br><span class="line"><span class="built_in">ls</span> -lt    <span class="comment"># 按时间列出文件和文件夹详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -ltr   <span class="comment"># 按修改时间列出文件和文件夹详细信息</span></span><br><span class="line"><span class="built_in">ls</span> --color=auto     <span class="comment"># 列出文件并标记颜色分类</span></span><br></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><blockquote><p>pwd 命令用来显示当前目录的绝对路径。</p><p>参考：<a href="http://man.linuxde.net/pwd">http://man.linuxde.net/pwd</a></p></blockquote><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><blockquote><p>mkdir 命令用来创建目录。</p><p>参考：<a href="http://man.linuxde.net/mkdir">http://man.linuxde.net/mkdir</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录中创建 zp 和 zp 的子目录 test</span></span><br><span class="line"><span class="built_in">mkdir</span> -p zp/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录中创建 zp 和 zp 的子目录 test；权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问</span></span><br><span class="line"><span class="built_in">mkdir</span> -p -m 750 zp/test</span><br></pre></td></tr></table></figure><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><blockquote><p>rmdir 命令用来删除空目录。</p><p>参考：<a href="http://man.linuxde.net/rmdir">http://man.linuxde.net/rmdir</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除子目录 test 和其父目录 zp</span></span><br><span class="line"><span class="built_in">rmdir</span> -p zp/test</span><br></pre></td></tr></table></figure><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><blockquote><p>tree 命令以树状显示目录的内。</p><p>参考：<a href="http://man.linuxde.net/tree">http://man.linuxde.net/tree</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录 /private 第一级文件名</span></span><br><span class="line">tree /private -L 1</span><br><span class="line">/private/</span><br><span class="line">├── etc</span><br><span class="line">├── tftpboot</span><br><span class="line">├── tmp</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略文件夹</span></span><br><span class="line">tree -I node_modules            <span class="comment"># 忽略当前目录文件夹 node_modules</span></span><br><span class="line">tree -P node_modules            <span class="comment"># 列出当前目录文件夹 node_modules 的目录结构</span></span><br><span class="line">tree -P node_modules -L 2       <span class="comment"># 显示目录 node_modules 两层的目录树结构</span></span><br><span class="line">tree -L 2 &gt; /home/www/tree.txt  <span class="comment"># 当前目录结果存到 tree.txt 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略多个文件夹</span></span><br><span class="line">tree -I <span class="string">&#x27;node_modules|icon|font&#x27;</span> -L 2</span><br></pre></td></tr></table></figure><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><blockquote><p>touch 命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建空文件。</p><p>参考：<a href="http://man.linuxde.net/touch">http://man.linuxde.net/touch</a></p></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ex2</span><br></pre></td></tr></table></figure><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><blockquote><p>ln 命令用来为文件创建连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。</p><p>🔔 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。</p><p>参考：<a href="http://man.linuxde.net/ln">http://man.linuxde.net/ln</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目录 /usr/mengqc/mub1 下的文件 m2.c 链接到目录 /usr/liu 下的文件 a2.c</span></span><br><span class="line"><span class="built_in">cd</span> /usr/mengqc</span><br><span class="line"><span class="built_in">ln</span> /mub1/m2.c /usr/liu/a2.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目录 /usr/liu 下建立一个符号链接文件 abc，使它指向目录 /usr/mengqc/mub1</span></span><br><span class="line"><span class="comment"># 执行该命令后，/usr/mengqc/mub1 代表的路径将存放在名为 /usr/liu/abc 的文件中</span></span><br><span class="line"><span class="built_in">ln</span> -s /usr/mengqc/mub1 /usr/liu/abc</span><br></pre></td></tr></table></figure><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><blockquote><p>rename 命令用字符串替换的方式批量重命名。</p><p>参考：<a href="http://man.linuxde.net/rename">http://man.linuxde.net/rename</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 main1.c 重命名为 main.c</span></span><br><span class="line">rename main1.c main.c main1.c</span><br><span class="line"></span><br><span class="line">rename <span class="string">&quot;s/AA/aa/&quot;</span> *             <span class="comment"># 把文件名中的 AA 替换成 aa</span></span><br><span class="line">rename <span class="string">&quot;s//.html//.php/&quot;</span> *      <span class="comment"># 把 .html 后缀的改成 .php 后缀</span></span><br><span class="line">rename <span class="string">&quot;s/$//.txt/&quot;</span> *           <span class="comment"># 把所有的文件名都以 txt 结尾</span></span><br><span class="line">rename <span class="string">&quot;s//.txt//&quot;</span> *            <span class="comment"># 把所有以 .txt 结尾的文件名的.txt 删掉</span></span><br></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><blockquote><p>stat 命令用于显示文件的状态信息。stat 命令的输出信息比 ls 命令的输出信息要更详细。</p><p>参考：<a href="http://man.linuxde.net/stat">http://man.linuxde.net/stat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> myfile</span><br></pre></td></tr></table></figure><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><blockquote><p>file 命令用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。</p><p>参考：<a href="http://man.linuxde.net/file">http://man.linuxde.net/file</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file install.log          <span class="comment"># 显示文件类型</span></span><br><span class="line">file -b install.log       <span class="comment"># 不显示文件名称</span></span><br><span class="line">file -i install.log       <span class="comment"># 显示 MIME 类型</span></span><br><span class="line">file -L /var/spool/mail   <span class="comment"># 显示符号链接的文件类型</span></span><br></pre></td></tr></table></figure><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><blockquote><p>chmod 命令用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p><p>参考：<a href="http://man.linuxde.net/chmod">http://man.linuxde.net/chmod</a></p></blockquote><p>知识扩展：</p><p>Linux 用 户分为：拥有者、组群(Group)、其他（other），Linux 系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及 root 的相关信 息， 都是记录在<code>/etc/passwd</code>文件中。每个人的密码则是记录在<code>/etc/shadow</code>文件下。 此外，所有的组群名称记录在<code>/etc/group</code>內！</p><p>linux 文件的用户权限的分析图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules</span><br><span class="line"><span class="comment"># ↑╰┬╯╰┬╯╰┬╯</span></span><br><span class="line"><span class="comment"># ┆ ┆  ┆  ╰┈ 0 其他人</span></span><br><span class="line"><span class="comment"># ┆ ┆  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ g 属组</span></span><br><span class="line"><span class="comment"># ┆ ╰┈┈┈┈ u 属组</span></span><br><span class="line"><span class="comment"># ╰┈┈ 第一个字母 `d` 代表目录，`-` 代表普通文件</span></span><br></pre></td></tr></table></figure><p>例：rwx 　 rw-　 r—</p><p>r=读取属性　　//值＝ 4<br>w=写入属性　　//值＝ 2<br>x=执行属性　　//值＝ 1</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x,g+w f01　　<span class="comment"># 为文件f01设置自己可以执行，组员可以写入的权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rwx,g=rw,o=r f01</span><br><span class="line"><span class="built_in">chmod</span> 764 f01</span><br><span class="line"><span class="built_in">chmod</span> a+x f01　　    <span class="comment"># 对文件f01的u,g,o都设置可执行属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将/home/wwwroot/里的所有文件和文件夹设置为755权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R  755 /home/wwwroot/*</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><blockquote><p>chown 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户 D，用户组可以是组名或组 id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p><p>只有文件拥有者和超级用户才可以便用该命令。</p><p>参考：<a href="http://man.linuxde.net/chown">http://man.linuxde.net/chown</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu</span></span><br><span class="line"><span class="built_in">chown</span> -R liu /usr/meng</span><br></pre></td></tr></table></figure><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><blockquote><p>locate 命令和 slocate 命令都用来查找文件或目录。</p><p>locate 命令其实是 find -name 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令，手动更新数据库。</p><p>参考：<a href="http://man.linuxde.net/locate_slocate">http://man.linuxde.net/locate_slocate</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate <span class="built_in">pwd</span>      <span class="comment"># 查找和 pwd 相关的所有文件</span></span><br><span class="line">locate /etc/sh  <span class="comment"># 搜索 etc 目录下所有以 sh 开头的文件</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><blockquote><p>find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>参考：<a href="http://man.linuxde.net/find">http://man.linuxde.net/find</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*&quot;</span> | xargs grep <span class="string">&quot;140.206.111.111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line">find .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /home 目录下查找以 .txt 结尾的文件名</span></span><br><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="comment"># 同上，但忽略大小写</span></span><br><span class="line">find /home -iname <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</span></span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配文件路径或者文件</span></span><br><span class="line">find /usr/ -path <span class="string">&quot;*local*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于正则表达式匹配文件路径</span></span><br><span class="line">find . -regex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br><span class="line"><span class="comment"># 同上，但忽略大小写</span></span><br><span class="line">find . -iregex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 /home 下不是以 .txt 结尾的文件</span></span><br><span class="line">find /home ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><blockquote><p>cp 命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp 命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p><p>参考：<a href="http://man.linuxde.net/cp">http://man.linuxde.net/cp</a></p></blockquote><p>示例：</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li>源文件：制定源文件列表。默认情况下，cp 命令不能复制目录，如果要复制目录，则必须使用<code>-R</code>选项；</li><li>目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件 file 复制到目录 /usr/men/tmp 下，并改名为 file1</span></span><br><span class="line"><span class="built_in">cp</span> file /usr/men/tmp/file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录 /usr/men下的所有文件及其子目录复制到目录 /usr/zh 中</span></span><br><span class="line"><span class="built_in">cp</span> -r /usr/men /usr/zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行将 /usr/men下的所有文件复制到目录 /usr/zh 中，无论是否有文件重复</span></span><br><span class="line"><span class="built_in">cp</span> -rf /usr/men/* /usr/zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录 /usr/men 中的以 m 打头的所有 .c 文件复制到目录 /usr/zh 中</span></span><br><span class="line"><span class="built_in">cp</span> -i /usr/men m*.c /usr/zh</span><br></pre></td></tr></table></figure><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><blockquote><p>scp 命令用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system 时，用 scp 可以帮你把文件移出来。另外，scp 还非常不占资源，不会提高多少系统负荷，在这一点上，rsync 就远远不及它了。虽然 rsync 比 scp 会快一点，但当小文件众多的情况下，rsync 会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。</p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件到远程服务器的指定目录</span></span><br><span class="line">scp &lt;file&gt; &lt;user&gt;@&lt;ip&gt;:&lt;url&gt;</span><br><span class="line">scp test.txt root@192.168.0.1:/opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝目录到远程服务器的指定目录</span></span><br><span class="line">scp -r &lt;folder&gt; &lt;user&gt;@&lt;ip&gt;:&lt;url&gt;</span><br><span class="line">scp -r <span class="built_in">test</span> root@192.168.0.1:/opt</span><br></pre></td></tr></table></figure><h5 id="免密码传输"><a href="#免密码传输" class="headerlink" title="免密码传输"></a>免密码传输</h5><p>（1）生成 ssh 公私钥对</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>（2）将服务器 A 的 <code>\~/.ssh/id_rsa.pub</code> 文件内容复制到服务器 B 的 <code>\~/.ssh/authorized_keys</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器 A 上执行以下命令</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub root@192.168.0.2:~/.ssh/id_rsa.pub.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器 B 上执行以下命令</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub.tmp &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">rm</span> ~/.ssh/id_rsa.pub.tmp</span><br></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><blockquote><p>mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p><p>参考：<a href="http://man.linuxde.net/mv">http://man.linuxde.net/mv</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1.txt /home/office/                      <span class="comment"># 移动单个文件</span></span><br><span class="line"><span class="built_in">mv</span> file2.txt file3.txt file4.txt /home/office/  <span class="comment"># 移动多个文件</span></span><br><span class="line"><span class="built_in">mv</span> *.txt /home/office/                          <span class="comment"># 移动所有 txt 文件</span></span><br><span class="line"><span class="built_in">mv</span> dir1/ /home/office/                          <span class="comment"># 移动目录</span></span><br><span class="line"><span class="built_in">mv</span> /usr/men/* .                                 <span class="comment"># 将指定目录中的所有文件移到当前目录中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> file1.txt file2.txt          <span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> dir1/ dir2/                  <span class="comment"># 重命名目录</span></span><br><span class="line"><span class="built_in">mv</span> -v *.txt /home/office        <span class="comment"># 打印移动信息</span></span><br><span class="line"><span class="built_in">mv</span> -i file1.txt /home/office    <span class="comment"># 提示是否覆盖文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> -uv *.txt /home/office       <span class="comment"># 源文件比目标文件新时才执行更新</span></span><br><span class="line"><span class="built_in">mv</span> -vn *.txt /home/office       <span class="comment"># 不要覆盖任何已存在的文件</span></span><br><span class="line"><span class="built_in">mv</span> -f *.txt /home/office        <span class="comment"># 无条件覆盖已经存在的文件</span></span><br><span class="line"><span class="built_in">mv</span> -bv *.txt /home/office       <span class="comment"># 复制时创建备份</span></span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><blockquote><p>rm 命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。</p><p>参考：<a href="http://man.linuxde.net/rm">http://man.linuxde.net/rm</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt               <span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -i test.txt test2.txt  <span class="comment"># 交互式删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -r *                   <span class="comment"># 删除当前目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -r testdir             <span class="comment"># 删除目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf testdir            <span class="comment"># 强制删除目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -v testdir             <span class="comment"># 显示当前删除操作的详情</span></span><br></pre></td></tr></table></figure><h2 id="Linux-文件内容查看编辑命令"><a href="#Linux-文件内容查看编辑命令" class="headerlink" title="Linux 文件内容查看编辑命令"></a>Linux 文件内容查看编辑命令</h2><h3 id="Linux-文件内容查看编辑要点"><a href="#Linux-文件内容查看编辑要点" class="headerlink" title="Linux 文件内容查看编辑要点"></a>Linux 文件内容查看编辑要点</h3><ul><li><strong>连接文件并打印到标准输出设备 - 使用 cat</strong></li><li><strong>显示指定文件的开头若干行 - 使用 head</strong></li><li><strong>显示指定文件的末尾若干行，常用于实时打印日志文件内容 - 使用 tail</strong></li><li><strong>显示文件内容，每次显示一屏 - 使用 more</strong></li><li><strong>显示文件内容，每次显示一屏 - 使用 less</strong></li><li><strong>自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等 - 使用 sed</strong></li><li><strong>文本编辑器 - 使用 vi</strong></li><li><strong>使用正则表达式搜索文本，并把匹配的行打印出来 - 使用 grep</strong></li></ul><h3 id="命令常见用法-2"><a href="#命令常见用法-2" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><blockquote><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>参考：<a href="http://man.linuxde.net/cat">http://man.linuxde.net/cat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> m1              <span class="comment"># 在屏幕上显示文件 ml 的内容</span></span><br><span class="line"><span class="built_in">cat</span> m1 m2           <span class="comment"># 同时显示文件 ml 和 m2 的内容</span></span><br><span class="line"><span class="built_in">cat</span> m1 m2 &gt; file    <span class="comment"># 将文件 ml 和 m2 合并后放入文件 file 中</span></span><br></pre></td></tr></table></figure><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><blockquote><p>head 命令用于显示文件的开头内容。在默认情况下，head 命令显示文件的头部 10 行内容。</p><p>参考：<a href="http://man.linuxde.net/head">http://man.linuxde.net/head</a></p></blockquote><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><blockquote><p>tail 命令用于显示文件的尾部内容。在默认情况下，tail 命令显示文件的尾部 10 行内容。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。</p><p>参考：<a href="http://man.linuxde.net/tail">http://man.linuxde.net/tail</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> file           <span class="comment"># 显示文件file的最后10行</span></span><br><span class="line"><span class="built_in">tail</span> -n +20 file    <span class="comment"># 显示文件file的内容，从第20行至文件末尾</span></span><br><span class="line"><span class="built_in">tail</span> -c 10 file     <span class="comment"># 显示文件file的最后10个字符</span></span><br></pre></td></tr></table></figure><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><blockquote><p>more 命令是一个基于 vi 编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持 vi 中的关键字定位操作。more 名单中内置了若干快捷键，常用的有 H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p><p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：—More—（XX%）可以用下列不同的方法对提示做出回答：</p><ul><li>按 Space 键：显示文本的下一屏内容。</li><li>按 Enier 键：只显示文本的下一行内容。</li><li>按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</li><li>按 H 键：显示帮助屏，该屏上有相关的帮助信息。</li><li>按 B 键：显示上一屏内容。</li><li>按 Q 键：退出 rnore 命令。</li></ul><p>参考：<a href="http://man.linuxde.net/more">http://man.linuxde.net/more</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件 file 的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</span></span><br><span class="line">more -dc file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件 file 的内容，每 10 行显示一次，而且在显示之前先清屏。</span></span><br><span class="line">more -c -10 file</span><br></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 命令的作用与 more 十分相似，都可以用来浏览文字档案的内容，不同的是 less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览。用 less 命令显示文件时，用 PageUp 键向上翻页，用 PageDown 键向下翻页。要退出 less 程序，应按 Q 键。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /var/log/shadowsocks.log</span><br></pre></td></tr></table></figure><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><blockquote><p>sed 是一种流编辑器，它是文本处理工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed 主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p>参考：<a href="http://man.linuxde.net/sed">http://man.linuxde.net/sed</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换文本中的字符串</span></span><br><span class="line">sed <span class="string">&#x27;s/book/books/&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 选项 和 p 命令 一起使用表示只打印那些发生替换的行</span></span><br><span class="line">sed -n <span class="string">&#x27;s/test/TEST/p&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接编辑文件选项 -i ，会匹配 file 文件中每一行的第一个 book 替换为 books</span></span><br><span class="line">sed -i <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用后缀 /g 标记会替换每一行中的所有匹配</span></span><br><span class="line">sed <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件的第2行</span></span><br><span class="line">sed <span class="string">&#x27;2d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件的第2行到末尾所有行</span></span><br><span class="line">sed <span class="string">&#x27;2,$d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件最后一行</span></span><br><span class="line">sed <span class="string">&#x27;$d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件中所有开头是test的行</span></span><br><span class="line">sed <span class="string">&#x27;/^test/&#x27;</span>d file</span><br></pre></td></tr></table></figure><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><blockquote><p>vi 命令是 UNIX 操作系统和类 UNIX 操作系统中最通用的全屏幕纯文本编辑器。Linux 中的 vi 编辑器叫 vim，它是 vi 的增强版（vi Improved），与 vi 编辑器完全兼容，而且实现了很多增强功能。</p><p>参考：<a href="http://man.linuxde.net/vi">http://man.linuxde.net/vi</a></p><p>引申阅读：<a href="https://github.com/dunwu/OS/blob/master/docs/vim.md">Vim 入门指南(opens new window)</a></p></blockquote><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><blockquote><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>参考：<a href="http://man.linuxde.net/grep">http://man.linuxde.net/grep</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在多级目录中对文本递归搜索(程序员搜代码的最爱）:</span></span><br><span class="line">$ grep <span class="string">&quot;class&quot;</span> . -R -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略匹配样式中的字符大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | grep -i <span class="string">&quot;HELLO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配多个模式:</span></span><br><span class="line">$ grep -e <span class="string">&quot;class&quot;</span> -e <span class="string">&quot;vitural&quot;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --include *.&#123;php,html&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在搜索结果中排除所有README文件</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --exclude <span class="string">&quot;README&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --exclude-from filelist</span><br></pre></td></tr></table></figure><h2 id="Linux-文件压缩和解压命令"><a href="#Linux-文件压缩和解压命令" class="headerlink" title="Linux 文件压缩和解压命令"></a>Linux 文件压缩和解压命令</h2><h3 id="Linux-文件压缩和解压要点"><a href="#Linux-文件压缩和解压要点" class="headerlink" title="Linux 文件压缩和解压要点"></a>Linux 文件压缩和解压要点</h3><ul><li><strong>压缩和解压 tar 文件 - 使用 tar</strong></li><li><strong>压缩和解压 gz 文件 - 使用 gzip</strong></li><li><strong>压缩和解压 zip 文件 - 分别使用 zip、unzip</strong></li></ul><h3 id="命令常见用法-3"><a href="#命令常见用法-3" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><blockquote><p>tar 命令可以为 linux 的文件和目录创建档案。利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar 最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用 tar 命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p><p>参考：<a href="http://man.linuxde.net/tar">http://man.linuxde.net/tar</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log            <span class="comment"># 仅打包，不压缩</span></span><br><span class="line">tar -zcvf log.tar.gz log2012.log        <span class="comment"># 打包后，以 gzip 压缩</span></span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log       <span class="comment"># 打包后，以 bzip2 压缩</span></span><br><span class="line"></span><br><span class="line">tar -ztvf log.tar.gz                    <span class="comment"># 查阅上述 tar 包内有哪些文件</span></span><br><span class="line">tar -zxvf log.tar.gz                    <span class="comment"># 将 tar 包解压缩</span></span><br><span class="line">tar -zxvf log30.tar.gz log2013.log      <span class="comment"># 只将 tar 内的部分文件解压出来</span></span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><blockquote><p>gzip 命令用来压缩文件。gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出“.gz”扩展名。</p><p>gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～ 70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p>参考：<a href="http://man.linuxde.net/gzip">http://man.linuxde.net/gzip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip * <span class="comment"># 将所有文件压缩成 .gz 文件</span></span><br><span class="line">gzip -l * <span class="comment"># 详细显示压缩文件的信息，并不解压</span></span><br><span class="line">gzip -dv * <span class="comment"># 解压上例中的所有压缩文件，并列出详细的信息</span></span><br><span class="line">gzip -r log.tar     <span class="comment"># 压缩一个 tar 备份文件，此时压缩文件的扩展名为.tar.gz</span></span><br><span class="line">gzip -rv <span class="built_in">test</span>/      <span class="comment"># 递归的压缩目录</span></span><br><span class="line">gzip -dr <span class="built_in">test</span>/      <span class="comment"># 递归地解压目录</span></span><br></pre></td></tr></table></figure><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><blockquote><p>zip 命令可以用来解压缩文件，或者对文件进行打包操作。zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。</p><p>参考：<a href="http://man.linuxde.net/zip">http://man.linuxde.net/zip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /home/Blinux/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip</span></span><br><span class="line">zip -q -r html.zip /home/Blinux/html</span><br></pre></td></tr></table></figure><h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h4><blockquote><p>unzip 命令用于解压缩由 zip 命令压缩的“.zip”压缩包。</p><p>参考：<a href="http://man.linuxde.net/unzip">http://man.linuxde.net/unzip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip test.zip              <span class="comment"># 解压 zip 文件</span></span><br><span class="line">unzip -n test.zip -d /tmp/  <span class="comment"># 在指定目录下解压缩</span></span><br><span class="line">unzip -o test.zip -d /tmp/  <span class="comment"># 在指定目录下解压缩，如果有相同文件存在则覆盖</span></span><br><span class="line">unzip -v test.zip           <span class="comment"># 查看压缩文件目录，但不解压</span></span><br></pre></td></tr></table></figure><h2 id="Linux-用户管理命令"><a href="#Linux-用户管理命令" class="headerlink" title="Linux 用户管理命令"></a>Linux 用户管理命令</h2><h3 id="用户管理要点"><a href="#用户管理要点" class="headerlink" title="用户管理要点"></a>用户管理要点</h3><ul><li><strong>创建用户组 - 使用 groupadd</strong></li><li>删除用户组 - 使用 groupdel</li><li>修改用户组信息 - 使用 groupmod</li><li><strong>创建用户 - 使用 useradd</strong></li><li><strong>删除用户 - 使用 userdel</strong></li><li><strong>修改用户信息 - 使用 usermod</strong></li><li>设置用户认证信息 - 使用 passwd</li><li><strong>切换用户 - 使用 su</strong></li><li><strong>当前用户想执行没有权限执行的命令时，使用其他用户身份去执行 - 使用 sudo</strong></li></ul><h3 id="命令常见用法-4"><a href="#命令常见用法-4" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><blockquote><p>groupadd 命令用于创建一个新的用户组，新用户组的信息将被添加到系统文件中。</p><p>参考：<a href="http://man.linuxde.net/groupadd">http://man.linuxde.net/groupadd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个新组，并设置组 ID 加入系统</span></span><br><span class="line">$ groupadd -g 344 jsdigname</span><br></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><blockquote><p>groupdel 命令用于删除指定的用户组，本命令要修改的系统文件包括 <code>/ect/group</code> 和 <code>/ect/gshadow</code>。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><p>参考：<a href="http://man.linuxde.net/groupdel">http://man.linuxde.net/groupdel</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd damon  <span class="comment"># 创建damon用户组</span></span><br><span class="line">$ groupdel damon  <span class="comment"># 删除这个用户组</span></span><br></pre></td></tr></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><blockquote><p>groupmod 命令更改群组识别码或名称。需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。</p><p>参考：<a href="http://man.linuxde.net/groupmod">http://man.linuxde.net/groupmod</a></p></blockquote><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><blockquote><p>useradd 命令用于 Linux 中创建的新的系统用户。useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code> 文本文件中。</p><p>参考：<a href="http://man.linuxde.net/useradd">http://man.linuxde.net/useradd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建用户加入组</span></span><br><span class="line">$ useradd –g sales jack –G company,employees    <span class="comment"># -g：加入主要组、-G：加入次要组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个新用户账户，并设置 ID</span></span><br><span class="line">$ useradd caojh -u 544</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><blockquote><p>userdel 命令用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。</p><p>参考：<a href="http://man.linuxde.net/userdel">http://man.linuxde.net/userdel</a></p></blockquote><p>示例：</p><p>userdel 命令很简单，比如我们现在有个用户 linuxde，其 home 目录位于<code>/var</code>目录中，现在我们来删除这个用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ userdel linuxde       <span class="comment"># 删除用户linuxde，但不删除其家目录及文件；</span></span><br><span class="line">$ userdel -r linuxde    <span class="comment"># 删除用户linuxde，其 home 目录及文件一并删除；</span></span><br></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><blockquote><p>usermod 命令用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变 user id，必须确认这名 user 没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在 server 上更动相关的 NIS 设定。</p><p>参考：<a href="http://man.linuxde.net/usermod">http://man.linuxde.net/usermod</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 newuser2 添加到组 staff 中</span></span><br><span class="line">$ usermod -G staff newuser2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 newuser 的用户名为 newuser1</span></span><br><span class="line">$ usermod -l newuser1 newuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定账号 newuser1</span></span><br><span class="line">$ usermod -L newuser1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解除对 newuser1 的锁定</span></span><br><span class="line">$ usermod -U newuser1</span><br></pre></td></tr></table></figure><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><blockquote><p>passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><p>参考：<a href="http://man.linuxde.net/passwd">http://man.linuxde.net/passwd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是普通用户执行 passwd 只能修改自己的密码。</span></span><br><span class="line"><span class="comment"># 如果新建用户后，要为新用户创建密码，则用 passwd 用户名，注意要以 root 用户的权限来创建。</span></span><br><span class="line">$ passwd linuxde    <span class="comment"># 更改或创建linuxde用户的密码；</span></span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">New UNIX password:          <span class="comment"># 请输入新密码；</span></span><br><span class="line">Retype new UNIX password:   <span class="comment"># 再输入一次；</span></span><br><span class="line">passwd: all authentication tokens updated successfully. <span class="comment"># 成功；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通用户如果想更改自己的密码，直接运行 passwd 即可，比如当前操作的用户是 linuxde。</span></span><br><span class="line">$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde. <span class="comment"># 更改linuxde用户的密码；</span></span><br><span class="line">(current) UNIX password:   <span class="comment"># 请输入当前密码；</span></span><br><span class="line">New UNIX password:         <span class="comment"># 请输入新密码；</span></span><br><span class="line">Retype new UNIX password:  <span class="comment"># 确认新密码；</span></span><br><span class="line">passwd: all authentication tokens updated successfully. <span class="comment"># 更改成功；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如我们让某个用户不能修改密码，可以用`-l`选项来锁定：</span></span><br><span class="line">$ passwd -l linuxde    <span class="comment"># 锁定用户linuxde不能更改密码；</span></span><br><span class="line">Locking password <span class="keyword">for</span> user linuxde.</span><br><span class="line">passwd: Success           <span class="comment"># 锁定成功；</span></span><br><span class="line"></span><br><span class="line">$ su linuxde   <span class="comment"># 通过su切换到linuxde用户；</span></span><br><span class="line">$ passwd      <span class="comment"># linuxde来更改密码；</span></span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">Changing password <span class="keyword">for</span> linuxde</span><br><span class="line">(current) UNIX password:          <span class="comment"># 输入linuxde的当前密码；</span></span><br><span class="line">passwd: Authentication token manipulation error     <span class="comment"># 失败，不能更改密码；</span></span><br><span class="line"></span><br><span class="line">$ passwd -d linuxde  <span class="comment"># 清除linuxde用户密码；</span></span><br><span class="line">Removing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">passwd: Success                         <span class="comment"># 清除成功；</span></span><br><span class="line"></span><br><span class="line">$ passwd -S linuxde    <span class="comment"># 查询linuxde用户密码状态；</span></span><br><span class="line">Empty password.                         <span class="comment"># 空密码，也就是没有密码；</span></span><br></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><blockquote><p>su 命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。</p><p>参考：<a href="http://man.linuxde.net/su">http://man.linuxde.net/su</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变更帐号为 root 并在执行 ls 指令后退出变回原使用者：</span></span><br><span class="line">$ su -c <span class="built_in">ls</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更帐号为 root 并传入`-f`选项给新执行的 shell：</span></span><br><span class="line">$ su root -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更帐号为 test 并改变工作目录至 test 的家目录：</span></span><br><span class="line">$ su -<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><blockquote><p>sudo 命令用来以其他身份来执行命令，预设的身份为 root。在 <code>/etc/sudoers</code> 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。</p><p>参考：<a href="http://man.linuxde.net/sudo">http://man.linuxde.net/sudo</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定用户执行命令</span></span><br><span class="line">$ sudo -u userb <span class="built_in">ls</span> -l</span><br><span class="line"><span class="comment"># 列出目前的权限</span></span><br><span class="line">$ sudo -l</span><br><span class="line"><span class="comment"># 显示sudo设置</span></span><br><span class="line">$ sudo -L</span><br></pre></td></tr></table></figure><h5 id="给普通用户授权-sudo"><a href="#给普通用户授权-sudo" class="headerlink" title="给普通用户授权 sudo"></a>给普通用户授权 sudo</h5><p>假设要给普通用户 mary 配置 sudo 权限：</p><ol><li><code>/etc/sudoers</code> 文件存放了 sudo 的相关用户，但是默认是没有写权限的，所以需要设为可写：<code>chmod u+w /etc/sudoers</code></li><li>在该文件中添加 <code>mary ALL=(ALL) ALL</code> ，保存并退出，让 mary 具有 sudo 的所有权限</li><li>再将 <code>/etc/sudoers</code> 的权限恢复到默认状态：<code>chmod u-w /etc/sudoers</code></li></ol><h5 id="免密码授权-sudo"><a href="#免密码授权-sudo" class="headerlink" title="免密码授权 sudo"></a>免密码授权 sudo</h5><p>与给普通用户授权 sudo 类似，区别仅在于第 2 步：<code>mary ALL=(ALL) NOPASSWD: ALL</code>。</p><h2 id="Linux-系统管理命令"><a href="#Linux-系统管理命令" class="headerlink" title="Linux 系统管理命令"></a>Linux 系统管理命令</h2><blockquote><p>关键词：<code>lsb_release</code>, <code>reboot</code>, <code>exit</code>, <code>shutdown</code>, <code>date</code>, <code>mount</code>, <code>umount</code>, <code>ps</code>, <code>kill</code>, <code>systemctl</code>, <code>service</code>, <code>crontab</code></p></blockquote><h3 id="系统管理要点"><a href="#系统管理要点" class="headerlink" title="系统管理要点"></a>系统管理要点</h3><ul><li>查看 Linux 系统发行版本<ul><li>使用 lsb_release（此命令适用于所有的 Linux 发行版本）</li><li>使用 <code>cat /etc/redhat-release</code>（此方法只适合 Redhat 系的 Linux）</li></ul></li><li>查看 CPU 信息 - 使用 <code>cat /proc/cpuinfo</code></li><li>重新启动 Linux 操作系统 - 使用 reboot</li><li>退出 shell，并返回给定值 - 使用 exit</li><li>关闭系统 - 使用 shutdown</li><li>查看或设置系统时间与日期 - 使用 date</li><li><strong>挂载文件系统 - 使用 mount</strong></li><li>取消挂载文件系统 - 使用 umount</li><li><strong>查看系统当前进程状态 - 使用 ps</strong></li><li><strong>删除当前正在运行的进程 - 使用 kill</strong></li><li><strong>启动、停止、重启、关闭、显示系统服务（Centos7），使用 systemctl</strong></li><li>启动、停止、重启、关闭、显示系统服务（Centos7 以前），使用 service</li><li>管理需要周期性执行的任务，使用 crontab</li></ul><h3 id="命令常见用法-5"><a href="#命令常见用法-5" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="lsb-release"><a href="#lsb-release" class="headerlink" title="lsb_release"></a>lsb_release</h4><p>lsb_release 不是 bash 默认命令，如果要使用，需要先安装。</p><p>安装方法：</p><ol><li>执行 <code>yum provides lsb_release</code>，查看支持 lsb_release 命令的包。</li><li>选择合适版本，执行类似这样的安装命令：<code>yum install -y redhat-lsb-core-4.1-27.el7.centos.1.x86_64</code></li></ol><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><blockquote><p>reboot 命令用来重新启动正在运行的 Linux 操作系统。</p><p>参考：<a href="http://man.linuxde.net/reboot">http://man.linuxde.net/reboot</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot        <span class="comment"># 重开机。</span></span><br><span class="line">reboot -w     <span class="comment"># 做个重开机的模拟（只有纪录并不会真的重开机）。</span></span><br></pre></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><blockquote><p>exit 命令同于退出 shell，并返回给定值。在 shell 脚本中可以终止当前脚本执行。执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。</p><p>参考：<a href="http://man.linuxde.net/exit">http://man.linuxde.net/exit</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 退出当前 shell</span></span><br><span class="line">[root@localhost ~]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，进入脚本所在目录，否则退出</span></span><br><span class="line"><span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$0</span>) || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，判断参数数量，不匹配就打印使用方式，退出</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -ne <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;usage: <span class="variable">$0</span> &lt;area&gt; &lt;hours&gt;&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，退出时删除临时文件</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f tmpfile; echo Bye.&quot;</span> EXIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查上一命令的退出码</span></span><br><span class="line">./mycommand.sh</span><br><span class="line">EXCODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$EXCODE</span>&quot;</span> == <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;O.K&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><blockquote><p>shutdown 命令用来系统关机命令。shutdown 指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。</p><p>参考：<a href="http://man.linuxde.net/shutdown">http://man.linuxde.net/shutdown</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定现在立即关机</span></span><br><span class="line">shutdown -h now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 5 分钟后关机，同时送出警告信息给登入用户</span></span><br><span class="line">shutdown +5 <span class="string">&quot;System will shutdown after 5 minutes&quot;</span></span><br></pre></td></tr></table></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><blockquote><p>date 命令是显示或设置系统时间与日期。</p><p>参考：<a href="http://man.linuxde.net/date">http://man.linuxde.net/date</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d&quot;</span></span><br><span class="line">2009-12-07</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出昨天日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;1 day ago&quot;</span> +<span class="string">&quot;%Y-%m-%d&quot;</span></span><br><span class="line">2012-11-19</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 秒后输出</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;2 second&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2012-11-20 14:21.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传说中的 1234567890 秒</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;1970-01-01 1234567890 seconds&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%m:%S&quot;</span></span><br><span class="line">2009-02-13 23:02:30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通转格式</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;2009-12-12&quot;</span> +<span class="string">&quot;%Y/%m/%d %H:%M.%S&quot;</span></span><br><span class="line">2009/12/12 00:00.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># apache 格式转换</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;Dec 5, 2009 12:00:37 AM&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2009-12-05 00:00.37</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式转换后时间游走</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;Dec 5, 2009 12:00:37 AM 2 year ago&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2007-12-05 00:00.37</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加减操作</span></span><br><span class="line"><span class="built_in">date</span> +%Y%m%d                   <span class="comment"># 显示前天年月日</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示前一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示后一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示上一月的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示下一月的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示前一年的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示下一年的日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定时间</span></span><br><span class="line"><span class="built_in">date</span> -s                        <span class="comment"># 设置当前时间，只有root权限才能设置，其他只能查看</span></span><br><span class="line"><span class="built_in">date</span> -s 20120523               <span class="comment"># 设置成20120523，这样会把具体时间设置成空00:00:00</span></span><br><span class="line"><span class="built_in">date</span> -s 01:01:01               <span class="comment"># 设置具体时间，不会对日期做更改</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01:01:01 2012-05-23&quot;</span>  <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01:01:01 20120523&quot;</span>    <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2012-05-23 01:01:01&quot;</span>  <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;20120523 01:01:01&quot;</span>    <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时需要检查一组命令花费的时间</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">nmap man.linuxde.net &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">difference=$(( end - start ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$difference</span> seconds.</span><br></pre></td></tr></table></figure><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><blockquote><p>mount 命令用于挂载文件系统到指定的挂载点。此命令的最常用于挂载 cdrom，使我们可以访问 cdrom 中的数据，因为你将光盘插入 cdrom 中，Linux 并不会自动挂载，必须使用 Linux mount 命令来手动完成挂载。</p><p>参考：<a href="http://man.linuxde.net/mount">http://man.linuxde.net/mount</a> &gt; <a href="https://blog.csdn.net/weishujie000/article/details/76531924">https://blog.csdn.net/weishujie000/article/details/76531924</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hda1 挂在 /mnt 之下</span></span><br><span class="line">mount /dev/hda1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 /dev/hda1 用唯读模式挂在 /mnt 之下</span></span><br><span class="line">mount -o ro /dev/hda1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom 之下</span></span><br><span class="line"><span class="comment"># 用这种方法可以将一般网络上可以找到的 Linux ISO 在不烧录成光碟的情况下检视其内容</span></span><br><span class="line">mount -o loop /tmp/image.iso /mnt/cdrom</span><br></pre></td></tr></table></figure><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><blockquote><p>umount 命令用于卸载已经挂载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。</p><p>参考：<a href="http://man.linuxde.net/umount">http://man.linuxde.net/umount</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设备名卸载</span></span><br><span class="line">umount -v /dev/sda1</span><br><span class="line">/dev/sda1 umounted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过挂载点卸载</span></span><br><span class="line">umount -v /mnt/mymount/</span><br><span class="line">/tmp/diskboot.img umounted</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><blockquote><p>ps 命令用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p><p>参考：<a href="http://man.linuxde.net/ps">http://man.linuxde.net/ps</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按内存资源的使用量对进程进行排序</span></span><br><span class="line">ps aux | <span class="built_in">sort</span> -rnk 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 CPU 资源的使用量对进程进行排序</span></span><br><span class="line">ps aux | <span class="built_in">sort</span> -nk 3</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><blockquote><p>kill 命令用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。</p><p>参考：<a href="http://man.linuxde.net/kill">http://man.linuxde.net/kill</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有信号名称</span></span><br><span class="line"> <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line"> 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU</span><br><span class="line">25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH</span><br><span class="line">29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先用 ps 查找进程，然后用 kill 杀掉</span></span><br><span class="line">ps -ef | grep vim</span><br><span class="line">root      3268  2884  0 16:21 pts/1    00:00:00 vim install.log</span><br><span class="line">root      3370  2822  0 16:21 pts/0    00:00:00 grep vim</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 3268</span><br><span class="line"><span class="built_in">kill</span> 3268</span><br><span class="line">-bash: <span class="built_in">kill</span>: (3268) - 没有那个进程</span><br></pre></td></tr></table></figure><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><blockquote><p>systemctl 命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。</p><p>参考：<a href="http://man.linuxde.net/systemctl">http://man.linuxde.net/systemctl</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.启动 nfs 服务</span></span><br><span class="line">systemctl start nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.停止开机自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看服务当前状态</span></span><br><span class="line">systemctl status nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.重新启动某服务</span></span><br><span class="line">systemctl restart nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看所有已启动的服务</span></span><br><span class="line">systemctl list -units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 开启防火墙 22 端口</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -j accept</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 彻底关闭防火墙</span></span><br><span class="line">sudo systemctl status firewalld.service</span><br><span class="line">sudo systemctl stop firewalld.service</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><blockquote><p>service 命令是 Redhat Linux 兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p><p>参考：<a href="http://man.linuxde.net/service">http://man.linuxde.net/service</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service network status</span><br><span class="line">配置设备：</span><br><span class="line">lo eth0</span><br><span class="line">当前的活跃设备：</span><br><span class="line">lo eth0</span><br><span class="line"></span><br><span class="line">service network restart</span><br><span class="line">正在关闭接口 eth0：                                        [  确定  ]</span><br><span class="line">关闭环回接口：                                             [  确定  ]</span><br><span class="line">设置网络参数：                                             [  确定  ]</span><br><span class="line">弹出环回接口：                                             [  确定  ]</span><br><span class="line">弹出界面 eth0：                                            [  确定  ]</span><br></pre></td></tr></table></figure><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><blockquote><p>crontab 命令被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>参考：<a href="http://man.linuxde.net/crontab">http://man.linuxde.net/crontab</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每 1 分钟执行一次 command</span></span><br><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 * * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个星期一的上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每晚的 21:30 重启 smb</span></span><br><span class="line">30 21 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月 1、10、22 日的 4 : 45 重启 smb</span></span><br><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周六、周日的 1:10 重启 smb</span></span><br><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 smb</span></span><br><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每星期六的晚上 11:00 pm 重启 smb</span></span><br><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一小时重启 smb</span></span><br><span class="line">* */1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 晚上 11 点到早上 7 点之间，每隔一小时重启 smb</span></span><br><span class="line">* 23-7/1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月的 4 号与每周一到周三的 11 点重启 smb</span></span><br><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一月一号的 4 点重启 smb</span></span><br><span class="line">0 4 1 jan * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时执行`/etc/cron.hourly`目录内的脚本</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure><h2 id="Linux-网络管理命令"><a href="#Linux-网络管理命令" class="headerlink" title="Linux 网络管理命令"></a>Linux 网络管理命令</h2><h3 id="Linux-网络应用要点"><a href="#Linux-网络应用要点" class="headerlink" title="Linux 网络应用要点"></a>Linux 网络应用要点</h3><ul><li><strong>下载文件 - 使用 curl、wget</strong></li><li><strong>telnet 方式登录远程主机，对远程主机进行管理 - 使用 telnet</strong></li><li><strong>查看或操纵 Linux 主机的路由、网络设备、策略路由和隧道 - 使用 ip</strong></li><li>查看和设置系统的主机名 - 使用 hostname</li><li><strong>查看和配置 Linux 内核中网络接口的网络参数 - 使用 ifconfig</strong></li><li><strong>查看和设置 Linux 内核中的网络路由表 - 使用 route</strong></li><li><strong>ssh 方式连接远程主机 - 使用 ssh</strong></li><li><strong>为 ssh 生成、管理和转换认证密钥 - 使用 ssh-keygen</strong></li><li><strong>查看、设置防火墙（Centos7），使用 firewalld</strong></li><li>查看、设置防火墙（Centos7 以前），使用 iptables</li><li>查看域名信息 - 使用 host, nslookup</li><li>设置路由 - 使用 nc/netcat</li><li><strong>测试主机之间网络是否连通 - 使用 ping</strong></li><li>追踪数据在网络上的传输时的全部路径 - 使用 traceroute</li><li><strong>查看当前工作的端口信息 - 使用 netstat</strong></li></ul><h3 id="命令常见用法-6"><a href="#命令常见用法-6" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote><p>curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl 可以祝一臂之力。</p><p>参考：<a href="http://man.linuxde.net/curl">http://man.linuxde.net/curl</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件，指定下载路径，并查看进度</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">########################################## 100.0%</span></span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><blockquote><p>wget 命令用来从指定的 URL 下载文件。</p><p>参考：<a href="http://man.linuxde.net/wget">http://man.linuxde.net/wget</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 wget 下载单个文件</span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br></pre></td></tr></table></figure><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><blockquote><p>telnet 命令用于登录远程主机，对远程主机进行管理。</p><p>参考：<a href="http://man.linuxde.net/telnet">http://man.linuxde.net/telnet</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.2.10</span><br><span class="line">Trying 192.168.2.10...</span><br><span class="line">Connected to 192.168.2.10 (192.168.2.10).</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release 2.6.18-274.18.1.el5 <span class="comment">#1 SMP Thu Feb 9 12:45:44 EST 2012) (1)</span></span><br><span class="line"></span><br><span class="line">login: root</span><br><span class="line">Password:</span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><blockquote><p>ip 命令用来查看或操纵 Linux 主机的路由、网络设备、策略路由和隧道，是 Linux 下较新的功能强大的网络配置工具。</p><p>参考：<a href="http://man.linuxde.net/ip">http://man.linuxde.net/ip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ip <span class="built_in">link</span> show                     <span class="comment"># 查看网络接口信息</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 upi             <span class="comment"># 开启网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down            <span class="comment"># 关闭网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on      <span class="comment"># 开启网卡的混合模式</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc offi    <span class="comment"># 关闭网卡的混个模式</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 txqueuelen 1200 <span class="comment"># 设置网卡队列长度</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 mtu 1400        <span class="comment"># 设置网卡最大传输单元</span></span><br><span class="line">$ ip addr show     <span class="comment"># 查看网卡IP信息</span></span><br><span class="line">$ ip addr add 192.168.0.1/24 dev eth0 <span class="comment"># 设置eth0网卡IP地址192.168.0.1</span></span><br><span class="line">$ ip addr del 192.168.0.1/24 dev eth0 <span class="comment"># 删除eth0网卡IP地址</span></span><br><span class="line"></span><br><span class="line">$ ip route show <span class="comment"># 查看系统路由</span></span><br><span class="line">$ ip route add default via 192.168.1.254   <span class="comment"># 设置系统默认路由</span></span><br><span class="line">$ ip route list                 <span class="comment"># 查看路由信息</span></span><br><span class="line">$ ip route add 192.168.4.0/24  via  192.168.0.254 dev eth0 <span class="comment"># 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口</span></span><br><span class="line">$ ip route add default via  192.168.0.254  dev eth0        <span class="comment"># 设置默认网关为192.168.0.254</span></span><br><span class="line">$ ip route del 192.168.4.0/24   <span class="comment"># 删除192.168.4.0网段的网关</span></span><br><span class="line">$ ip route del default          <span class="comment"># 删除默认路由</span></span><br><span class="line">$ ip route delete 192.168.1.0/24 dev eth0 <span class="comment"># 删除路由</span></span><br></pre></td></tr></table></figure><h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><blockquote><p>hostname 命令用于查看和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改 <code>/etc/hosts</code> 和 <code>/etc/sysconfig/network</code> 的相关内容。</p><p>参考：<a href="http://man.linuxde.net/hostname">http://man.linuxde.net/hostname</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">AY1307311912260196fcZ</span><br></pre></td></tr></table></figure><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><blockquote><p>ifconfig 命令被用于查看和配置 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p>参考：<a href="http://man.linuxde.net/ifconfig">http://man.linuxde.net/ifconfig</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络设备信息（激活状态的）</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51</span><br><span class="line">          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)</span><br></pre></td></tr></table></figure><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><blockquote><p>route 命令用来查看和设置 Linux 内核中的网络路由表，route 命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p><p>参考：<a href="http://man.linuxde.net/route">http://man.linuxde.net/route</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前路由</span></span><br><span class="line">route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    *               255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      *               255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">default         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br><span class="line"></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    <span class="comment"># 添加网关/设置网关</span></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject      <span class="comment"># 屏蔽一条路由</span></span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0             <span class="comment"># 删除路由记录</span></span><br><span class="line">route add default gw 192.168.120.240                   <span class="comment"># 添加默认网关</span></span><br><span class="line">route del default gw 192.168.120.240                   <span class="comment"># 删除默认网关</span></span><br></pre></td></tr></table></figure><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><blockquote><p>ssh 命令是 openssh 套件中的客户端连接工具，可以给予 ssh 加密协议实现安全的远程登录服务器。</p><p>参考：<a href="http://man.linuxde.net/ssh">http://man.linuxde.net/ssh</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh 用户名@远程服务器地址</span></span><br><span class="line">ssh user1@172.24.210.101</span><br><span class="line"><span class="comment"># 指定端口</span></span><br><span class="line">ssh -p 2211 root@140.206.185.170</span><br></pre></td></tr></table></figure><p>引申阅读：<a href="https://linux.cn/article-8476-1.html">ssh 背后的故事(opens new window)</a></p><h4 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h4><blockquote><p>ssh-keygen 命令用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。</p><p>参考：<a href="http://man.linuxde.net/ssh-keygen">http://man.linuxde.net/ssh-keygen</a></p></blockquote><h4 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h4><blockquote><p>firewalld 命令是 Linux 上的防火墙软件（Centos7 默认防火墙）。</p><p>参考：<a href="https://www.cnblogs.com/moxiaoan/p/5683743.html">https://www.cnblogs.com/moxiaoan/p/5683743.html</a></p></blockquote><h5 id="1-firewalld-的基本使用"><a href="#1-firewalld-的基本使用" class="headerlink" title="1. firewalld 的基本使用"></a>1. firewalld 的基本使用</h5><ul><li>启动 - systemctl start firewalld</li><li>关闭 - systemctl stop firewalld</li><li>查看状态 - systemctl status firewalld</li><li>开机禁用 - systemctl disable firewalld</li><li>开机启用 - systemctl enable firewalld</li></ul><h5 id="2-使用-systemctl-管理-firewalld-服务"><a href="#2-使用-systemctl-管理-firewalld-服务" class="headerlink" title="2. 使用 systemctl 管理 firewalld 服务"></a>2. 使用 systemctl 管理 firewalld 服务</h5><p>systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和 chkconfig 的功能于一体。</p><ul><li>启动一个服务 - systemctl start firewalld.service</li><li>关闭一个服务 - systemctl stop firewalld.service</li><li>重启一个服务 - systemctl restart firewalld.service</li><li>显示一个服务的状态 - systemctl status firewalld.service</li><li>在开机时启用一个服务 - systemctl enable firewalld.service</li><li>在开机时禁用一个服务 - systemctl disable firewalld.service</li><li>查看服务是否开机启动 - systemctl is-enabled firewalld.service</li><li>查看已启动的服务列表 - systemctl list-unit-files|grep enabled</li><li>查看启动失败的服务列表 - systemctl —failed</li></ul><h5 id="3-配置-firewalld-cmd"><a href="#3-配置-firewalld-cmd" class="headerlink" title="3. 配置 firewalld-cmd"></a>3. 配置 firewalld-cmd</h5><ul><li>查看版本 - firewall-cmd —version</li><li>查看帮助 - firewall-cmd —help</li><li>显示状态 - firewall-cmd —state</li><li>查看所有打开的端口 - firewall-cmd —zone=public —list-ports</li><li>更新防火墙规则 - firewall-cmd —reload</li><li>查看区域信息: firewall-cmd —get-active-zones</li><li>查看指定接口所属区域 - firewall-cmd —get-zone-of-interface=eth0</li><li>拒绝所有包：firewall-cmd —panic-on</li><li>取消拒绝状态 - firewall-cmd —panic-off</li><li>查看是否拒绝 - firewall-cmd —query-panic</li></ul><h5 id="4-在防火墙中开放一个端口"><a href="#4-在防火墙中开放一个端口" class="headerlink" title="4. 在防火墙中开放一个端口"></a>4. 在防火墙中开放一个端口</h5><ul><li>添加（—permanent 永久生效，没有此参数重启后失效） - firewall-cmd —zone=public —add-port=80/tcp —permanent</li><li>重新载入 - firewall-cmd —reload</li><li>查看 - firewall-cmd —zone= public —query-port=80/tcp</li><li>删除 - firewall-cmd —zone= public —remove-port=80/tcp —permanent</li></ul><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><blockquote><p>iptables 命令是 Linux 上常用的防火墙软件，是 netfilter 项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p><p>参考：<a href="http://man.linuxde.net/iptables">http://man.linuxde.net/iptables</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放指定的端口</span></span><br><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               <span class="comment">#允许本地回环接口(即运行本机访问本机)</span></span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    <span class="comment">#允许已建立的或相关连的通行</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT         <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    <span class="comment">#允许访问22端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    <span class="comment">#允许访问80端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT    <span class="comment">#允许ftp服务的21端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT    <span class="comment">#允许FTP服务的20端口</span></span><br><span class="line">iptables -A INPUT -j reject       <span class="comment">#禁止其他未允许的规则访问</span></span><br><span class="line">iptables -A FORWARD -j REJECT     <span class="comment">#禁止其他未允许的规则访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 屏蔽IP</span></span><br><span class="line">iptables -I INPUT -s 123.45.6.7 -j DROP       <span class="comment">#屏蔽单个IP的命令</span></span><br><span class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP      <span class="comment">#封整个段即从123.0.0.1到123.255.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP    <span class="comment">#封IP段即从123.45.0.1到123.45.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP    <span class="comment">#封IP段即从123.45.6.1到123.45.6.254的命令是</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已添加的iptables规则</span></span><br><span class="line">iptables -L -n -v</span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><blockquote><p>host 命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。</p><p>参考：<a href="http://man.linuxde.net/host">http://man.linuxde.net/host</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># host www.jsdig.com</span></span><br><span class="line">www.jsdig.com is an <span class="built_in">alias</span> <span class="keyword">for</span> host.1.jsdig.com.</span><br><span class="line">host.1.jsdig.com has address 100.42.212.8</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># host -a www.jsdig.com</span></span><br><span class="line">Trying <span class="string">&quot;www.jsdig.com&quot;</span></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 34671</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.jsdig.com.               IN      ANY</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.jsdig.com.        463     IN      CNAME   host.1.jsdig.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Received 54 bytes from 202.96.104.15#53 in 0 ms</span></span><br></pre></td></tr></table></figure><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><blockquote><p>nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。</p><p>参考：<a href="http://man.linuxde.net/nslookup">http://man.linuxde.net/nslookup</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nslookup www.jsdig.com</span></span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.jsdig.com canonical name = host.1.jsdig.com.</span><br><span class="line">Name:   host.1.jsdig.com</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure><h4 id="nc-netcat"><a href="#nc-netcat" class="headerlink" title="nc/netcat"></a>nc/netcat</h4><blockquote><p>nc 命令是 netcat 命令的简称，都是用来设置路由器。</p><p>参考：<a href="http://man.linuxde.net/nc_netcat">http://man.linuxde.net/nc_netcat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP 端口扫描</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -v -z -w2 192.168.0.3 1-100</span></span><br><span class="line">192.168.0.3: inverse host lookup failed: Unknown host</span><br><span class="line">(UNKNOWN) [192.168.0.3] 80 (http) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 23 (telnet) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 22 (ssh) open</span><br><span class="line"></span><br><span class="line"><span class="comment"># UDP 端口扫描</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -u -z -w2 192.168.0.1 1-1000  # 扫描192.168.0.3 的端口 范围是 1-1000</span></span><br></pre></td></tr></table></figure><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><blockquote><p>ping 命令用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>参考：<a href="http://man.linuxde.net/ping">http://man.linuxde.net/ping</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@AY1307311912260196fcZ ~]<span class="comment"># ping www.jsdig.com</span></span><br><span class="line">PING host.1.jsdig.com (100.42.212.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=1 ttl=50 time=177 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=2 ttl=50 time=178 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=3 ttl=50 time=174 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=4 ttl=50 time=177 ms</span><br><span class="line">...按Ctrl+C结束</span><br><span class="line"></span><br><span class="line">--- host.1.jsdig.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2998ms</span><br><span class="line">rtt min/avg/max/mdev = 174.068/176.916/178.182/1.683 ms</span><br></pre></td></tr></table></figure><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><blockquote><p>traceroute 命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。</p><p>参考：<a href="http://man.linuxde.net/traceroute">http://man.linuxde.net/traceroute</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.58.com</span><br><span class="line">traceroute to www.58.com (211.151.111.30), 30 hops max, 40 byte packets</span><br><span class="line"> 1  unknown (192.168.2.1)  3.453 ms  3.801 ms  3.937 ms</span><br><span class="line"> 2  221.6.45.33 (221.6.45.33)  7.768 ms  7.816 ms  7.840 ms</span><br><span class="line"> 3  221.6.0.233 (221.6.0.233)  13.784 ms  13.827 ms 221.6.9.81 (221.6.9.81)  9.758 ms</span><br><span class="line"> 4  221.6.2.169 (221.6.2.169)  11.777 ms 122.96.66.13 (122.96.66.13)  34.952 ms 221.6.2.53 (221.6.2.53)  41.372 ms</span><br><span class="line"> 5  219.158.96.149 (219.158.96.149)  39.167 ms  39.210 ms  39.238 ms</span><br><span class="line"> 6  123.126.0.194 (123.126.0.194)  37.270 ms 123.126.0.66 (123.126.0.66)  37.163 ms  37.441 ms</span><br><span class="line"> 7  124.65.57.26 (124.65.57.26)  42.787 ms  42.799 ms  42.809 ms</span><br><span class="line"> 8  61.148.146.210 (61.148.146.210)  30.176 ms 61.148.154.98 (61.148.154.98)  32.613 ms  32.675 ms</span><br><span class="line"> 9  202.106.42.102 (202.106.42.102)  44.563 ms  44.600 ms  44.627 ms</span><br><span class="line">10  210.77.139.150 (210.77.139.150)  53.302 ms  53.233 ms  53.032 ms</span><br><span class="line">11  211.151.104.6 (211.151.104.6)  39.585 ms  39.502 ms  39.598 ms</span><br><span class="line">12  211.151.111.30 (211.151.111.30)  35.161 ms  35.938 ms  36.005 ms</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><blockquote><p>netstat 命令用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。</p><p>参考：<a href="http://man.linuxde.net/netstat">http://man.linuxde.net/netstat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有端口 (包括监听和未监听的)</span></span><br><span class="line">netstat -a     <span class="comment">#列出所有端口</span></span><br><span class="line">netstat -at    <span class="comment">#列出所有tcp端口</span></span><br><span class="line">netstat -au    <span class="comment">#列出所有udp端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有处于监听状态的 Sockets</span></span><br><span class="line">netstat -l        <span class="comment">#只显示监听端口</span></span><br><span class="line">netstat -lt       <span class="comment">#只列出所有监听 tcp 端口</span></span><br><span class="line">netstat -lu       <span class="comment">#只列出所有监听 udp 端口</span></span><br><span class="line">netstat -lx       <span class="comment">#只列出所有监听 UNIX 端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示每个协议的统计信息</span></span><br><span class="line">netstat -s   显示所有端口的统计信息</span><br><span class="line">netstat -st   显示TCP端口的统计信息</span><br><span class="line">netstat -su   显示UDP端口的统计信息</span><br></pre></td></tr></table></figure><h2 id="Linux-硬件管理命令"><a href="#Linux-硬件管理命令" class="headerlink" title="Linux 硬件管理命令"></a>Linux 硬件管理命令</h2><h3 id="Linux-硬件管理要点"><a href="#Linux-硬件管理要点" class="headerlink" title="Linux 硬件管理要点"></a>Linux 硬件管理要点</h3><ul><li><strong>查看磁盘空间 - 使用 df</strong></li><li>查看文件或目录的磁盘空间 - 使用 du</li><li><strong>实时查看系统整体运行状态（如：CPU、内存） - 使用 top</strong></li><li><strong>查看已使用和未使用的内存 - 使用 free</strong></li><li>查看磁盘 I/O 使用状况 - 使用 iotop</li></ul><h3 id="命令常见用法-7"><a href="#命令常见用法-7" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><blockquote><p>df 命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>参考：<a href="http://man.linuxde.net/df">http://man.linuxde.net/df</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统磁盘设备，默认是 KB 为单位</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df</span></span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h 选项以 KB 以上的单位来显示，可读性高</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df -h</span></span><br><span class="line">文件系统              容量  已用 可用 已用% 挂载点</span><br><span class="line">/dev/sda2             140G   27G  106G  21% /</span><br><span class="line">/dev/sda1             996M   61M  884M   7% /boot</span><br><span class="line">tmpfs                1009M     0 1009M   0% /dev/shm</span><br><span class="line">/dev/sdb1             2.7T  209G  2.4T   8% /data1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全部文件系统</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df -a</span></span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">proc                         0         0         0   -  /proc</span><br><span class="line">sysfs                        0         0         0   -  /sys</span><br><span class="line">devpts                       0         0         0   -  /dev/pts</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br><span class="line">none                         0         0         0   -  /proc/sys/fs/binfmt_misc</span><br></pre></td></tr></table></figure><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><blockquote><p>du 命令也是查看使用空间的，但是与 df 命令不同的是：du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的。</p><p>参考：<a href="http://man.linuxde.net/du">http://man.linuxde.net/du</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示目录或者文件所占空间</span></span><br><span class="line">root@localhost [<span class="built_in">test</span>]<span class="comment"># du</span></span><br><span class="line">608 ./test6</span><br><span class="line">308 ./test4</span><br><span class="line">4 ./scf/lib</span><br><span class="line">4 ./scf/service/deploy/product</span><br><span class="line">4 ./scf/service/deploy/info</span><br><span class="line">12 ./scf/service/deploy</span><br><span class="line">16 ./scf/service</span><br><span class="line">4 ./scf/doc</span><br><span class="line">4 ./scf/bin</span><br><span class="line">32 ./scf</span><br><span class="line">8 ./test3</span><br><span class="line">1288 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du log2012.log</span></span><br><span class="line">300 log2012.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定目录的所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du scf</span></span><br><span class="line">4 scf/lib</span><br><span class="line">4 scf/service/deploy/product</span><br><span class="line">4 scf/service/deploy/info</span><br><span class="line">12 scf/service/deploy</span><br><span class="line">16 scf/service</span><br><span class="line">4 scf/doc</span><br><span class="line">4 scf/bin</span><br><span class="line">32 scf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示多个文件所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du log30.tar.gz log31.tar.gz</span></span><br><span class="line">4 log30.tar.gz</span><br><span class="line">4 log31.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示总和的大小</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du -s</span></span><br><span class="line">1288 .</span><br><span class="line"></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du -s scf</span></span><br><span class="line">32 scf</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><blockquote><p>top 命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。</p><p>参考：<a href="http://man.linuxde.net/top">http://man.linuxde.net/top</a></p></blockquote><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><blockquote><p>free 命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p><p>参考：<a href="http://man.linuxde.net/free">http://man.linuxde.net/free</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">free -t    <span class="comment"># 以总和的形式显示内存的使用信息</span></span><br><span class="line">free -s 10 <span class="comment"># 周期性的查询内存使用信息，每10s 执行一次命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示内存使用情况</span></span><br><span class="line"></span><br><span class="line">free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          2016       1973         42          0        163       1497</span><br><span class="line">-/+ buffers/cache:        312       1703</span><br><span class="line">Swap:         4094          0       4094</span><br></pre></td></tr></table></figure><h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><blockquote><p>iotop 命令是一个用来监视磁盘 I/O 使用状况的 top 类工具。iotop 具有与 top 相似的 UI，其中包括 PID、用户、I/O、进程等相关信息。Linux 下的 IO 统计工具如 iostat，nmon 等大多数是只能统计到 per 设备的读写情况，如果你想知道每个进程是如何使用 IO 的就比较麻烦，使用 iotop 命令可以很方便的查看。</p><p>参考：<a href="http://man.linuxde.net/iotop">http://man.linuxde.net/iotop</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Total DISK <span class="built_in">read</span>:       0.00 B/s | Total DISK write:       0.00 B/s</span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    <span class="built_in">command</span></span><br><span class="line">    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init [3]</span><br><span class="line">    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line">    3 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">    4 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">    5 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]</span><br><span class="line">    6 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/1]</span><br><span class="line">    7 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/1]</span><br><span class="line">    8 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/1]</span><br><span class="line">    9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [events/0]</span><br><span class="line">   10 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [events/1]</span><br><span class="line">   11 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [khelper]</span><br><span class="line">2572 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [bluetooth]</span><br></pre></td></tr></table></figure><h2 id="Linux-软件管理命令"><a href="#Linux-软件管理命令" class="headerlink" title="Linux 软件管理命令"></a>Linux 软件管理命令</h2><h3 id="1-rpm"><a href="#1-rpm" class="headerlink" title="1. rpm"></a>1. rpm</h3><blockquote><p>rpm 命令是 RPM 软件包的管理工具。rpm 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p><p>参考：<a href="http://man.linuxde.net/rpm">http://man.linuxde.net/rpm</a></p></blockquote><p>示例：</p><p>（1）安装 rpm 包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure><p>（2）安装.src.rpm 软件包</p><p>这类软件包是包含了源代码的 rpm 包，在安装时需要进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -i xxx.src.rpm</span><br><span class="line"><span class="built_in">cd</span> /usr/src/redhat/SPECS</span><br><span class="line">rpmbuild -bp xxx.specs             <span class="comment">#一个和你的软件包同名的specs文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/src/redhat/BUILD/xxx/      <span class="comment">#一个和你的软件包同名的目录</span></span><br><span class="line">./configure                        <span class="comment">#这一步和编译普通的源码软件一样，可以加上参数</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>（3）卸载 rpm 软件包</p><p>使用命令 <code>rpm -e 包名</code>，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包 proftpd-1.2.8-1，可以使用下列格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1</span><br><span class="line">rpm -e proftpd-1.2.8</span><br><span class="line">rpm -e proftpd-</span><br><span class="line">rpm -e proftpd</span><br></pre></td></tr></table></figure><p>不可以是下列格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1.i386.rpm</span><br><span class="line">rpm -e proftpd-1.2.8-1.i386</span><br><span class="line">rpm -e proftpd-1.2</span><br><span class="line">rpm -e proftpd-1</span><br></pre></td></tr></table></figure><p>有时会出现一些错误或者警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... is needed by ...</span><br></pre></td></tr></table></figure><p>这说明这个软件被其他软件需要，不能随便卸载，可以用 rpm -e —nodeps 强制卸载</p><p>（4）查看与 rpm 包相关的文件和其他信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa <span class="comment"># 列出所有安装过的包</span></span><br></pre></td></tr></table></figure><h3 id="2-yum"><a href="#2-yum" class="headerlink" title="2. yum"></a>2. yum</h3><blockquote><p>yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理 RPM 软件包，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>参考：<a href="http://man.linuxde.net/yum">http://man.linuxde.net/yum</a></p></blockquote><p>示例：</p><p>部分常用的命令包括：</p><ul><li>自动搜索最快镜像插件：<code>yum install yum-fastestmirror</code></li><li>安装 yum 图形窗口插件：<code>yum install yumex</code></li><li>查看可能批量安装的列表：<code>yum grouplist</code></li></ul><p><strong>安装</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install              #全部安装</span><br><span class="line">yum install package1     #安装指定的安装包package1</span><br><span class="line">yum groupinsall group1   #安装程序组group1</span><br></pre></td></tr></table></figure><p><strong>更新和升级</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update               #全部更新</span><br><span class="line">yum update package1      #更新指定程序包package1</span><br><span class="line">yum check-update         #检查可更新的程序</span><br><span class="line">yum upgrade package1     #升级指定程序包package1</span><br><span class="line">yum groupupdate group1   #升级程序组group1</span><br></pre></td></tr></table></figure><p><strong>查找和显示</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum info package1      #显示安装包信息package1</span><br><span class="line">yum list               #显示所有已经安装和可以安装的程序包</span><br><span class="line">yum list package1      #显示指定程序包安装情况package1</span><br><span class="line">yum groupinfo group1   #显示程序组group1信息yum search string 根据关键字string查找安装包</span><br><span class="line">yum search &lt;keyword&gt;   #查找软件包</span><br></pre></td></tr></table></figure><p><strong>删除程序</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum remove &lt;package_name&gt;          #删除程序包package_name</span><br><span class="line">yum groupremove group1             #删除程序组group1</span><br><span class="line">yum deplist package1               #查看程序package1依赖情况</span><br></pre></td></tr></table></figure><p><strong>清除缓存</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean packages       #清除缓存目录下的软件包</span><br><span class="line">yum clean headers        #清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders     #清除缓存目录下旧的 headers</span><br></pre></td></tr></table></figure><h4 id="2-1-yum-源"><a href="#2-1-yum-源" class="headerlink" title="2.1. yum 源"></a>2.1. yum 源</h4><p>yum 的默认源是国外的，下载速度比较慢，所以最好替换为一个国内的 yum 源。</p><div class="table-container"><table><thead><tr><th>推荐 yum 国内源</th><th>源地址</th></tr></thead><tbody><tr><td><a href="http://mirrors.163.com/">http://mirrors.163.com/(opens new window)</a></td><td>Centos6：<a href="http://mirrors.aliyun.com/repo/Centos-6.repo">http://mirrors.aliyun.com/repo/Centos-6.repo</a> Centos7：<a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></td></tr><tr><td><a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/(opens new window)</a></td><td>Centos6：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a> Centos7：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></td></tr></tbody></table></div><blockquote><p>🔔 注意：Cento5 已废弃，只能使用 <a href="http://vault.centos.org/">http://vault.centos.org/</a> 替换，但由于是国外镜像，速度较慢。</p></blockquote><p>替换方法，以 aliyun CentOS7 为例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h3 id="3-apt-get"><a href="#3-apt-get" class="headerlink" title="3. apt-get"></a>3. apt-get</h3><blockquote><p>apt-get 命令是 Debian Linux 发行版中的 APT 软件包管理工具。所有基于 Debian 的发行都使用这个包管理系统。deb 包可以把一个应用的文件包在一起，大体就如同 Windows 上的安装文件。</p><p>参考：<a href="http://man.linuxde.net/apt-get">http://man.linuxde.net/apt-get</a></p></blockquote><p>示例：</p><p>使用 apt-get 命令的第一步就是引入必需的软件库，Debian 的软件库也就是所有 Debian 软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get 就能搜索到我们想要的软件。/etc/apt/sources.list 是存放这些地址列表的配置文件，其格式如下：</p><p>deb [web 或 ftp 地址][发行版名字] [main/contrib/non-free] 我们常用的 Ubuntu 就是一个基于 Debian 的发行，我们使用 apt-get 命令获取这个列表，以下是我整理的常用命令：</p><p>在修改 /etc/apt/sources.list 或者 /etc/apt/preferences 之后运行该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 apt-get</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装一个软件包</span></span><br><span class="line">apt-get install packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载一个已安装的软件包（保留配置文件）</span></span><br><span class="line">apt-get remove packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载一个已安装的软件包（删除配置文件）</span></span><br><span class="line">apt-get –purge remove packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要空间的话，可以让这个命令来删除你已经删掉的软件</span></span><br><span class="line">apt-get autoclean apt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把安装的软件的备份也删除，不过这样不会影响软件的使用的</span></span><br><span class="line">apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新所有已安装的软件包</span></span><br><span class="line">apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将系统升级到新版本</span></span><br><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://dunwu.github.io/linux-tutorial/">https://dunwu.github.io/linux-tutorial/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/mingyry/69c3279c.html"/>
      <url>/mingyry/69c3279c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始本地库</p><p>默认分支名字 master</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>查看本地库状态</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505092414006.png" alt="image-20230505092414006"></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>添加文件到暂存区</p><h3 id="git-commit-m-“-”-文件名"><a href="#git-commit-m-“-”-文件名" class="headerlink" title="git commit -m “ ” 文件名"></a>git commit -m “ ” 文件名</h3><p>提交文件， 并且添加注释</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505092731838.png" alt="image-20230505092731838"></p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>查看版本日志信息</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>查看详细版本信息</p><h3 id="git-reset-—hard-版本号"><a href="#git-reset-—hard-版本号" class="headerlink" title="git reset —hard 版本号"></a>git reset —hard 版本号</h3><p>穿越版本</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505093003814.png" alt="image-20230505093003814"></p><h3 id="git分支模式"><a href="#git分支模式" class="headerlink" title="git分支模式"></a>git分支模式</h3><h4 id="git分支操作"><a href="#git分支操作" class="headerlink" title="git分支操作"></a>git分支操作</h4><ul><li><p>git branch 分支名</p><p>创建分支</p></li><li><p>git branch -v</p><p>查看分支</p></li><li><p>git checkout 分支名</p><p>转换到当前分支名</p></li><li><p>git merge 分支名1</p><p>合并分支名1到当前的分支</p></li></ul><h4 id="git冲突"><a href="#git冲突" class="headerlink" title="git冲突"></a>git冲突</h4><p>git无法自动合并两个文件，需要人为解决冲突</p><ol><li><p>解决冲突</p></li><li><p>添加到暂存区</p></li><li><p>提交文件</p><p>不能带文件名的提交</p></li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505094234284.png" alt="image-20230505094234284"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="创建远程库"><a href="#创建远程库" class="headerlink" title="创建远程库"></a>创建远程库</h3><h4 id="查看远程库别名"><a href="#查看远程库别名" class="headerlink" title="查看远程库别名"></a>查看远程库别名</h4><p>git remote -v</p><h4 id="创建远程库别名"><a href="#创建远程库别名" class="headerlink" title="创建远程库别名"></a>创建远程库别名</h4><p>git remote add 别名 原名</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505095327663.png" alt="image-20230505095327663"></p><h4 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h4><p>git push 别名 分支</p><p>推送远程库的最小单位是分支</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505095500365.png" alt="image-20230505095500365"></p><h4 id="拉取远程库"><a href="#拉取远程库" class="headerlink" title="拉取远程库"></a>拉取远程库</h4><p>git pull 别名 分支</p><h3 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h3><p>git clone 地址</p><p>不需要登录账号</p><p>clone：拉取代码，初始化本地库，创建别名</p><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><ol><li><p>修改文件，推送到远程库</p></li><li><p>需要主创建人邀请合作者</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505100250747.png" alt="image-20230505100250747"></p></li><li><p>合作者复制邀请函，接受邀请，才可以推送到远程库</p></li></ol><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ol><li>点击fork 插入到自己的仓库中</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505100624625.png" alt="image-20230505100624625"></p><ol><li>pull request 请求提交到对方的库中</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505100725609.png" alt="image-20230505100725609"></p><ol><li>主创建人，接收提交</li></ol><h3 id="SSH免密码登录"><a href="#SSH免密码登录" class="headerlink" title="SSH免密码登录"></a>SSH免密码登录</h3><ol><li><p>生成ssh密钥</p><p>ssh-keygen -t rsa -C 用户邮箱</p></li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505101111933.png" alt="image-20230505101111933"></p><ol><li>复制公钥 .pub文件是公钥</li><li>添加公钥到github上</li><li>利用SSH拉取代码</li></ol><h2 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h2><h3 id="配置Git忽略文件"><a href="#配置Git忽略文件" class="headerlink" title="配置Git忽略文件"></a>配置Git忽略文件</h3><p>.ignore 一般放在用户的java目录下</p><p>在gitconfig里面引用忽略文件</p><h3 id="定位Git程序"><a href="#定位Git程序" class="headerlink" title="定位Git程序"></a>定位Git程序</h3><p>找到Git 配置Git的安装目录</p><p>IDEA 中VCS 创建git本地库</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505102055131.png" alt="image-20230505102055131"></p><h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><p>add和commit提交本地库</p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p>Version Control</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505102334621.png" alt="image-20230505102334621"></p><p>当前显示的版本head 和绿色表示分支</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505102453635.png" alt="image-20230505102453635"></p><p>右键checkout切换版本</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>New branch</p><p>选择Merge into Current</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505102912076.png" alt="image-20230505102912076"></p><p>IDEA 合并冲突</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505103005283.png" alt="image-20230505103005283"></p><h4 id="IDEA集成Github"><a href="#IDEA集成Github" class="headerlink" title="IDEA集成Github"></a>IDEA集成Github</h4><ol><li><p>设置github账号</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505103123640.png" alt="image-20230505103123640"></p></li><li><p>也可以使用Token登录</p></li><li><p>分享项目到github</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505103322685.png" alt="image-20230505103322685"></p></li></ol><ol><li><p>推送分支到远程库，可以调整推送到哪个库，利用remote进行设置</p><p>如果本地库代码跟远程库代码版本不一致，推送操作会被拒绝，因此，想要push成功，一定要保证本地库的版本要比远程库的版本高</p><p>先检查远程库和本地代码的区别，如果本地代码版本落后，切记先pull远程库的代码</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505140121121.png" alt="image-20230505140121121"></p></li><li><p>拉取远程库的代码</p></li><li><p>clone 克隆远程库代码到本地</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505140620112.png" alt=""></p></li></ol><h3 id="自建GitLab"><a href="#自建GitLab" class="headerlink" title="自建GitLab"></a>自建GitLab</h3><p>基于网络的Git仓库管理工具</p><p>下载安装包</p><p>参考官网安装gitlab，使用脚本，添加脚本，运行脚本</p><h3 id="初始化GitLab服务"><a href="#初始化GitLab服务" class="headerlink" title="初始化GitLab服务"></a>初始化GitLab服务</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505141601050.png" alt="image-20230505141601050"></p><h3 id="启动GitLab服务"><a href="#启动GitLab服务" class="headerlink" title="启动GitLab服务"></a>启动GitLab服务</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230505141638913.png" alt="image-20230505141638913"></p><h3 id="使用浏览器访问GitLab服务"><a href="#使用浏览器访问GitLab服务" class="headerlink" title="使用浏览器访问GitLab服务"></a>使用浏览器访问GitLab服务</h3><p>如果想要通过主机名访问，需要在Window中配置映射</p><p>首次登录，需要设置密码</p><h3 id="IDEA集成GitLab"><a href="#IDEA集成GitLab" class="headerlink" title="IDEA集成GitLab"></a>IDEA集成GitLab</h3><p>安装gitlab插件</p><p>只要GitLab的远程库定义好以后，操作和github与码云一直</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/mingyry/6c92115f.html"/>
      <url>/mingyry/6c92115f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-的优点"><a href="#Spring-的优点" class="headerlink" title="Spring 的优点"></a>Spring 的优点</h2><p>（1）spring属于低侵入式设计，代码的污染极低；</p><p>（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>（4）spring对于主流的应用框架提供了集成支持</p><h2 id="IOC体系结构"><a href="#IOC体系结构" class="headerlink" title="IOC体系结构"></a>IOC体系结构</h2><ul><li>BeanFactory：工厂模式定义了IOC容器的基本功能规范</li><li>BeanRegistry：向IOC容器手工注册BeanDefinition对象的方法</li><li>BeanDefinition：定义了各种Bean对象及其相互的关系</li><li>BeanDefinitionReader：BeanDefition的解析器</li><li>BeanDefinitionHolder：BeanDefition的包装类，用来存储BeanDefinition，name，以及aliases等</li></ul><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>继承了BeanFactory，拥有对Bean的管理外，还包含了：</p><ul><li>访问资源：对不同方式的Bean配置（即资源）进行加载（ResourcePatternResolver接口）</li><li>国际化：支持信息源，可以实现国际化（MessageSource接口）</li><li>应用事件：支持应用事件（ApplicationEventPublisher）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/spring-framework-ioc-source-71.png" alt=""></p><h2 id="IOC容器初始化的基本步骤"><a href="#IOC容器初始化的基本步骤" class="headerlink" title="IOC容器初始化的基本步骤"></a>IOC容器初始化的基本步骤</h2><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230521165816288.png" alt="image-20230521165816288"></p><p>初始化的入口在容器实现中的 refresh()调用来完成</p><p>对 bean 定义载入 IOC 容器使用的方法是 loadBeanDefinition,其中的大致过程如下：</p><ul><li>通过 ResourceLoader 来完成资源文件位置的定位，DefaultResourceLoader 是默认的实现，同时上下文本身就给出了 ResourceLoader 的实现，可以从类路径，文件系统, URL 等方式来定为资源位置。如果是 XmlBeanFactory作为 IOC 容器，那么需要为它指定 bean 定义的资源，也就是说 bean 定义文件时通过抽象成 Resource 来被 IOC 容器处理的</li><li>通过 BeanDefinitionReader来完成定义信息的解析和 Bean 信息的注册, 往往使用的是XmlBeanDefinitionReader 来解析 bean 的 xml 定义文件 - 实际的处理过程是委托给 BeanDefinitionParserDelegate 来完成的，从而得到 bean 的定义信息，这些信息在 Spring 中使用 BeanDefinition 对象来表示 - 这个名字可以让我们想到loadBeanDefinition,RegisterBeanDefinition 这些相关的方法 - 他们都是为处理 BeanDefinitin 服务的</li><li>容器解析得到 BeanDefinition 以后，需要把它在 IOC 容器中注册，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</li></ul><p>然后我们就可以通过 BeanFactory 和 ApplicationContext 来享受到 Spring IOC 的服务了,在使用 IOC 容器的时候，我们注意到除了少量粘合代码，绝大多数以正确 IoC 风格编写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。 Spring 本身提供了对声明式载入 web 应用程序用法的应用程序上下文,并将其存储在ServletContext 中的框架实现</p><h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><h3 id="getBean-bean的获取方法的执行流程"><a href="#getBean-bean的获取方法的执行流程" class="headerlink" title="getBean() bean的获取方法的执行流程"></a>getBean() bean的获取方法的执行流程</h3><ul><li>解析bean的真正name，如果bean是工厂类，name前缀会加&amp;，需要去掉</li><li>无参单例先从缓存只尝试获取</li><li>如果bean实例还在创建中，则抛出异常</li><li>如果bean definition存在父的bean工厂中，委派给父Bean工厂获取</li><li>标记这个beanName实例正在创建</li><li>确保它的依赖也被初始化</li><li>真正创建<ul><li>单例</li><li>原型</li><li>根据bean的scope来创建</li></ul></li></ul><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230521173947193.png" alt="image-20230521173947193"></p><p><strong>Aware 接口</strong>是一组特殊的接口，用于将容器中的一些资源传递给特定的 Bean。这些接口都以 “Aware” 结尾，并提供了对应的回调方法，当 Bean 实例被创建时，Spring 容器会自动调用这些方法，将相关的资源注入到 Bean 中。这样，Bean 就可以获取容器提供的一些重要资源。</p><p>常见的 Aware 接口及其作用：</p><ol><li><strong>ApplicationContextAware：</strong> 实现这个接口的 Bean 可以获得 Spring 容器的 ApplicationContext 对象，从而可以获取容器中的其他 Bean。</li><li><strong>BeanFactoryAware：</strong> 实现这个接口的 Bean 可以获得 BeanFactory 对象，用于访问容器中的 Bean。</li><li><strong>BeanNameAware：</strong> 实现这个接口的 Bean 可以获得自己在 Spring 容器中的名字。</li><li><strong>MessageSourceAware：</strong> 实现这个接口的 Bean 可以获得用于国际化的 MessageSource，用于获取国际化的消息。</li><li><strong>ApplicationEventPublisherAware：</strong> 实现这个接口的 Bean 可以获得 ApplicationEventPublisher 对象，用于发布事件。</li><li><strong>ResourceLoaderAware：</strong> 实现这个接口的 Bean 可以获得 ResourceLoader 对象，用于加载资源。</li><li><strong>EnvironmentAware：</strong> 实现这个接口的 Bean 可以获得 Environment 对象，用于获取配置属性等信息。</li></ol><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><font color='red'>Spring只解决了通过setter方法进行依赖注入且是单例模式下产生的循环依赖问题</font><p><strong>未解决的</strong>：</p><ul><li><p>通过构造方法进行依赖注入时产生的循环依赖问题</p><p>new对象的时候会被阻塞，两个同时new</p></li><li><p>通过setter方法进行依赖注入时是在多例（原型）模式下产生的循环依赖问题</p><p>多例情况下，每一次getBean()都会产生一个新的Bean，最终导致OOM异常</p></li></ul><p><strong>三级缓存：</strong></p><ul><li><p>第一级缓存：</p><p>单例对象缓存池，已经实例化并且属性赋值，是成熟对象，可以直接使用</p></li><li><p>第二级缓存：</p><p>单例对象缓存池，已经实例化，但是未将属性赋值，半成品</p></li><li><p>第三级缓存：</p><p>单例工厂的缓存，当 Bean 创建的过程中需要依赖其他 Bean，但这些 Bean 还没有创建完成时，会将创建 Bean 的工厂放入三级缓存。当依赖的 Bean 创建完成后，会使用工厂来创建 Bean 并放入一级缓存中</p></li></ul><p><strong>解决办法：</strong></p><ul><li>先从一级缓存获取ClassA，没有获取到</li><li>实例化 ClassA，这时候属性没有赋值</li><li>将ClassA曝光到singletonFactories（三级缓存）中</li><li>依赖注入Class B</li><li>实例化 ClassB</li><li>ClassB 通过singleonFactories获取到A对象（半成品），将A放入到二级缓存中</li><li>初始化Class B， 将其放到一级缓存中</li><li>返回Class A ，这时A进行初始化ClassA</li><li>将其ClassA 自己放入到一级缓存中</li></ul><h3 id="为什么要使用三级缓存"><a href="#为什么要使用三级缓存" class="headerlink" title="为什么要使用三级缓存"></a>为什么要使用三级缓存</h3><p>一般的二级缓存就够用了，但是会出现代理的情况，如果一个对象实现了AOP，那么所注入的对象就是代理对象而不是原始对象。所以需要三级缓存来产生最终的代理对象</p><ol><li>Class A 实例化</li><li>将A放入到三级缓存中</li><li>Class A依赖注入Class B</li><li>实例化Class B</li><li>将Class B 放入到三级缓存中</li><li>Class B依赖注入ClassA</li><li>先获取A，然后使用AOP创建代理对象ClassA-AOP，放入二级缓存中</li><li>初始化B</li><li>将B放入一级缓存中</li><li>初始化A</li><li>执行后置处理器</li><li>从二级缓存中获取ClassA-AOP</li><li>初始化成功ClassA-AOP</li><li>然后将ClassA-AOP放入到一级缓存中</li></ol><h3 id="其它循环依赖如何解决？"><a href="#其它循环依赖如何解决？" class="headerlink" title="其它循环依赖如何解决？"></a>其它循环依赖如何解决？</h3><blockquote><p>那么实际开发中，类似的依赖是如何解决？</p></blockquote><ul><li><strong>生成代理对象产生的循环依赖</strong></li></ul><p>这类循环依赖问题解决方法很多，主要有：</p><ol><li>使用@Lazy注解，延迟加载</li><li>使用@DependsOn注解，指定加载先后关系</li><li>修改文件名称，改变循环依赖类的加载顺序</li></ol><ul><li><strong>使用@DependsOn产生的循环依赖</strong></li></ul><p>这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</p><ul><li><strong>多例循环依赖</strong></li></ul><p>这类循环依赖问题可以通过把bean改成单例的解决。</p><ul><li><strong>构造器循环依赖</strong></li></ul><p>这类循环依赖问题可以通过使用@Lazy注解解决</p><h3 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h3><ol><li>singleton：默认作用域，单例bean，每个容器中只有一个bean的实例</li><li>prototype：多例bean，每个bean请求创建一个实例</li><li>request：每个request请求创建实例，请求完成后，bean会失效并被垃圾回收期回收</li><li>session：同一个session会话共享一个实例，不同会话使用不同的实例</li><li>global-session：全局作用域，所有会话共享一个实例。</li></ol><h3 id="Spring-Bean是线程安全的还是不安全"><a href="#Spring-Bean是线程安全的还是不安全" class="headerlink" title="Spring Bean是线程安全的还是不安全"></a>Spring Bean是线程安全的还是不安全</h3><ol><li><p>对于protopyte作用域的bean：不存在线程安全问题</p></li><li><p>对于singleton作用域的bean：</p><ul><li><p>无状态bean：没有实例变量的bean，不能保存数据，是不变类，是线程安全的</p></li><li><p>有状态bean：有实例变量的bean，可以保存数据，非线程安全</p><p><strong>解决办法：</strong></p><ul><li>最简单的办法就是将单例bean变为多例bean</li><li>采取ThreadLocal解决线程安全问题，为每一个线程提供一个独立的变量副本，不同线程只操作自己的线程的副本变量</li></ul></li></ul></li></ol><h3 id="Spring-自动装配"><a href="#Spring-自动装配" class="headerlink" title="Spring 自动装配"></a>Spring 自动装配</h3><p><strong>@Autowired和@Resource的区别：</strong></p><ul><li>@Autowired默认按照类型装配注入，如果查询到的结果不止一个，会根据名称来查找</li><li><p>@Resource默认按照名称来装配注入，当找不到与名称匹配的bean才会按照类型来装配注入</p></li><li><p>@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上</p></li></ul><h4 id="使用属性注入出现的问题"><a href="#使用属性注入出现的问题" class="headerlink" title="使用属性注入出现的问题"></a>使用属性注入出现的问题</h4><ol><li><p>违背单一职责原则</p></li><li><p>容易导致Spring初始化失败</p><p>Java初始化一个类的顺序：静态变量或静态语句块-&gt;实例变量或初始化语句块-&gt;构造方法-&gt;@Autowired</p><p>可能属性在被注入之前就引用而导致npe（空指针错误）</p></li><li><p>通过@Autowired注入可能导致出现两个相同类型的bean</p></li></ol><h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><p>AOP将与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装成一个可用的模块。</p><p>AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><ul><li>AspectJ，静态代理，也称编译时增强，AOP框架会在编译阶段生成AOP代理类，并将Aspect(切面) 织入到Java字节码中，允许的时候就是增强后的AOP对象</li><li>Spring AOP使用动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个对象包含了目标对象的全部方法，并在特定的切点做了增强处理，并回调原对象的方法</li></ul><h2 id="Spring-AOP几个名词的概念："><a href="#Spring-AOP几个名词的概念：" class="headerlink" title="Spring AOP几个名词的概念："></a>Spring AOP几个名词的概念：</h2><p>（1）连接点（Join point）：指程序运行过程中所执行的方法。在Spring AOP中，一个连接点总代表一个方法的执行。 </p><p>（2）切面（Aspect）：被抽取出来的公共模块，可以用来会横切多个对象。Aspect切面可以看成 Pointcut切点 和 Advice通知 的结合，一个切面可以由多个切点和通知组成。</p><p>在Spring AOP中，切面可以在类上使用 @AspectJ 注解来实现。</p><p>（3）切点（Pointcut）：切点用于定义 要对哪些Join point进行拦截。</p><p>切点分为execution方式和annotation方式。execution方式可以用路径表达式指定对哪些方法拦截，比如指定拦截add<em>、search</em>。annotation方式可以指定被哪些注解修饰的代码进行拦截。</p><p>（4）通知（Advice）：指要在连接点（Join Point）上执行的动作，即增强的逻辑，比如权限校验和、日志记录等。通知有各种类型，包括Around、Before、After、After returning、After throwing。</p><p>（5）目标对象（Target）：包含连接点的对象，也称作被通知（Advice）的对象。 由于Spring AOP是通过动态代理实现的，所以这个对象永远是一个代理对象。</p><p>（6）织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程。</p><p>（7）引入（Introduction）：添加额外的方法或者字段到被通知的类。Spring允许引入新的接口（以及对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p><p>几个概念的关系图可以参考下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/2020120700443256.png" alt="img"></p><h2 id="AOP实现流程"><a href="#AOP实现流程" class="headerlink" title="AOP实现流程"></a>AOP实现流程</h2><p>由<strong>IOC Bean加载</strong>方法栈中找到parseCustomElement方法，找到parse <code>aop:aspectj-autoproxy</code>的handler(org.springframework.aop.config.AopNamespaceHandler)</p><p><strong>AopNamespaceHandler</strong>注册了<code>&lt;aop:aspectj-autoproxy/&gt;</code>的解析类是AspectJAutoProxyBeanDefinitionParser</p><p><strong>AspectJAutoProxyBeanDefinitionParser</strong>的parse 方法 通过AspectJAwareAdvisorAutoProxyCreator类去创建</p><p><strong>AspectJAwareAdvisorAutoProxyCreator</strong>实现了两类接口，BeanFactoryAware和BeanPostProcessor；根据Bean生命周期方法找到两个核心方法：postProcessBeforeInstantiation和postProcessAfterInitialization </p><ol><li><strong>postProcessBeforeInstantiation</strong>：主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应Advice，并将Advice连同切入点匹配器和切面类等信息一并封装到Advisor</li><li><strong>postProcessAfterInitialization</strong>：主要负责将Advisor注入到合适的位置，创建代理（cglib或jdk)，为后面给代理进行增强实现做准备。</li></ol><h2 id="Spring通知（Advice）有哪些类型？"><a href="#Spring通知（Advice）有哪些类型？" class="headerlink" title="Spring通知（Advice）有哪些类型？"></a>Spring通知（Advice）有哪些类型？</h2><h3 id="Advice的类型："><a href="#Advice的类型：" class="headerlink" title="Advice的类型："></a>Advice的类型：</h3><p>（1）前置通知（Before Advice）：在连接点（Join point）之前执行的通知。</p><p>（2）后置通知（After Advice）：当连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 </p><p>（3）环绕通知（Around Advice）：包围一个连接点的通知，这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</p><p>（4）返回后通知（AfterReturning Advice）：在连接点正常完成后执行的通知（如果连接点抛出异常，则不执行）</p><p>（5）抛出异常后通知（AfterThrowing advice）：在方法抛出异常退出时执行的通知</p><h3 id="Advice的执行顺序："><a href="#Advice的执行顺序：" class="headerlink" title="Advice的执行顺序："></a>Advice的执行顺序：</h3><p>（1）没有异常情况下的执行顺序：</p><ul><li>around before advice</li><li>before advice</li><li>target method 执行</li><li>after advice</li><li>around after advice</li><li>afterReturning advice</li></ul><p>（2）出现异常情况下的执行顺序：</p><ul><li>around before advice</li><li>before advice</li><li>target method 执行</li><li>after advice</li><li>around after advice</li><li>afterThrowing advice</li><li>java.lang.RuntimeException：异常发生</li></ul><h3 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h3><p>Spring默认在目标类实现接口时是通过JDK代理实现的，只有非接口的是通过Cglib代理实现的。当设置proxy-target-class为true时在目标类不是接口或者代理类时优先使用cglib代理实现。</p><h4 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h4><p>JDK提供的工具类Proxy</p><ul><li>只提供接口的代理，不支持类的代理，要求被代理类实现接口</li><li>核心是InvocationHandler接口和Proxy类，在获取代理对象时，使用Proxy类来动态创建目标类的代理类（即最终真正的代理类，这个类继承自Proxy类并实现了所定义的接口）</li><li>当代理对象调用真实对象的方法是，IncocationHandler通过invoke()方法来反射调用目标类中的代码，动态地将横切逻辑和业务编织在一起。</li></ul><h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><p>是一个代码生成的类库</p><ul><li>在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP</li><li>通过继承的方式做的动态代理，如果一个类被标记为<font color='red'>final</font>，那么就无法使用CGLIB做动态代理</li></ul><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><h3 id="为什么要有Spring-Boot"><a href="#为什么要有Spring-Boot" class="headerlink" title="为什么要有Spring Boot"></a>为什么要有Spring Boot</h3><p>Spring 的组件代码是轻量级的，<strong>但是配置却是重量级的（需要大量的xml文件）</strong></p><p>spring boot目的是简化spring的开发（减少配置文件，开箱即用）</p><h3 id="什么是Spring-Boot-Starters"><a href="#什么是Spring-Boot-Starters" class="headerlink" title="什么是Spring Boot Starters?"></a>什么是Spring Boot Starters?</h3><p>Spring Boot Starters 是一种用于简化 Spring Boot 应用程序依赖管理的方式。它们是预配置的一组依赖项，用于在特定的应用场景中快速启动 Spring Boot 项目。通过使用 Starters，你可以轻松地引入所需的依赖项，而不必手动配置和管理每个依赖项的版本。</p><p>Spring Boot Starters 的好处包括：</p><ol><li><strong>简化依赖管理：</strong> Starters 简化了依赖项的管理过程，减少了开发者手动管理依赖版本的工作。</li><li><strong>约定优于配置：</strong> Starters 遵循一些最佳实践和约定，提供了默认的配置，减少了手动配置的需要。</li><li><strong>快速入门：</strong> 通过引入适当的 Starter，你可以快速地启动项目，专注于业务逻辑的开发。</li><li><strong>可扩展性：</strong> 你可以根据需求组合不同的 Starters，以创建出满足项目需求的自定义应用。</li><li><strong>版本兼容性：</strong> Starters 已经经过测试和验证，确保不同依赖项版本之间的兼容性。</li></ol><h3 id="Spring-Boot的内嵌容器"><a href="#Spring-Boot的内嵌容器" class="headerlink" title="Spring Boot的内嵌容器"></a>Spring Boot的内嵌容器</h3><ul><li>tomcat 9.0</li><li>jetty 9.4</li><li>Undertow 2.0</li></ul><h3 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下@SpringBootApplication注解</h3><p>可以看出大概可以把<code>`@SpringBootApplication</code>看作是<code>@Configuration</code> 、<code>@EnableAutoConfiguration</code> 、<code>@ComponentScan</code>注解的集合。</p><p>根据SpringBoot官网，这三个注解的作用分别是:</p><ul><li><p><code>@EnableAutoConfiguration</code>：启用SpringBoot的自动配置机制</p><p>通过Spring 提供的<code>`@Import</code> 注解导入配置类或者Bean</p></li><li><p><code>@ComponentScan</code>：扫描被<code>`@Component</code> (<code>@Service</code> , <code>@Controller</code>)注解的bean，注解默认会扫描该类所在的包下所有的类。</p></li><li><p><code>@Configuration</code>：允许在上下文中注册额外的 bean或导入其他配置类</p></li></ul><h3 id="Spring-Boot读取配置文件"><a href="#Spring-Boot读取配置文件" class="headerlink" title="Spring Boot读取配置文件"></a>Spring Boot读取配置文件</h3><ul><li>通过<code>@Value</code>读取比较简单的信息（不推荐使用）</li><li><p>通过<code>@ConfigurationProperties</code>读取并且与Bean绑定，这时候Bean的值就是配置文件中的值，Bean需要加上<code>@Component</code></p></li><li><p>通过<code>@ConfigurationProperties</code><strong>读取并校验</strong></p><p>ProfileProperties类没有加<code>`@Component</code>注解。我们在我们要使用ProfileProperties的地方使用<code>@EnableConfigurationProperties</code>注册我们的配置bean。（<code>@EnableConfigurationProperties(ProfileProperties.class)</code> 指定Bean的类）</p></li><li><p><code>@PropertySource</code>读取指定的properties文件</p><p><code>@PropertySource( &quot;classpath:website.properties &quot;)</code> 指定配置文件，并且通过@Value来读取信息 <code>@Value(&quot;$&#123;url&#125;&quot;)</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/mingyry/27ace9d5.html"/>
      <url>/mingyry/27ace9d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h2 id="JSON-交互登录"><a href="#JSON-交互登录" class="headerlink" title="JSON 交互登录"></a>JSON 交互登录</h2><h3 id="1-有状态登录"><a href="#1-有状态登录" class="headerlink" title="1. 有状态登录"></a>1. 有状态登录</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-无状态登录"><a href="#1-2-无状态登录" class="headerlink" title="1.2 无状态登录"></a>1.2 无状态登录</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-各自优缺点"><a href="#1-4-各自优缺点" class="headerlink" title="1.4 各自优缺点"></a>1.4 各自优缺点</h3><p>使用 session 最大的优点在于方便。你不用做过多的处理，一切都是默认的即可。</p><p>但是使用 session 有另外一个致命的问题就是如果你的前端是 Android、iOS、小程序等，这些 App 天然的就没有 cookie，如果非要用 session，就需要这些工程师在各自的设备上做适配，一般是模拟 cookie，从这个角度来说，在移动 App 遍地开花的今天，我们单纯的依赖 session 来做安全管理，似乎也不是特别理想。</p><p>这个时候 JWT 这样的无状态登录就展示出自己的优势了，这些登录方式所依赖的 token 你可以通过普通参数传递，也可以通过请求头传递，怎么样都行，具有很强的灵活性。</p><p>不过话说回来，如果你的前后端分离只是网页+服务端，其实没必要上无状态登录，基于 session 来做就可以了，省事又方便。</p><blockquote><p>我们知道，当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即<strong>用户名或者密码输入错误，请重新输入</strong>，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。</p><p>但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。</p><p>在 Spring Security 中，用户名查找失败对应的异常是：</p><ul><li>UsernameNotFoundException</li></ul><p>密码匹配失败对应的异常是：</p><ul><li>BadCredentialsException</li></ul><p>但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。</p></blockquote><h3 id="3-未认证处理方案"><a href="#3-未认证处理方案" class="headerlink" title="3. 未认证处理方案"></a>3. 未认证处理方案</h3><p>但是在前后端分离中，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。</p><p>要解决这个问题，就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">AuthenticationException authException)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="keyword">if</span> (forceHttps &amp;&amp; <span class="string">&quot;http&quot;</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (redirectUrl == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">loginForm</span> <span class="operator">=</span> determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Server side forward to: &quot;</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.csrf().disable().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">            out.write(<span class="string">&quot;尚未登录，请先登录&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h3 id="4-注销登录"><a href="#4-注销登录" class="headerlink" title="4. 注销登录"></a>4. 注销登录</h3><p>最后我们再来看看注销登录的处理方案。</p><p>注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.logout()</span><br><span class="line">.logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">.logoutSuccessHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">    resp.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    out.write(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>这样，注销成功之后，前端收到的也是 JSON 了：</p><h2 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h2><p>我们最常用的就是 UsernamePasswordAuthenticationToken 了，而每一个 Authentication 都有适合它的 AuthenticationProvider 去处理校验。例如处理 UsernamePasswordAuthenticationToken 的 AuthenticationProvider 是 DaoAuthenticationProvider。</p><p>所以大家在 AuthenticationProvider 中看到一个 supports 方法，就是用来判断 AuthenticationProvider 是否支持当前 Authentication。</p><p>在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理</p><p>这里我们来重点看一下 DaoAuthenticationProvider，因为这是我们最常用的一个，当我们使用用户名/密码登录的时候，用的就是它，DaoAuthenticationProvider 的父类是 AbstractUserDetailsAuthenticationProvider，我们就先从它的父类看起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span>, InitializingBean, MessageSourceAware &#123;</span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (authentication.getPrincipal() == <span class="literal">null</span>) ? <span class="string">&quot;NONE_PROVIDED&quot;</span> : authentication.getName();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line"><span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line"><span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="built_in">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (UsernamePasswordAuthenticationToken.class</span><br><span class="line">.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractUserDetailsAuthenticationProvider 的代码还是挺长的，这里我们重点关注两个方法：authenticate 和 supports</p><p>authenticate 方法就是用来做认证的方法，我们来简单看下方法流程：</p><ol><li>首先从 Authentication 提取出登录用户名。</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li>additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。但是注意，additionalAuthenticationChecks 方法是一个抽象方法，具体的实现是在 AbstractUserDetailsAuthenticationProvider 的子类中实现的，也就是 DaoAuthenticationProvider。这个其实很好理解，因为 AbstractUserDetailsAuthenticationProvider 作为一个较通用的父类，处理一些通用的行为，我们在登录的时候，有的登录方式并不需要密码，所以 additionalAuthenticationChecks 方法一般交给它的子类去实现，在 DaoAuthenticationProvider 类中，additionalAuthenticationChecks 方法就是做密码比对的，在其他的 AuthenticationProvider 中，additionalAuthenticationChecks 方法的作用就不一定了。</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期。</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的UsernamePasswordAuthenticationToken。</li></ol><p>supports 方法就比较简单了，主要用来判断当前的 Authentication 是否是 UsernamePasswordAuthenticationToken。</p><p>由于 AbstractUserDetailsAuthenticationProvider 已经把 authenticate 和 supports 方法实现了，所以在 DaoAuthenticationProvider 中，我们主要关注 additionalAuthenticationChecks 方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails,</span></span><br><span class="line"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line"><span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line"><span class="keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(messages.getMessage(</span><br><span class="line"><span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line"><span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，additionalAuthenticationChecks 方法主要用来做密码比对的，逻辑也比较简单，就是调用 PasswordEncoder 的 matches 方法做比对，如果密码不对则直接抛出异常即可。</p><p><strong>正常情况下，我们使用用户名/密码登录，最终都会走到这一步。</strong></p><p>而 AuthenticationProvider 都是通过 ProviderManager#authenticate 方法来调用的。由于我们的一次认证可能会存在多个 AuthenticationProvider，所以，在 ProviderManager#authenticate 方法中会逐个遍历 AuthenticationProvider，并调用他们的 authenticate 方法做认证，我们来稍微瞅一眼 ProviderManager#authenticate 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个方法中，会遍历所有的 AuthenticationProvider，并调用它的 authenticate 方法进行认证。</p><h3 id="2-自定义认证思路"><a href="#2-自定义认证思路" class="headerlink" title="2. 自定义认证思路"></a>2. 自定义认证思路</h3><p>之前我们通过自定义过滤器，将自定义的过滤器加入到 Spring Security 过滤器链中，进而实现了添加登录验证码功能，但是我们也说这种方式是有弊端的，就是破坏了原有的过滤器链，请求每次都要走一遍验证码过滤器，这样不合理。</p><p>我们改进的思路也很简单。</p><p>登录请求是调用 AbstractUserDetailsAuthenticationProvider#authenticate 方法进行认证的，在该方法中，又会调用到 DaoAuthenticationProvider#additionalAuthenticationChecks 方法做进一步的校验，去校验用户登录密码。我们可以自定义一个 AuthenticationProvider 代替 DaoAuthenticationProvider，并重写它里边的 additionalAuthenticationChecks 方法，在重写的过程中，加入验证码的校验逻辑即可。</p><p>这样既不破坏原有的过滤器链，又实现了自定义认证功能。<strong>常见的手机号码动态登录，也可以使用这种方式来认证。</strong></p><h3 id="用户登录的session问题的管理"><a href="#用户登录的session问题的管理" class="headerlink" title="用户登录的session问题的管理"></a>用户登录的session问题的管理</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230424104259556.png" alt="image-20230424104259556"></p><p>sessionStrategy.onAuthentication(authResult, request, response); 这个方法就是用来处理 session 的并发问题的。 </p><h2 id="Http-Session"><a href="#Http-Session" class="headerlink" title="Http Session"></a>Http Session</h2><p>HttpSession 是一个服务端的概念，服务端生成的 HttpSession 都会有一个对应的 sessionid，这个 sessionid 会通过 cookie 传递给前端，前端以后发送请求的时候，就带上这个 sessionid 参数，服务端看到这个 sessionid 就会把这个前端请求和服务端的某一个 HttpSession 对应起来，形成“会话”的感觉。</p><p>浏览器关闭并不会导致服务端的 HttpSession 失效，想让服务端的 HttpSession 失效，要么手动调用 HttpSession#invalidate 方法；要么等到 session 自动过期；要么重启服务端。</p><p>但是为什么有的人会感觉浏览器关闭之后 session 就失效了呢？这是因为浏览器关闭之后，保存在浏览器里边的 sessionid 就丢了（默认情况下），所以当浏览器再次访问服务端的时候，服务端会给浏览器重新分配一个 sessionid ，这个 sessionid 和之前的 HttpSession 对应不上，所以用户就会感觉 session 失效。</p><p>注意前面我用了一个<strong>默认情况下</strong>，也就是说，我们可以通过手动配置，让浏览器重启之后 sessionid 不丢失，但是这样会带来安全隐患，所以一般不建议。</p><p>以 Spring Boot 为例，服务端生成 sessionid 之后，返回给前端的响应头是这样的：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20200513110652.png" alt="img"></p><p>在服务端的响应头中有一个 Set-Cookie 字段，该字段指示浏览器更新 sessionid，同时大家注意还有一个 HttpOnly 属性，这个表示通过 JS 脚本无法读取到 Cookie 信息，这样能有效的防止 XSS 攻击。</p><p>下一次浏览器再去发送请求的时候，就会自觉的携带上这个 jsessionid 了：</p><h3 id="防御会话固定攻击"><a href="#防御会话固定攻击" class="headerlink" title="防御会话固定攻击"></a>防御会话固定攻击</h3><h4 id="2-会话固定攻击"><a href="#2-会话固定攻击" class="headerlink" title="2.会话固定攻击"></a>2.会话固定攻击</h4><p>什么是会话固定攻击？英文叫做 session fixation attack。</p><p>正常来说，只要你不关闭浏览器，并且服务端的 HttpSession 也没有过期，那么维系服务端和浏览器的 sessionid 是不会发生变化的，而会话固定攻击，则是利用这一机制，借助受害者用相同的会话 ID 获取认证和授权，然后利用该会话 ID 劫持受害者的会话以成功冒充受害者，造成会话固定攻击。</p><p>一般来说，会话固定攻击的流程是这样，以淘宝为例：</p><ol><li>攻击者自己可以正常访问淘宝网站，在访问的过程中，淘宝网站给攻击者分配了一个 sessionid。</li><li>攻击者利用自己拿到的 sessionid 构造一个淘宝网站的链接，并把该链接发送给受害者。</li><li>受害者使用该链接登录淘宝网站（该链接中含有 sessionid），登录成功后，一个合法的会话就成功建立。</li><li>攻击者利用手里的 sessionid 冒充受害者。</li></ol><p>在这个过程中，如果淘宝网站支持 URL 重写，那么攻击还会变得更加容易。</p><p>什么是 URL 重写？就是用户如果在浏览器中禁用了 cookie，那么 sessionid 自然也用不了了，所以有的服务端就支持把 sessionid 放在请求地址中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.taobao.com;jsessionid=xxxxxx</span><br></pre></td></tr></table></figure><p>如果服务端支持这种 URL 重写，那么对于攻击者来说，按照上面的攻击流程，构造一个这种地址简直太简单不过了。</p><p>不过这种请求地址大家在 Spring Security 中应该很少见到（原因请见下文），但是在 Shiro 中可能多多少少有见过。</p><h4 id="3-如何防御"><a href="#3-如何防御" class="headerlink" title="3.如何防御"></a>3.如何防御</h4><p>这个问题的根源在 sessionid 不变，如果用户在未登录时拿到的是一个 sessionid，登录之后服务端给用户重新换一个 sessionid，就可以防止会话固定攻击了。</p><p>如果你使用了 Spring Security ，其实是不用担心这个问题的，因为 Spring Security 中默认已经做了防御工作了。</p><p>Spring Security 中的防御主要体现在三个方面：</p><p><strong>首先</strong>就是HttpFirewall请求地址中有 <code>;</code> 请求会被直接拒绝。</p><p><strong>另一方面</strong>就是响应的 Set-Cookie 字段中有 HttpOnly 属性，这种方式避免了通过 XSS 攻击来获取 Cookie 中的会话信息进而达成会话固定攻击。</p><p><strong>第三点</strong>则是让 sessionid 变一下。既然问题是由于 sessionid 不变导致的，那我就让 sessionid 变一下。</p><p>具体配置如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20200513120930.png" alt="img"></p><p>可以看到，在这里，我们有四个选项：</p><ol><li>migrateSession 表示在登录成功之后，创建一个新的会话，然后将旧的 session 中的信息复制到新的 session 中，<strong>默认即此</strong>。</li><li>none 表示不做任何事情，继续使用旧的 session。</li><li>changeSessionId 表示 session 不变，但是会修改 sessionid，这实际上用到了 Servlet 容器提供的防御会话固定攻击。</li><li>newSession 表示登录后创建一个新的 session。</li></ol><p>默认的 migrateSession ，在用户匿名访问的时候是一个 sessionid，当用户成功登录之后，又是另外一个 sessionid，这样就可以有效避免会话固定攻击。</p><p>这三种方案，可以让我们有效避免会话固定攻击！</p><h2 id="session-共享"><a href="#session-共享" class="headerlink" title="session 共享"></a>session 共享</h2><p>对于这一类问题的解决，目前比较主流的方案就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/14-2.png" alt="img"></p><p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。</p><p>这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。</p><p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。</p><p>对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p><h3 id="2-session-拷贝"><a href="#2-session-拷贝" class="headerlink" title="2 session 拷贝"></a>2 session 拷贝</h3><p>session 拷贝就是不利用 redis，直接在各个 Tomcat 之间进行 session 数据拷贝，但是这种方式效率有点低，Tomcat A、B、C 中任意一个的 session 发生了变化，都需要拷贝到其他 Tomcat 上，如果集群中的服务器数量特别多的话，这种方式不仅效率低，还会有很严重的延迟。</p><p>所以这种方案一般作为了解即可。</p><h3 id="3-粘滞会话"><a href="#3-粘滞会话" class="headerlink" title="3 粘滞会话"></a>3 粘滞会话</h3><p>所谓的粘滞会话就是将相同 IP 发送来的请求，通过 Nginx 路由到同一个 Tomcat 上去，这样就不用进行 session 共享与同步了。这是一个办法，但是在一些极端情况下，可能会导致负载失衡（因为大部分情况下，都是很多人用同一个公网 IP）。</p><p><strong>所以，Session 共享就成为了这个问题目前主流的解决方案了</strong></p><p>然后先访问 <code>localhost:8080/set</code> 向 <code>8080</code> 这个服务的 <code>Session</code> 中保存一个变量，第一次访问时会自动跳转到登录页面，输入用户名密码进行登录即可。访问成功后，数据就已经自动同步到 <code>Redis</code>  中 了 ：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20200514104238.png" alt="img"></p><p>然后，再调用 <code>localhost:8081/get</code> 接口，就可以获取到 <code>8080</code> 服务的 <code>session</code> 中的数据：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/14-6.png" alt="img"></p><p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了</p><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><p>想要防御 CSRF 攻击，那我们得先搞清楚什么是 CSRF 攻击，松哥通过下面一张图，来和大家梳理 CSRF 攻击流程：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/csrf-1.png" alt="img"></p><p>其实这个流程很简单：</p><ol><li>假设用户打开了招商银行网上银行网站，并且登录。</li><li>登录成功后，网上银行会返回 Cookie 给前端，浏览器将 Cookie 保存下来。</li><li>用户在没有登出网上银行的情况下，在浏览器里边打开了一个新的选项卡，然后又去访问了一个危险网站。</li><li>这个危险网站上有一个超链接，超链接的地址指向了招商银行网上银行。</li><li>用户点击了这个超链接，由于这个超链接会自动携带上浏览器中保存的 Cookie，所以用户不知不觉中就访问了网上银行，进而可能给自己造成了损失。</li></ol><h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><h3 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h3><p>如果使用了 Spring Security，当我们登录成功后，可以通过如下方式获取到当前登录用户信息：</p><ol><li><code>SecurityContextHolder.getContext().getAuthentication()</code></li><li>在 Controller 的方法中，加入 Authentication 参数</li></ol><p>正常情况下，我们通过如上两种方式的任意一种就可以获取到已经登录的用户信息。</p><p>异常情况，就是这两种方式中的任意一种，都返回 null。</p><p>都返回 null，意味着系统收到当前请求时并不知道你已经登录了（因为你没有在系统中留下任何有效信息），这会带来两个问题：</p><ol><li>无法获取到当前登录用户信息。</li><li>当你发送任何请求，系统都会给你返回 401。</li></ol><h3 id="2-顺藤摸瓜"><a href="#2-顺藤摸瓜" class="headerlink" title="2.顺藤摸瓜"></a>2.顺藤摸瓜</h3><p>要弄明白这个问题，我们就得明白 Spring Security 中的用户信息到底是在哪里存的？</p><p>前面说了两种数据获取方式，但是这两种数据获取方式，获取到的数据又是从哪里来的？</p><p>首先松哥之前和大家聊过，SecurityContextHolder 中的数据，本质上是保存在 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。</p><p>ThreadLocalSecurityContextHolderStrategy.java（全部源码）</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/1313132-20180804103942608-416432377.png" alt="img"></p><p>基于ThreadLocal的存储策略实现，看上去，这个类好像跟上面那个全局的没什么差别。但是要注意了，它是用ThreadLocal来存储的。新手可能会疑惑，就一个变量，我怎么存储多个上下文，这个变量又不是集合。这里就不分析源码了，实际上ThreadLocal内部会用数组来存储多个对象的。原理是，ThreadLocal会为每个线程开辟一个存储区域，来存储相应的对象。</p><p>这样就带来一个问题，当不同的请求进入到服务端之后，由不同的 thread 去处理，按理说后面的请求就可能无法获取到登录请求的线程存入的数据，例如登录请求在线程 A 中将登录用户信息存入 <code>ThreadLocal</code>，后面的请求来了，在线程 B 中处理，那此时就无法获取到用户的登录信息。</p><p>但实际上，正常情况下，我们每次都能够获取到登录用户信息，这又是怎么回事呢？</p><p>这我们就要引入 Spring Security 中的 <code>SecurityContextPersistenceFilter</code> 了。</p><p>小伙伴们都知道，无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，松哥前面跟大家聊了 <code>UsernamePasswordAuthenticationFilter</code> 过滤器，在这个过滤器之前，还有一个过滤器就是 <code>SecurityContextPersistenceFilter</code>，请求在到达 <code>UsernamePasswordAuthenticationFilter</code> 之前都会先经过 <code>SecurityContextPersistenceFilter</code>。</p><p>我们来看下它的源码(部分)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"><span class="type">HttpRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestResponseHolder</span>(request,</span><br><span class="line">response);</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的方法很长，我这里列出来了比较关键的几个部分：</p><ol><li>SecurityContextPersistenceFilter 继承自 GenericFilterBean，而 GenericFilterBean 则是 Filter 的实现，所以 SecurityContextPersistenceFilter 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li><li>在 doFilter 方法中，它首先会从 repo 中读取一个 SecurityContext 出来，这里的 repo 实际上就是 HttpSessionSecurityContextRepository，读取 SecurityContext 的操作会进入到 readSecurityContextFromSession 方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 springSecurityContextKey 对象的值就是 SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个 SecurityContext 对象。</li><li>SecurityContext 是一个接口，它有一个唯一的实现类 SecurityContextImpl，这个实现类其实就是用户信息在 session 中保存的 value。</li><li>在拿到 SecurityContext 之后，通过 SecurityContextHolder.setContext 方法将这个 SecurityContext 设置到 ThreadLocal 中去，这样，在当前请求中，Spring Security 的后续操作，我们都可以直接从 SecurityContextHolder 中获取到用户信息了。</li><li>接下来，通过 chain.doFilter 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li><li>在过滤器链走完之后，数据响应给前端之后，finally 中还有一步收尾操作，这一步很关键。这里从 SecurityContextHolder 中获取到 SecurityContext，获取到之后，会把 SecurityContextHolder 清空，然后调用 repo.saveContext 方法将获取到的 SecurityContext 存入 session 中。</li></ol><p>至此，整个流程就很明了了。</p><p>每一个请求到达服务端的时候，首先从 session 中找出来 SecurityContext ，然后设置到 SecurityContextHolder 中去，方便后续使用，当这个请求离开的时候，SecurityContextHolder 会被清空，SecurityContext 会被放回 session 中，方便下一个请求来的时候获取。</p><p>搞明白这一点之后，再去解决 Spring Security 登录后无法获取到当前登录用户这个问题，就非常 easy 了。</p><h3 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3.问题解决"></a>3.问题解决</h3><p>经过上面的分析之后，我们再来回顾一下为什么会发生登录之后无法获取到当前用户信息这样的事情？</p><p>最简单情况的就是你在一个新的线程中去执行 <code>SecurityContextHolder.getContext().getAuthentication()</code>，这肯定获取不到用户信息，无需多说。例如下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/menu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Menu&gt; <span class="title function_">getMenusByHrId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">            System.out.println(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">return</span> menuService.getMenusByHrId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种简单的问题相信大家都能够很容易排查到。</p><p>还有一种隐藏比较深的就是在 SecurityContextPersistenceFilter 的 doFilter 方法中没能从 session 中加载到用户信息，进而导致 SecurityContextHolder 里边空空如也。</p><p>在 SecurityContextPersistenceFilter 中没能加载到用户信息，原因可能就比较多了，例如：</p><ul><li><strong>上一个请求临走的时候，没有将数据存储到 session 中去。</strong></li><li><strong>当前请求自己没走过滤器链。</strong></li></ul><p>什么时候会发生这个问题呢？有的小伙伴可能在配置 SecurityConfig#configure(WebSecurity) 方法时，会忽略掉一个重要的点。</p><p>当我们想让 Spring Security 中的资源可以匿名访问时，我们有两种办法：</p><ol><li>不走 Spring Security 过滤器链。</li><li>继续走 Spring Security 过滤器链，但是可以匿名访问。</li></ol><p>这两种办法对应了两种不同的配置方式。其中第一种配置可能会影响到我们获取登录用户信息，第二种则不影响，所以这里我们来重点看看第一种。</p><p>不想走 Spring Security 过滤器链，我们一般可以通过如下方式配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;/index.html&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/favicon.ico&quot;</span>,<span class="string">&quot;/verifyCode&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常这样配置是没有问题的。</p><p>如果你很不巧，把登录请求地址放进来了，那就 gg 了。虽然登录请求可以被所有人访问，但是不能放在这里（而应该通过允许匿名访问的方式来给请求放行）。<strong>如果放在这里，登录请求将不走 <code>SecurityContextPersistenceFilter</code> 过滤器，也就意味着不会将登录用户信息存入 session，进而导致后续请求无法获取到登录用户信息。</strong></p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域这个问题松哥之前写过文章，但是最近收到小伙伴们的一些问题，让我发现之前的总结不够全面，因此打算再写一篇文章，来和大家分享一下 Spring Boot 中的跨域问题。</p><p>这次我把 Spring Boot 中的跨域问题分为了三个场景：</p><ul><li>普通跨域</li><li>Spring Security 跨域</li><li>OAuth2 跨域</li></ul><p>分为三种并非多此一举，主要是因为这三种场景的配置都不太一样，而这三种场景又都是非常常见的场景，所以这里和大家再来专门分享下。</p><h3 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h3><p>谁出现的跨域？ ==》 <strong>浏览器！</strong></p><p>为何出现？ ==》 同源策略</p><ul><li>同源策略？<ul><li>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。</li><li>所谓同源 ==》指的是 “协议+域名+端口” 三者的相同 只要有一个不同就会导致跨域问题</li></ul></li><li>目的：简单来说就是禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</li></ul><p>解决方案？</p><ul><li><p>前端做代理服务器</p></li><li><p>跨域技术-<code>CORS</code> （<code>CrossOrigin Resources Sharing</code>，跨源资源共享） <strong>（推荐）</strong></p><ul><li><code>CORS</code>，是 <code>HTML5</code> 的一项特性，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。</li><li>使用原理：浏览器一旦发现 axios 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。 服务器根据这些附加的值，决定是否同意此次请求。</li></ul></li><li><p><code>JSONP</code></p><ul><li><p>改变请求方式 <code>dataType: &#39;jsonp&#39;, // 请求方式为jsonp</code></p></li><li><p>原理： JSONP 是通过动态添加</p></li><li><p>```scala<br>// 前端实现<br>$.ajax({<br>url: ‘<a href="http://www.domain2.com:8080/login">http://www.domain2.com:8080/login</a>‘,<br>type: ‘get’,<br>dataType: ‘jsonp’, // 请求方式为jsonp<br>jsonpCallback: “onBack”, // 自定义回调函数名<br>data: {}<br>});</p><p>// 后台实现<br>@ControllerAdvice(basePackages = “com.zkn.learnspringboot.web.controller”)<br>public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice{</p><p>public JsonpAdvice() {</p><p>super(“callback”,”jsonp”);<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解决最优解 ==》 `CORS`</span><br><span class="line"></span><br><span class="line">- 相比于 `jsonp` 只能用于get 请求来说 `cors`对于所有的请求都通用</span><br><span class="line">- `jsonp` 的优势在于可以在于支持老式浏览器，以及可以向不支持 `cors` 的网站请求数据。</span><br><span class="line"></span><br><span class="line">作者：白小剑</span><br><span class="line">链接：https://juejin.cn/post/7006320955316240415</span><br><span class="line"></span><br><span class="line">在 Spring 框架中，对于 CORS 也提供了相应的解决方案，在 Spring Boot 中，这一方案得倒了简化，无论是单纯的跨域，还是结合 Spring Security 之后的跨域，都变得非常容易了。</span><br><span class="line"></span><br><span class="line">### 2.解决方案</span><br><span class="line"></span><br><span class="line">首先创建两个普通的 Spring Boot 项目，这个就不用我多说，第一个命名为 provider 提供服务，第二个命名为 consumer 消费服务，第一个配置端口为 8080，第二个配置配置为 8081，然后在 provider 上提供两个 hello 接口，一个 get，一个 post，如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @PostMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello2() &#123;</span><br><span class="line">        return &quot;post hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>在 consumer 的 resources/static 目录下创建一个 html 文件，发送一个简单的 ajax 请求，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;get_button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;btnClick2()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;post_button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">btnClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">html</span>(msg);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">btnClick2</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/hello&#x27;</span>, <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#app&quot;</span>).<span class="title function_">html</span>(msg);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://localhost:8080/hello&#x27; from origin &#x27;http://localhost:8081&#x27; has been blocked by CORS policy: No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>可以看到，由于同源策略的限制，请求无法发送成功。</p><p>使用 CORS 可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在 provider 中如何配置。首先可以通过 <code>@CrossOrigin</code> 注解配置某一个方法接受某一个域的请求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(value = &quot;http://localhost:8081&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;post hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解表示这两个接口接受来自 <code>http://localhost:8081</code> 地址的请求，配置完成后，重启 provider ，再次发送请求，浏览器控制台就不会报错了，consumer 也能拿到数据了。</p><p>此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20200602175129.png" alt="img"></p><p>这个表示服务端愿意接收来自 <code>http://localhost:8081</code> 的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。</p><p>provider 上，每一个方法上都去加注解未免太麻烦了，有的小伙伴想到可以讲注解直接加在 Controller 上，不过每个 Controller 都要加还是麻烦，在 Spring Boot 中，还可以通过全局配置一次性解决这个问题，全局配置只需要在 SpringMVC 的配置类中重写 addCorsMappings 方法即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">        .allowedOrigins(<span class="string">&quot;http://localhost:8081&quot;</span>)</span><br><span class="line">        .allowedMethods(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">        .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/**</code> 表示本应用的所有方法都会去处理跨域请求，allowedMethods 表示允许通过的请求数，allowedHeaders 则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。</p><h4 id="2-1-存在的问题"><a href="#2-1-存在的问题" class="headerlink" title="2.1 存在的问题"></a>2.1 存在的问题</h4><p>了解了整个 CORS 的工作过程之后，我们通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><h3 id="3-SpringSecurity"><a href="#3-SpringSecurity" class="headerlink" title="3. SpringSecurity"></a>3. SpringSecurity</h3><p>如果使用了 Spring Security，上面的跨域配置会失效，因为请求被 Spring Security 拦截了。</p><p>当引入了 Spring Security 的时候，我们有两种办法开启 Spring Security 对跨域的支持。</p><h3 id="3-1-方式一"><a href="#3-1-方式一" class="headerlink" title="3.1 方式一"></a>3.1 方式一</h3><p>方式一就是在上一小节的基础上，添加 Spring Security 对于 CORS 的支持，只需要添加如下配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>.cors</code> 就开启了 Spring Security 对 CORS 的支持。</p><h3 id="3-2-方式二"><a href="#3-2-方式二" class="headerlink" title="3.2 方式二"></a>3.2 方式二</h3><p>方式二则是去除第二小节的跨域配置，直接在 Spring Security 中做全局配置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        configuration.setAllowedOrigins(Arrays.asList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setMaxAge(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 CorsConfigurationSource 实例对跨域信息作出详细配置，例如允许的请求来源、允许的请求方法、允许通过的请求头、探测请求的有效期、需要处理的路径等等。</p><p><strong>使用这种方式就可以去掉第二小节的跨域配置了。</strong></p><h2 id="4-OAuth2"><a href="#4-OAuth2" class="headerlink" title="4.OAuth2"></a>4.OAuth2</h2><p>还有一种情况就是 OAuth2 允许跨域，如果用户要访问 OAuth2 端点，例如 <code>/oauth/token</code> ，出现了跨域该怎么配置呢？</p><p>这个解决方案松哥在之前的 【<a href="">用 Swagger 测试接口，怎么在请求头中携带 Token？</a>】 一文中已经有过介绍，主要是配置一个 CorsFilter，大家可以参考该篇文章，我这里就把核心配置类列出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SecurityConfig 中开启跨域支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .requestMatchers().antMatchers(HttpMethod.OPTIONS, <span class="string">&quot;/oauth/**&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable().formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JWT，全称是 Json Web Token ， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/640" alt="图片"></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<a href="https://github.com/jwtk/jjwt">https://github.com/jwtk/jjwt</a></p><h4 id="JWT-数据格式"><a href="#JWT-数据格式" class="headerlink" title="JWT 数据格式"></a>JWT 数据格式</h4><p>JWT 包含三部分数据：</p><p>1.Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><p>2.Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了 7 个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><p>3.Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥 secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</p><p>生成的数据格式如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230519120431924.png" alt=""></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分。另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="JWT-交互流程"><a href="#JWT-交互流程" class="headerlink" title="JWT 交互流程"></a>JWT 交互流程</h4><p>流程图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/640" alt="图片"></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就符合了 RESTful 的无状态规范。</p><h2 id="JWT-身份认证常见问题及解决办法"><a href="#JWT-身份认证常见问题及解决办法" class="headerlink" title="JWT 身份认证常见问题及解决办法"></a>JWT 身份认证常见问题及解决办法</h2><h3 id="注销登录等场景下-JWT-还有效"><a href="#注销登录等场景下-JWT-还有效" class="headerlink" title="注销登录等场景下 JWT 还有效"></a>注销登录等场景下 JWT 还有效</h3><p>与之类似的具体相关场景有：</p><ul><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被封禁/删除；</li><li>用户被服务端强制注销；</li><li>用户被踢下线；</li><li>……</li></ul><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。但是，使用 JWT 认证的方式就不好解决了。我们也说过了，JWT 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p><p>那我们如何解决这个问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p><p><strong>1、将 JWT 存入内存数据库</strong></p><p>将 JWT 存入 DB 中，Redis 内存数据库在这里是不错的选择。如果需要让某个 JWT 失效就直接从 Redis 中删除这个 JWT 即可。但是，这样会导致每次使用 JWT 发送请求都要先从 DB 中查询 JWT 是否存在的步骤，而且违背了 JWT 的无状态原则。</p><p><strong>2、黑名单机制</strong></p><p>和上面的方式类似，使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p><p>前两种方案的核心在于将有效的 JWT 存储起来或者将指定的 JWT 拉入黑名单。</p><p>虽然这两种方案都违背了 JWT 的无状态原则，但是一般实际项目中我们通常还是会使用这两种方案。</p><p><strong>3、修改密钥 (Secret)</strong> :</p><p>我们为每个用户都创建一个专属密钥，如果我们想让某个 JWT 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大：</p><ul><li>如果服务是分布式的，则每次发出新的 JWT 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</li><li>如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的。</li></ul><p><strong>4、保持令牌的有效期限短并经常轮换</strong></p><p>很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p><p>另外，对于修改密码后 JWT 还有效问题的解决还是比较容易的。说一种我觉得比较好的方式：<strong>使用用户的密码的哈希值对 JWT 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</strong></p><h3 id="JWT-的续签问题"><a href="#JWT-的续签问题" class="headerlink" title="JWT 的续签问题"></a>JWT 的续签问题</h3><p>JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？</p><p>我们先来看看在 Session 认证中一般的做法：<strong>假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。</strong></p><p>JWT 认证的话，我们应该如何解决续签问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p><p><strong>1、类似于 Session 认证中的做法</strong></p><p>这种方案满足于大部分场景。假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ,对客户端不是很友好。</p><p><strong>2、每次请求都返回新 JWT</strong></p><p>这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</p><p><strong>3、JWT 有效期设置到半夜</strong></p><p>这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p><p><strong>4、用户登录返回两个 JWT</strong></p><p>第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p><p>这种方案的不足是：</p><ul><li>需要客户端来配合；</li><li>用户注销的时候需要同时保证两个 JWT 都无效；</li><li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li><li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。</li></ul><h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><ol><li><p>登录过后给前端进行返回token并设置了过期时间30分钟，每次请求的时候前端把token存在请求头里面进行发请求，后端接收请求的时候获取请求头出来进行jwt解析判断过期时间是否小于10分钟，如果小于10分钟就生成新的token在responseHearde进行返回即可</p><p>问题：性能比较低，</p></li><li><p>利用两个token来实现无感刷新</p><ul><li><p>登录得到两个token</p></li><li><p>当access_token过期时，自动发送refresh_token到刷新token的请求路径请求token刷新</p></li><li><p>得到新的token后，将请求重新发送</p></li><li><p>响应拦截，进行token的无感刷新<br>这是最难的一步，我们需要考虑到几个问题，第一：要实现无感，那么用户的请求就不能被舍弃，而是需要在得到新的token后帮他再执行一次；第二，当同时出现多个请求时，可能会导致多次刷新token的情况，所以需要用一个标志量来标志是否正在刷新token，并使用一个数据对请求进行存储。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标志当前是否正在刷洗token</span></span><br><span class="line"><span class="keyword">let</span> isNotRefreshing = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//请求队列</span></span><br><span class="line"><span class="keyword">let</span> requests = [];</span><br><span class="line">my_axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="comment">//我们可以定义一个标准响应体，比如：&#123;code=10415,msg=&#x27;token已过期&#x27;,data:null&#125;，当收到token过期的响应就要进行token刷新了</span></span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">10415</span>) &#123;</span><br><span class="line">        <span class="comment">//首先拿到响应的配置参数，这和请求的配置参数是一样的，包括了url、data等信息，待会需要使用这个config来进行重发</span></span><br><span class="line">            <span class="keyword">const</span> config = res.<span class="property">config</span>;</span><br><span class="line">            <span class="comment">//如果当前不处于刷新阶段就进行刷新操作</span></span><br><span class="line">            <span class="keyword">if</span> (isNotRefreshing) &#123;</span><br><span class="line">                isNotRefreshing = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//返回刷新token的回调的返回值，本来考虑到由于请求是异步的，所以return会先执行，导致返回一个undefined，那么就需要使用async+await，但实际上没有加也成功了</span></span><br><span class="line">                <span class="keyword">return</span> my_axios.<span class="title function_">get</span>(<span class="string">&quot;/admin/refreshToken&quot;</span>)</span><br><span class="line">                    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//如果token无效或token仍然过期，就只能重新登录了</span></span><br><span class="line">                        <span class="keyword">if</span> (res.<span class="property">code</span> == <span class="number">10422</span> || res.<span class="property">code</span> == <span class="number">10415</span>) &#123;</span><br><span class="line">                            sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;tokenBo&quot;</span>);</span><br><span class="line">                            sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;currentAdmin&quot;</span>);</span><br><span class="line">                            location.<span class="property">href</span> = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">code</span> == <span class="number">10200</span>) &#123;</span><br><span class="line">                        <span class="comment">//刷新成功之后，将新的token存起来</span></span><br><span class="line">                            sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;tokenBo&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">data</span>))</span><br><span class="line">                            <span class="comment">//执行requests队列中的请求，（requests中存的不是请求参数，而是请求的Promise函数，这里直接拿来执行就好）</span></span><br><span class="line">                            requests.<span class="title function_">forEach</span>(<span class="function"><span class="params">run</span> =&gt;</span> <span class="title function_">run</span>())</span><br><span class="line">                            <span class="comment">//将请求队列置空</span></span><br><span class="line">                            requests = []</span><br><span class="line">                            <span class="comment">//重新执行当前未执行成功的请求并返回</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="title function_">my_axios</span>(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;tokenBo&quot;</span>);</span><br><span class="line">                        sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;currentAdmin&quot;</span>);</span><br><span class="line">                        location.<span class="property">href</span> = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        isNotRefreshing = <span class="literal">true</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前已经是处于刷新token的状态，就将请求置于请求队列中，这个队列会在刷新token的回调中执行，由于new关键子存在声明提升，所以不用顾虑会有请求没有处理完的情况，这段添加请求的程序一定会在刷新token的回调执行之前执行的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//这里加入的是一个promise的解析函数，将响应的config配置对应解析的请求函数存到requests中，等到刷新token回调后再执行</span></span><br><span class="line">                    requests.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(<span class="title function_">my_axios</span>(config));</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">10200</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">10409</span>) &#123;</span><br><span class="line">                    sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;tokenBo&quot;</span>);</span><br><span class="line">                    sessionStorage.<span class="title function_">removeItem</span>(<span class="string">&quot;currentAdmin&quot;</span>);</span><br><span class="line">                    location.<span class="property">href</span> = <span class="string">&quot;/#/login&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title class_">Message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">message</span>);</span><br><span class="line">                <span class="keyword">return</span> res.<span class="property">data</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//  还可以实现免密登录的作用，利用新的refresh_token，直接免密登录</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在redis中单独为每个JWT设置过期时间，每次访问时刷新JWT的过期时间</p><p>实现参考文章：<a href="https://juejin.cn/post/6932702419344162823">https://juejin.cn/post/6932702419344162823</a></p></li></ol><h3 id="记住我功能的实现"><a href="#记住我功能的实现" class="headerlink" title="记住我功能的实现"></a>记住我功能的实现</h3><p>准确的讲，答案是肯定的，任何基于Cookie的认证方案在前后端分离环境下都会失效（原因在于这些客户端默认没有实现Cookie功能），不过好在，这些客户端一般都提供了替代方案， 唯一遗憾的是，此场景中token的生命周期需要我们在前端手动控制：</p><p>还是根据设置刷新token的时长来进行记住我功能的实现</p><p>以经典跨端框架 <a href="https://uniapp.dcloud.io/">uni-app</a> 为例，我们可以使用如下方式达到同样的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用本地存储保存refreshToken，达到 [持久Cookie] 的效果</span></span><br><span class="line">uni.<span class="title function_">setStorageSync</span>(<span class="string">&quot;refreshToken&quot;</span>, <span class="string">&quot;xxxx-xxxx-xxxx-xxxx-xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用globalData保存refreshToken，达到 [临时Cookie] 的效果</span></span><br><span class="line"><span class="title function_">getApp</span>().<span class="property">globalData</span>.<span class="property">refreshToken</span> = <span class="string">&quot;xxxx-xxxx-xxxx-xxxx-xxx&quot;</span>;复制到剪贴板错误复制成功<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>如果你决定在PC浏览器环境下进行前后端分离模式开发，那么更加简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 localStorage 保存refreshToken，达到 [持久Cookie] 的效果</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;refreshToken&quot;</span>, <span class="string">&quot;xxxx-xxxx-xxxx-xxxx-xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sessionStorage 保存refreshToken，达到 [临时Cookie] 的效果</span></span><br><span class="line">sessionStorage.<span class="title function_">setItem</span>(<span class="string">&quot;refreshToken&quot;</span>, <span class="string">&quot;xxxx-xxxx-xxxx-xxxx-xxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>Remember me, it’s too easy!</p><ol><li>sessionStorage（临时存储） ：为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载</li><li>localStorage（长期存储） ：与 sessionStorage 一样，但是浏览器关闭后，数据依然会一直存在</li></ol><ul><li><p>localStorage有效期是永久的。一般的浏览器能存储的是5MB左右。sessionStorage api与localStorage相同。</p><p>sessionStorage默认的有效期是浏览器的会话时间（也就是说标签页关闭后就消失了）。</p></li><li><p>localStorage作用域是协议、主机名、端口。（理论上，不人为的删除，一直存在设备中）</p><p>sessionStorage作用域是窗口、协议、主机名、端口。</p></li></ul><h2 id="Shiro整合JWT：解决jwt注销和续签的问题"><a href="#Shiro整合JWT：解决jwt注销和续签的问题" class="headerlink" title="Shiro整合JWT：解决jwt注销和续签的问题"></a>Shiro整合JWT：解决jwt注销和续签的问题</h2><h3 id="场景一：token的注销问题（黑名单）"><a href="#场景一：token的注销问题（黑名单）" class="headerlink" title="场景一：token的注销问题（黑名单）"></a>场景一：token的注销问题（黑名单）</h3><p>注销登录等场景下 token 还有效的场景：</p><p>① 退出登录；</p><p>② 修改密码；</p><p>③ 用户的角色或者权限发生了改变；</p><p>④ 用户被禁用；</p><p>④ 用户被删除；</p><p>⑤ 用户被锁定；</p><p>⑥ 管理员注销用户；</p><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，我们只需要删除服务端session中的记录即可。但是，使用 token 认证的方式就不好解决了，因为token是一次性的，token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的；</p><p><strong>解决方法：</strong></p><p>① 将 token 存入内存数据库：将 token 存入 DB 或redis中。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从redis中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则，不可取。</p><p>② 黑名单机制：使用内存数据库比如 redis 维护一个黑名单，如果想让某个 token 失效的话就直接将这个 token 加入到 黑名单 即可。然后，每次使用 token 进行请求的话都会先判断这个 token 是否存在于黑名单中。</p><p>说明：JWT 最适合的场景是不需要服务端保存用户状态的场景，但是如果考虑到 token 注销和 token 续签的场景话，没有特别好的解决方案，大部分解决方案都给 token 加上了状态，这就有点类似 Session 认证了。</p><h3 id="场景二：token的续签问题"><a href="#场景二：token的续签问题" class="headerlink" title="场景二：token的续签问题"></a>场景二：token的续签问题</h3><p>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</p><p>① 类似于 Session 认证中的做法： 假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。每次请求都返回新 token :这种方案的的思路很简单，但是，很明显，开销会比较大。</p><p>② 用户登录返回两个 token ：第一个是 acessToken ，它的过期时间比较短，不如1天；另外一个是 refreshToken 它的过期时间更长一点比如为10天。客户端登录后，将 accessToken和refreshToken 保存在客户端本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果 refreshToken 有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。</p><p>该方案的不足是：① 需要客户端来配合；② 用户注销的时候需要同时保证两个 token 都无效；③ 重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</p><h3 id="项目中的实现"><a href="#项目中的实现" class="headerlink" title="项目中的实现"></a>项目中的实现</h3><p>在项目中对于token的注销问题使用了黑名单机制，对于token的续签问题使用了accessToken和refreshToken;接下来对上面提到的各种场景进行说明</p><h4 id="3-1-封装JWT工具类"><a href="#3-1-封装JWT工具类" class="headerlink" title="3.1 封装JWT工具类"></a>3.1 封装JWT工具类</h4><p>我们需要封装jWt的工具类，用来操作token，主要包括的方法，token的签发，生成accessToken和refreshToken，获取token的过期时间，token的剩余过期时间，解析token等等方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenUtil</span> &#123;</span><br><span class="line">    <span class="comment">//token的秘钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String securityKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Duration accessTokenExpireTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Duration refreshTokenExpireTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Duration refreshTokenExpireAppTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String issuer;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 签发token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(String issuer, String subject, Map&lt;String, Object&gt; claims, <span class="type">long</span> ttlMillis, String secret)</span> &#123;</span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">        .setSubject(subject)</span><br><span class="line">        .setIssuer(issuer)</span><br><span class="line">        .setIssuedAt(System.currentTimeMillis())</span><br><span class="line">        .setClaims(claims)</span><br><span class="line">        .signWith(SignatureAlgorithm.HS256,  DatatypeConverter.parseBase64Binary(secret));</span><br><span class="line">    <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//过期时间=当前时间+过期时长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">        builder.setExpiration(exp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 access_token：这个过期时间比较短，token的过期时间是2小时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAccessToken</span><span class="params">(String subject, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> generateToken(issuer, subject, claims, accessTokenExpireTime.toMillis(), securityKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 PC refresh_token：这个过期时间比较长，是8小时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getRefreshToken</span><span class="params">(String subject, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> generateToken(issuer, subject, claims, refreshTokenExpireTime.toMillis(), securityKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析token：从token中获取claims</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">getClaimsFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        claims = Jwts.parser()</span><br><span class="line">        .setSigningKey(DatatypeConverter.parseBase64Binary(securityKey))</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ClaimJwtException) &#123;</span><br><span class="line">            claims = ((ClaimJwtException) e).getClaims();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> claims;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserId</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        userId = claims.getSubject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;eror=&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUserName</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        username = (String) claims.get(Constant.JWT_USER_NAME);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;eror=&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证token 是否过期(true:已过期 false:未过期)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        <span class="comment">//token的过期时间 = 签发token时的时间 + 过期时长</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiration</span> <span class="operator">=</span> claims.getExpiration();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error=&#123;&#125;&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证token是否有效 (true：验证通过 false：验证失败)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">validateToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claimsFromToken</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">    <span class="keyword">return</span> (claimsFromToken ！= <span class="literal">null</span> &amp;&amp; !isTokenExpired(token));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取token的剩余过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getRemainingTime</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//剩余过期时间 = token的过期时间-当前时间</span></span><br><span class="line">        result = getClaimsFromToken(token).getExpiration().getTime() - nowMillis;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error=&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-配置Shiro的自定义认证类"><a href="#3-2-配置Shiro的自定义认证类" class="headerlink" title="3.2 配置Shiro的自定义认证类"></a>3.2 配置Shiro的自定义认证类</h4><p>这个配置我在上一篇文章中Shiro+jwt实现认证和授权有讲到，这里不再赘述，主要想说这里面配置的比较重要的一个类，自定义的token的认证类，我们在使用Shiro 进行认证时会认证token，配置token的认证方式；</p><p>后面当我们解决token的续签问题和token的注销问题时，都会在这儿认证token，比如：退出登录时我们使用黑名单机制将 token 放入redis缓存，认证token的时候，就会去黑名单（redis缓存）中看看，如果黑名单中有，则验证失败。而这个认证的逻辑就是在这个自定义的类中配置的，并由Shiro完成认证；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title class_">HashedCredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="type">CustomUsernamePasswordToken</span> <span class="variable">customUsernamePasswordToken</span></span><br><span class="line">            <span class="operator">=</span> (CustomUsernamePasswordToken) token;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> (String) customUsernamePasswordToken.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//校验token，判断token是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-登录和退出登录（token注销）"><a href="#3-3-登录和退出登录（token注销）" class="headerlink" title="3.3 登录和退出登录（token注销）"></a>3.3 登录和退出登录（token注销）</h4><p>为了凸显我想说的主题，所以一些类的封装代码和不重要的代码代码会省略掉，后文也是的；</p><h5 id="3-3-1-登录接口"><a href="#3-3-1-登录接口" class="headerlink" title="3.3.1 登录接口"></a>3.3.1 登录接口</h5><p>在第一次登录时，服务端会签发两个token分别是accessToken和refreshToken，并返回给客户端，保存在客户端本地，refreshToken（8小时）的过期时间比accessToken（2小时）的过期时间要长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoginRespVO <span class="title function_">login</span><span class="params">(LoginReqVO vo)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//一些密码用户认证的不重要信息已省略......</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//向claims中存放用户信息和权限信息</span></span><br><span class="line">        claims.put(Constant.ROLES_INFOS_KEY, getRoleByUserId(userInfoByName.getId()));</span><br><span class="line">        claims.put(Constant.PERMISSIONS_INFOS_KEY, getPermissionByUserId(userInfoByName.getId()));</span><br><span class="line">        claims.put(Constant.JWT_USER_NAME, userInfoByName.getUsername());</span><br><span class="line">        <span class="comment">//服务端生成accessToken</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> JwtTokenUtil.getAccessToken(userInfoByName.getId(), claims);</span><br><span class="line">        <span class="comment">//服务端生成refreshToke </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> JwtTokenUtil.getRefreshToken(userInfoByName.getId(), claims);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将accessToken和refreshToken返回给客户端并保存在客户端本地</span></span><br><span class="line">        loginRespVO.setAccessToken(accessToken);</span><br><span class="line">        loginRespVO.setRefreshToken(refreshToken);</span><br><span class="line">        <span class="keyword">return</span> loginRespVO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-退出登录"><a href="#3-3-2-退出登录" class="headerlink" title="3.3.2 退出登录"></a>3.3.2 退出登录</h5><p>退出登录时需要将accessToken和refreshToken同时失效，放入黑名单中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String accessToken, String refreshToken)</span> &#123;</span><br><span class="line">        <span class="comment">//从请求中获取accessToken和refreshToken</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(accessToken) || StringUtils.isEmpty(refreshToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span> (subject != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//退出登录</span></span><br><span class="line">            subject.logout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">        <span class="comment">//退出登录后需要保证accessToken和refreshToken都无效</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//把accessToken 加入黑名单,设置redis的过期时间和token的剩余过期时间相同</span></span><br><span class="line">        redisService.set(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken, userId, JwtTokenUtil.getRemainingTime(accessToken), TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//把refreshToken 加入黑名单</span></span><br><span class="line">        redisService.set(Constant.JWT_REFRESH_IDENTIFICATION + refreshToken, userId, JwtTokenUtil.getRemainingTime(refreshToken), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-3-在shiro的自定义认证类中添加认证规则"><a href="#3-3-3-在shiro的自定义认证类中添加认证规则" class="headerlink" title="3.3.3 在shiro的自定义认证类中添加认证规则"></a>3.3.3 在shiro的自定义认证类中添加认证规则</h5><p>我们已经把accessToken和refreshToken加入了redis中（黑名单中），当用户再次访问时，我们需要判断这个黑名单中有没有token对应的key，如果有的话，token认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title class_">HashedCredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="comment">//从用户的登录请求中获取accessToken</span></span><br><span class="line">        <span class="type">CustomUsernamePasswordToken</span> <span class="variable">customUsernamePasswordToken</span></span><br><span class="line">            <span class="operator">=</span> (CustomUsernamePasswordToken) token;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> (String) customUsernamePasswordToken.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//校验token，判断token是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断黑名单中有没有accessToken对应的key，如果有的话，认证失败抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-修改密码（token注销）"><a href="#3-4-修改密码（token注销）" class="headerlink" title="3.4 修改密码（token注销）"></a>3.4 修改密码（token注销）</h4><p>当用户修改密码时，我们需要注销还没失效的token，因为之前的token已经不能在使用了，因此当用户修改密码后，将accessToken和refreshToken加入黑名单中，然后当用户再次访问时，判断黑名单中有没有对应的token，如果有，禁止访问，需重新登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userUpdatePwd</span><span class="params">(UserUpdatePwdReqVO vo, String accessToken, String refreshToken)</span> &#123;</span><br><span class="line">    <span class="comment">//判断token是否失效</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> sysUserMapper.selectByPrimaryKey(userId);</span><br><span class="line">    <span class="keyword">if</span> (sysUser == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断旧的密码是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (!PasswordUtils.matches(sysUser.getSalt(), vo.getOldPwd(), sysUser.getPassword())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OLD_PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存新密码</span></span><br><span class="line">    sysUser.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    sysUser.setUpdateId(userId);</span><br><span class="line">    sysUser.setPassword(PasswordUtils.encode(vo.getNewPwd(), sysUser.getSalt()));</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysUserMapper.updateByPrimaryKeySelective(sysUser);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把token 加入黑名单 禁止再访问我们的系统资源，设置redis的过期时间和token的剩余过期时间相同</span></span><br><span class="line">    redisService.set(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken, userId, JwtTokenUtil.getRemainingTime(accessToken), TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="comment">//把 refreshToken 加入黑名单 禁止再拿来刷新token</span></span><br><span class="line">    redisService.set(Constant.JWT_REFRESH_TOKEN_BLACKLIST + refreshToken, userId, JwtTokenUtil.getRemainingTime(refreshToken), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们redis的key和退出登录时设置的key相同，因此不用再在shiro的自定义认证类中添加认证规则</p><h4 id="3-5-token续签问题（token续签）"><a href="#3-5-token续签问题（token续签）" class="headerlink" title="3.5 token续签问题（token续签）"></a>3.5 token续签问题（token续签）</h4><p>jwt 刷新有两种情况要考虑？</p><p>① 一种是管理员修改了该用户的角色/权限(需要主动去刷新)。角色和权限发生变化时之前签发的token就失效了，需要主动刷新token获取最先的角色和权限；<br>② 一种是之前签发的accessToken过期了，需要自动刷新通过refreshToken换取（生成）新的accessToken，自动刷新当前请求接口。</p><p>在刷新token时，前端请求需要携带之前保留的refreshToken，交给服务端去校验，服务端校验成功后，就会生成一个新的token，返回给前端，前端得到后就会保留在客户端本地（logstorage ）中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刷新token</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">refreshToken</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">        <span class="comment">//它是否过期、是否被加如了黑名</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(refreshToken) || redisService.hasKey(Constant.JWT_REFRESH_TOKEN_BLACKLIST + refreshToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从token中获取userId和userName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(refreshToken);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> JwtTokenUtil.getUserName(refreshToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//向claims中存放角色和权限等信息</span></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(Constant.ROLES_INFOS_KEY, getRoleByUserId(userId));</span><br><span class="line">        claims.put(Constant.PERMISSIONS_INFOS_KEY, getPermissionByUserId(userId));</span><br><span class="line">        claims.put(Constant.JWT_USER_NAME, username);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//生成新的token，token中包含了用户的最新角色和权限，userId、userName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newAccessToken</span> <span class="operator">=</span> JwtTokenUtil.getAccessToken(userId, claims);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> newAccessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-用户的角色发生了变化（token注销）"><a href="#3-6-用户的角色发生了变化（token注销）" class="headerlink" title="3.6 用户的角色发生了变化（token注销）"></a>3.6 用户的角色发生了变化（token注销）</h4><h5 id="3-6-1-更新角色"><a href="#3-6-1-更新角色" class="headerlink" title="3.6.1 更新角色"></a>3.6.1 更新角色</h5><p>这里涉及了jwt的自动刷新问题，也是我们上面提到的问题，当用户的角色发生变化时，旧的token中的角色信息已经不正确，我们需要主动刷新token，在token中保存更新过的角色信息。</p><p>因此当用户的角色发生变化时，需要标记该角色对应的用户，即放入redis的缓存中，认证的时候判断redis中有没有对应的key，如果有，再判断token有没有主动刷新过，如果主动刷新过则认证成功，否则认证失败；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateRole</span><span class="params">(RoleUpdateReqVO vo)</span> &#123;</span><br><span class="line">        <span class="comment">//保存角色基本信息</span></span><br><span class="line">        <span class="type">SysRole</span> <span class="variable">sysRole</span> <span class="operator">=</span> sysRoleMapper.selectByPrimaryKey(vo.getId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == sysRole) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanUtils.copyProperties(vo, sysRole);</span><br><span class="line">        sysRole.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sysRoleMapper.updateByPrimaryKeySelective(sysRole);</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改该角色和菜单权限关联数据</span></span><br><span class="line">        <span class="type">RolePermissionOperationReqVO</span> <span class="variable">reqVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RolePermissionOperationReqVO</span>();</span><br><span class="line">        reqVO.setRoleId(vo.getId());</span><br><span class="line">        reqVO.setPermissionIds(vo.getPermissions());</span><br><span class="line">        rolePermissionService.addRolePermission(reqVO);</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; userIdsBtRoleId = userRoleService.getUserIdsBtRoleId(vo.getId());</span><br><span class="line">        <span class="keyword">if</span> (!userIdsBtRoleId.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String userId :userIdsBtRoleId) &#123;</span><br><span class="line">                <span class="comment">// 用户角色发生了变化，需要将该角色对应的用户标记起来，认证时判断token有没有主动刷新过</span></span><br><span class="line">                <span class="comment">// 设置redis的失效时间为accessToken的过期时长（配置的2h）</span></span><br><span class="line">                redisService.set(Constant.JWT_REFRESH_KEY + userId, userId, JwtTokenUtil.getAccessTokenExpireTime().toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-删除角色"><a href="#3-6-2-删除角色" class="headerlink" title="3.6.2 删除角色"></a>3.6.2 删除角色</h5><p>删除角色原理和更新角色原理相同，不再赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletedRole</span><span class="params">(String roleId)</span> &#123;</span><br><span class="line">        <span class="comment">//更新删除的角色数据</span></span><br><span class="line">        <span class="type">SysRole</span> <span class="variable">sysRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysRole</span>();</span><br><span class="line">        sysRole.setId(roleId);</span><br><span class="line">        sysRole.setDeleted(<span class="number">0</span>);</span><br><span class="line">        sysRole.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysRoleMapper.updateByPrimaryKeySelective(sysRole);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//角色菜单权限关联数据删除</span></span><br><span class="line">        rolePermissionService.removeByRoleId(roleId);</span><br><span class="line">        List&lt;String&gt; userIdsBtRoleId = userRoleService.getUserIdsBtRoleId(roleId);</span><br><span class="line">        <span class="comment">//角色用户关联数据删除</span></span><br><span class="line">        userRoleService.removeUserRoleId(roleId);</span><br><span class="line">        <span class="comment">//把跟该角色关联的用户标记起来，需要刷新token</span></span><br><span class="line">        <span class="keyword">if</span> (!userIdsBtRoleId.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String userId :userIdsBtRoleId) &#123;</span><br><span class="line">                <span class="comment">//用户角色发生了变化，标记用户 在用户认证的时候判断token是否主动刷过</span></span><br><span class="line">                redisService.set(Constant.JWT_REFRESH_KEY + userId, userId, JwtTokenUtil.getAccessTokenExpireTime().toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-3-在shiro的自定义认证类中添加认证规则"><a href="#3-6-3-在shiro的自定义认证类中添加认证规则" class="headerlink" title="3.6.3 在shiro的自定义认证类中添加认证规则"></a>3.6.3 在shiro的自定义认证类中添加认证规则</h5><p>当用户角色发生变化时，token就需要重新认证，在Shiro的自定义认证类中，增加认证规则，步骤：</p><p>① 判断用户是否被标记了，如果被标记了说明用户的角色或者权限发生了变化</p><p>② 判断用户是否已经互动刷新过token</p><p>角色发生变化时，设置的redis的过期时长就是accessToken的过期时长即2小时，若角色变化后，用户主动刷新过token，那么redis的剩余过期时间一定小于新生成的accessToken的剩余过期时间，如果redis的剩余过期时间一定大于新生成的accessToken的剩余过期时间，说明没有刷新过，认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title class_">HashedCredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="comment">//从用户的登录请求中获取accessToken</span></span><br><span class="line">        <span class="type">CustomUsernamePasswordToken</span> <span class="variable">customUsernamePasswordToken</span></span><br><span class="line">            <span class="operator">=</span> (CustomUsernamePasswordToken) token;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> (String) customUsernamePasswordToken.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//校验token，判断token是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断黑名单中有没有accessToken对应的key，如果有的话，认证失败抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断用户是否被标记了，如果被标记了说明用户的角色或者权限发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_REFRESH_KEY + userId)) &#123;</span><br><span class="line">            <span class="comment">//判断用户是否已经互动刷新过token</span></span><br><span class="line">            <span class="comment">//角色发生变化时，设置的redis的过期时长就是accessToken的过期时长即2小时</span></span><br><span class="line">            <span class="comment">//若角色变化后，用户主动刷新过token，</span></span><br><span class="line">            <span class="comment">//那么redis的剩余过期时间一定小于新生成的accessToken的剩余过期时间</span></span><br><span class="line">            <span class="comment">//如果redis的剩余过期时间一定大于新生成的accessToken的剩余过期时间，说明没有刷新过，认证失败</span></span><br><span class="line">            <span class="keyword">if</span> (redisService.getExpire(Constant.JWT_REFRESH_KEY + userId, TimeUnit.MILLISECONDS) &gt; JwtTokenUtil.getRemainingTime(accessToken)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-用户的权限发生了变化（token注销）"><a href="#3-7-用户的权限发生了变化（token注销）" class="headerlink" title="3.7 用户的权限发生了变化（token注销）"></a>3.7 用户的权限发生了变化（token注销）</h4><h5 id="3-7-1-编辑权限"><a href="#3-7-1-编辑权限" class="headerlink" title="3.7.1 编辑权限"></a>3.7.1 编辑权限</h5><p>原理和编辑角色相同，不再赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PermissionService</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePermission</span><span class="params">(PermissionUpdateReqVO vo)</span> &#123;</span><br><span class="line">        <span class="comment">//校验数据</span></span><br><span class="line">        <span class="type">SysPermission</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysPermission</span>();</span><br><span class="line">        BeanUtils.copyProperties(vo, update);</span><br><span class="line">        verifyForm(update);</span><br><span class="line">        update.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysPermissionMapper.updateByPrimaryKeySelective(update);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断授权标识符是否发生了变化(权限标识符发生了变化，或者权限状态发生了变化)</span></span><br><span class="line">        <span class="keyword">if</span> (!sysPermission.getPerms().equals(vo.getPerms()) || sysPermission.getStatus() != vo.getStatus()) &#123;</span><br><span class="line">            List&lt;String&gt; roleIdsByPermissionId </span><br><span class="line">                = rolePermissionService.getRoleIdsByPermissionId(vo.getId());</span><br><span class="line">            <span class="keyword">if</span> (!roleIdsByPermissionId.isEmpty()) &#123;</span><br><span class="line">                List&lt;String&gt; userIdsByRoleIds </span><br><span class="line">                    = userRoleService.getUserIdsByRoleIds(roleIdsByPermissionId);</span><br><span class="line">                <span class="keyword">if</span> (!userIdsByRoleIds.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String userId : userIdsByRoleIds) &#123;</span><br><span class="line">                        <span class="comment">//用户权限发生变化时，标记该权限对应的用户，在用户认证的时候判断token有没主动刷新</span></span><br><span class="line">                        redisService.set(Constant.JWT_REFRESH_KEY + userId, userId, JwtTokenUtil.getAccessTokenExpireTime().toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7-2-删除权限"><a href="#3-7-2-删除权限" class="headerlink" title="3.7.2 删除权限"></a>3.7.2 删除权限</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletedPermission</span><span class="params">(String permissionId)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否有子集菜单权限关联</span></span><br><span class="line">    List&lt;SysPermission&gt; sysPermissions = sysPermissionMapper.selectChild(permissionId);</span><br><span class="line">    <span class="comment">//如果存在子集关联，那么就不能删除该权限</span></span><br><span class="line">    <span class="keyword">if</span> (!sysPermissions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.ROLE_PERMISSION_RELATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SysPermission</span> <span class="variable">sysPermission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysPermission</span>();</span><br><span class="line">    sysPermission.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    sysPermission.setDeleted(<span class="number">0</span>);</span><br><span class="line">    sysPermission.setId(permissionId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数据库中的权限数据更新,即删除菜单权限</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysPermissionMapper.updateByPrimaryKeySelective(sysPermission);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过permissionId获取roleId---&gt;通过roleId获取userId---&gt;标记该用户，重新签发token</span></span><br><span class="line">    List&lt;String&gt; roleIdsByPermissionId</span><br><span class="line">        = rolePermissionService.getRoleIdsByPermissionId(permissionId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解除相关角色和该菜单权限的关联</span></span><br><span class="line">    rolePermissionService.removeRoleByPermissionId(permissionId);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!roleIdsByPermissionId.isEmpty()) &#123;</span><br><span class="line">        List&lt;String&gt; userIdsByRoleIds </span><br><span class="line">            = userRoleService.getUserIdsByRoleIds(roleIdsByPermissionId);</span><br><span class="line">        <span class="keyword">if</span> (!userIdsByRoleIds.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String userId : userIdsByRoleIds) &#123;</span><br><span class="line">                <span class="comment">//用户权限发生变化时，标记该权限对应的用户，在用户认证的时候判断token有没主动刷新</span></span><br><span class="line">                redisService.set(Constant.JWT_REFRESH_KEY + userId, userId, JwtTokenUtil.getAccessTokenExpireTime().toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为用户角色发生变化和用户权限发生变化时，我们使用的是同一个key，因此不需要再 在shiro的自定义认证类中添加认证规则。</p><h4 id="3-8-用户被禁用（token注销）"><a href="#3-8-用户被禁用（token注销）" class="headerlink" title="3.8 用户被禁用（token注销）"></a>3.8 用户被禁用（token注销）</h4><h5 id="3-8-1-编辑用户"><a href="#3-8-1-编辑用户" class="headerlink" title="3.8.1 编辑用户"></a>3.8.1 编辑用户</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//编辑用户</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(UserUpdateReqVO vo, String operationId)</span> &#123;</span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysUser</span>();</span><br><span class="line">        BeanUtils.copyProperties(vo, sysUser);</span><br><span class="line">        sysUser.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        sysUser.setUpdateId(operationId);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(vo.getPassword())) &#123;</span><br><span class="line">            sysUser.setPassword(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> PasswordUtils.getSalt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">endPwd</span> <span class="operator">=</span> PasswordUtils.encode(vo.getPassword(), salt);</span><br><span class="line">            sysUser.setSalt(salt);</span><br><span class="line">            sysUser.setPassword(endPwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新用户</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysUserMapper.updateByPrimaryKeySelective(sysUser);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//如果用户状态设置为2，说明被禁用，需要标记，认证时判断redis是否有这个key如果有认证不通过</span></span><br><span class="line">        <span class="keyword">if</span> (vo.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            redisService.set(Constant.ACCOUNT_LOCK_KEY + vo.getId(), vo.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果用户状态不是2，需要将这个key从redis中删除</span></span><br><span class="line">            redisService.delete(Constant.ACCOUNT_LOCK_KEY + vo.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-2-在shiro的自定义认证类中添加认证规则"><a href="#3-8-2-在shiro的自定义认证类中添加认证规则" class="headerlink" title="3.8.2 在shiro的自定义认证类中添加认证规则"></a>3.8.2 在shiro的自定义认证类中添加认证规则</h5><p>当用户被禁用时，我们将这个key加入到redis中，认证的时候需要判断redis中有没有这个key，如果有的话，就认证失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title class_">HashedCredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="comment">//从用户的登录请求中获取accessToken</span></span><br><span class="line">        <span class="type">CustomUsernamePasswordToken</span> <span class="variable">customUsernamePasswordToken</span></span><br><span class="line">            <span class="operator">=</span> (CustomUsernamePasswordToken) token;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> (String) customUsernamePasswordToken.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//校验token，判断token是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断黑名单中有没有accessToken对应的key，如果有的话，认证失败抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断用户是否被标记了，如果被标记了说明用户的角色或者权限发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_REFRESH_KEY + userId)) &#123;</span><br><span class="line">            <span class="comment">//判断用户是否已经互动刷新过token</span></span><br><span class="line">            <span class="comment">//角色发生变化时，设置的redis的过期时长就是accessToken的过期时长即2小时</span></span><br><span class="line">            <span class="comment">//若角色变化后，用户主动刷新过token，</span></span><br><span class="line">            <span class="comment">//那么redis的剩余过期时间一定小于新生成的accessToken的剩余过期时间</span></span><br><span class="line">            <span class="comment">//如果redis的剩余过期时间一定大于新生成的accessToken的剩余过期时间，说明没有刷新过，认证失败</span></span><br><span class="line">            <span class="keyword">if</span> (redisService.getExpire(Constant.JWT_REFRESH_KEY + userId, TimeUnit.MILLISECONDS) &gt; JwtTokenUtil.getRemainingTime(accessToken)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//判断是否被锁定，入股redis中含有这个key，就认证失败</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.ACCOUNT_LOCK_KEY + userId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.ACCOUNT_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-用户被删除（token注销）"><a href="#3-9-用户被删除（token注销）" class="headerlink" title="3.9 用户被删除（token注销）"></a>3.9 用户被删除（token注销）</h4><h5 id="3-9-1-删除用户"><a href="#3-9-1-删除用户" class="headerlink" title="3.9.1 删除用户"></a>3.9.1 删除用户</h5><p>这里需要注意的是redis的有效期问题，当用户被删除的时候，之前的签发的token都不能被使用了，因此需要设置redis的过期时长为refreshToken的过期时长，保证之前签发的refreshToken也会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletedUsers</span><span class="params">(List&lt;String&gt; list, String operationId)</span> &#123;</span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">sysUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysUser</span>();</span><br><span class="line">        sysUser.setUpdateId(operationId);</span><br><span class="line">        sysUser.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量删除用户</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sysUserMapper.deletedUsers(sysUser, list);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.OPERATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当用户删除时，需要标记用户，认证的时候判断该用户是否被删除</span></span><br><span class="line"><span class="comment">         * redis的过期时间为refreshToken的过期时间，因为refreshToken的过期时间最长，</span></span><br><span class="line"><span class="comment">         * 需要保证在redis的有效期内，之前签发的所有的token都失效</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (String userId : list) &#123;</span><br><span class="line">            redisService.set(Constant.DELETED_USER_KEY + userId, userId, JwtTokenUtil.getRefreshTokenExpireTime().toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-9-2-在shiro的自定义认证类中添加认证规则"><a href="#3-9-2-在shiro的自定义认证类中添加认证规则" class="headerlink" title="3.9.2 在shiro的自定义认证类中添加认证规则"></a>3.9.2 在shiro的自定义认证类中添加认证规则</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title class_">HashedCredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="comment">//从用户的登录请求中获取accessToken</span></span><br><span class="line">        <span class="type">CustomUsernamePasswordToken</span> <span class="variable">customUsernamePasswordToken</span></span><br><span class="line">            <span class="operator">=</span> (CustomUsernamePasswordToken) token;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> (String) customUsernamePasswordToken.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> JwtTokenUtil.getUserId(accessToken);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//校验token，判断token是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!JwtTokenUtil.validateToken(accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断黑名单中有没有accessToken对应的key，如果有的话，认证失败抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_ACCESS_TOKEN_BLACKLIST + accessToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断用户是否被标记了，如果被标记了说明用户的角色或者权限发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.JWT_REFRESH_KEY + userId)) &#123;</span><br><span class="line">            <span class="comment">//判断用户是否已经互动刷新过token</span></span><br><span class="line">            <span class="comment">//角色发生变化时，设置的redis的过期时长就是accessToken的过期时长即2小时</span></span><br><span class="line">            <span class="comment">//若角色变化后，用户主动刷新过token，</span></span><br><span class="line">            <span class="comment">//那么redis的剩余过期时间一定小于新生成的accessToken的剩余过期时间</span></span><br><span class="line">            <span class="comment">//如果redis的剩余过期时间一定大于新生成的accessToken的剩余过期时间，说明没有刷新过，认证失败</span></span><br><span class="line">            <span class="keyword">if</span> (redisService.getExpire(Constant.JWT_REFRESH_KEY + userId, TimeUnit.MILLISECONDS) &gt; JwtTokenUtil.getRemainingTime(accessToken)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.TOKEN_PAST_DUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//判断是否被锁定，如果redis中含有这个key，就认证失败</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.ACCOUNT_LOCK_KEY + userId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.ACCOUNT_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断用户是否被删除，如果redis中含有这个key，那么认证失败</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.hasKey(Constant.DELETED_USER_KEY + userId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(BaseResponseCode.ACCOUNT_HAS_DELETED_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「我一直在流浪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42764468/article/details/107731844">https://blog.csdn.net/qq_42764468/article/details/107731844</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/mingyry/4509351.html"/>
      <url>/mingyry/4509351.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="Java集合概况"><a href="#Java集合概况" class="headerlink" title="Java集合概况"></a>Java集合概况</h2><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-collection-hierarchy.png" alt="img"></p><h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p><code>Collection</code> 接口下面的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayDeque</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><p><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p></li><li><p><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></p></li><li><p><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p></li><li><p><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</p></li></ul><h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h3><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><ul><li><p><code>RandomAccess</code> 是一个标志接口，表明实现这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</p></li><li><p><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</p></li></ul><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别?"></a>ArrayList 和 Vector 的区别?</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的。</li></ul><h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）</li><li>插入和删除是否受元素位置的影响：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了<code>`RandomAccess</code>接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="ArrayList扩容机制分析"><a href="#ArrayList扩容机制分析" class="headerlink" title="ArrayList扩容机制分析"></a>ArrayList扩容机制分析</h3><p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p><h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><div class="table-container"><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table></div><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><div class="table-container"><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table></div><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是<strong>小顶堆</strong>，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; bigHeap=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2-o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h2 id="Map接口之HashMap"><a href="#Map接口之HashMap" class="headerlink" title="Map接口之HashMap"></a>Map接口之HashMap</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h3 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h3><ul><li><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p></li><li><p>JDK1.8 以后在解决哈希冲突时有了较大的变化。</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p></li></ul><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul><li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</p></li></ul><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。）</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>HashMap</code></th><th style="text-align:center"><code>HashSet</code></th></tr></thead><tbody><tr><td style="text-align:center">实现了 <code>Map</code> 接口</td><td style="text-align:center">实现 <code>Set</code> 接口</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调用 <code>put()</code>向 map 中添加元素</td><td style="text-align:center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td style="text-align:center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td style="text-align:center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table></div><h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口</p><ul><li><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p></li><li><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p></li></ul><h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。</p><p>因为计算数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。</p><h3 id="HashMap-多线程的问题"><a href="#HashMap-多线程的问题" class="headerlink" title="HashMap 多线程的问题"></a>HashMap 多线程的问题</h3><h4 id="HashMap在多线程put后可能导致get无限循环"><a href="#HashMap在多线程put后可能导致get无限循环" class="headerlink" title="HashMap在多线程put后可能导致get无限循环"></a>HashMap在多线程put后可能导致get无限循环</h4><p><a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p><h4 id="多线程put的时候可能导致元素丢失"><a href="#多线程put的时候可能导致元素丢失" class="headerlink" title="多线程put的时候可能导致元素丢失"></a>多线程put的时候可能导致元素丢失</h4><p>考虑在多线程下put操作时，执行addEntry(hash, key, value, i)，如果有产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会出现覆盖丢失的情况。</p><h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap <a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">有哪几种常见的遍历方式</a>?</h3><ol><li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Lambda 表达式的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 单线程的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 多线程的方式进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><code>entrySet</code> 的性能比 <code>keySet</code> 的性能高出了一倍之多，因此我们应该尽量使用 <code>entrySet</code> 来实现 Map 集合的遍历</strong>。</p><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p><p><strong>我们应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。</p><h2 id="Map接口之ConcurrentHashMap"><a href="#Map接口之ConcurrentHashMap" class="headerlink" title="Map接口之ConcurrentHashMap"></a>Map接口之ConcurrentHashMap</h2><p>参考文档 <a href="https://www.imooc.com/article/314726">https://www.imooc.com/article/314726</a></p><h3 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a>ConcurrentHashMap 的实现原理</h3><p><strong>JDK1.7</strong>：ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8bf6d4aa717a871c73d5d2699d822fed.png" alt="img" style="zoom: 80%;" /></p><p><strong>JDK1.8</strong>：选择了与 HashMap 相同的<strong>Node数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加细粒度的锁。</p><p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3e0ef497f95c88e6d409cd6f0737bfe3.png" alt="img" style="zoom:80%;" /></p><h3 id="JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？"><a href="#JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？" class="headerlink" title="JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？"></a>JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？</h3><ul><li><p>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</p></li><li><p>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p></li></ul><h3 id="ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><ol><li>尝试自旋获取锁。</li><li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ol><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><ol><li><p>根据 key 计算出 hash 值；</p></li><li><p>判断是否需要进行初始化；</p></li><li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p><ul><li>如果为 null ，则通过 CAS 的方式尝试添加；</li><li>如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；</li><li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</li></ul></li><li>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</li></ol><h3 id="ConcurrentHashMap-的-get-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-get-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 get 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 get 方法执行逻辑是什么？</h3><h4 id="JDK1-7-1"><a href="#JDK1-7-1" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><ol><li><p>根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p></li><li><p>HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p></li></ol><h4 id="JDK1-8-1"><a href="#JDK1-8-1" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><ol><li>根据 key 计算出 hash 值，判断数组是否为空；</li><li>如果是首节点，就直接返回；</li><li>如果是红黑树结构，就从红黑树里面查询；</li><li>如果是链表结构，循环遍历判断。</li></ol><h3 id="ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？"><a href="#ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？" class="headerlink" title="ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？"></a>ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h3><ul><li>我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</li></ul><p>而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p><p><strong>我们用反证法来推理：</strong></p><p>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p><p>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。</p><p>但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p><h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p>实现线程安全的方式（重要）：</p><ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>Hashtable</strong> :</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/jdk1.7_hashmap.png" alt="Hashtable 的内部结构"></p><p><strong>JDK1.8 的 ConcurrentHashMap</strong> ：</p></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" style="zoom:80%;" /></p><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421170614212.png" alt="image-20230421170614212"></p><p>说明:上图有两个小问题：</p><ul><li>直接覆盖之后应该就会 return，不会有后续操作。。</li><li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK1.7 put 方法</strong>：头插法</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transfer函数</strong></p><p>transfer逻辑其实也简单，遍历旧数组，将旧数组元素通过头插法的方式，迁移到新数组的对应位置问题出就出在头插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="comment">//src旧数组</span></span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);<span class="comment">//由于是链表，所以是个循环过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-HTTP</title>
      <link href="/mingyry/c6823846.html"/>
      <url>/mingyry/c6823846.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-HTTP"><a href="#计算机网络-HTTP" class="headerlink" title="计算机网络-HTTP"></a>计算机网络-HTTP</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p><h3 id="HTTP：超文本传输协议"><a href="#HTTP：超文本传输协议" class="headerlink" title="HTTP：超文本传输协议"></a>HTTP：超文本传输协议</h3><h4 id="HTTP常见的状态码"><a href="#HTTP常见的状态码" class="headerlink" title="HTTP常见的状态码"></a>HTTP常见的状态码</h4><p><code>1XX</code>属于提示信息，是协议处理中的一种中间状态</p><p><code>2XX</code>表示服务器成功处理了客户端的请求</p><ul><li><p><code>200 OK</code> 最常见的成功状态码，表示一切正常</p></li><li><p><code>204 No Content</code> 成功状态码，但是响应头中没有body数据</p></li><li><code>206 Partial Content</code> 应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分</li></ul><p><code>3XX</code>表示重定向，需要客户端重现发送请求获取资源</p><ul><li><p><code>301 Moved Permanently</code> 表示永久重定向，说明请求的资源已经不存在了</p></li><li><p><code>302 Found</code> 表示临时重定向，说明请求的资源还在，但暂时需要另一个URL来访问</p><p>301和302浏览器会自动重新定向到新的URL</p></li><li><p><code>304 Not Modified</code> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件</p></li></ul><p><code>4XX</code> 表示客户端发送的报文有误，服务器无法处理</p><ul><li><p><code>400 Bad Request</code> 表示客户端请求的报文有错误</p></li><li><p><code>403 Forbidden</code> 表示服务器禁止访问资源</p></li><li><code>404 Not Found</code> 表示请求的资源在服务器上不存在或者未找到</li></ul><p><code>5XX</code>表示客户端请求报文正确，但是服务器处理时内部发生错误，属于服务器端的错误码</p><ul><li><code>500 Internal Server Error</code> 通用错误码，服务器端发生错误</li><li><code>501 Not Implemented</code> 表示客户端请求的功能还不支持</li><li><code>502 Bad Gateway</code> 服务器作为网关或代理时返回的错误码、表示服务器自身工作正常，访问后端服务器发生了错误</li><li><code>503 Service Unavailable</code> 表示服务器当前很忙，暂时无法响应客户端</li></ul><h4 id="Get方法和Post方法"><a href="#Get方法和Post方法" class="headerlink" title="Get方法和Post方法"></a>Get方法和Post方法</h4><ul><li>Get方法是从服务器获取指定的资源</li><li>Post方法是根据Body对指定的资源做出处理</li></ul><p>安全性：请求方法不会破坏服务器上的资源</p><p>幂等性：多次执行相同的操作，结果都是相同的</p><ul><li>Get方法是安全且幂等的，可以对Get请求的数据做缓存，可以将缓存发给到浏览器身上，也可以做到代理上（nginx）</li><li>Post方法不安全且不幂等，不能把Post请求作为缓存</li></ul><p>注意：以上前提是根据RFC（互联网中的标准，所定义的）规范定义的语义来分析的，你也可以选择在get方法中携带body。</p><h4 id="HTTP的缓存技术"><a href="#HTTP的缓存技术" class="headerlink" title="HTTP的缓存技术"></a>HTTP的缓存技术</h4><h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</p><ul><li><code>Cache-Control</code>， 是一个相对时间</li><li><p><code>Expires</code>，是一个绝对时间</p></li><li><p>都表示资源在客户端缓存的有效期</p></li></ul><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>当请求的响应码是<code>304</code>时，就告诉浏览器可以使用本地缓存的资源，这种需要通过服务器来告知客户端是否可以使用缓存的方式叫做协商缓存</p><p>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p></li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>简单：基本的报文格式就是<code>header+body</code>，头部信息也是<code>key-value</code>的简单文本的形式</li><li>灵活和易于扩展：<ul><li>HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</li><li>因为HTTP是应用层的协议，可以向下扩展：<ul><li>HTTPS就是在应用层和传输层加入SSL/TLS</li><li>HTTP1.1和HTTP2.0都是使用TCP进行传输，HTTP3.0使用UDP进行传输</li></ul></li></ul></li><li>应用广泛和跨平台：可以跨平台使用</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>无状态双刃剑：</p><p>每次请求都需要验证用户的信息（解决办法，cookie或者jwt，或者Session）</p></li><li><p>明文传输的弊端：</p><p>HTTP所有的信息都可以被窃取</p></li><li><p>不安全</p><ul><li>通信使用了明文</li><li>不验证通信双方的身份</li><li>无法证明报文的完整性</li></ul></li></ul><h4 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h4><p>HTTP协议是基于TCP/IP，并且使用了请求-应答的通信模式</p><ul><li><p>长连接：    </p><p>只要任意一端没有明确提出断开连接，则保持TCP连接状态</p><p>减少了TCP连接重复建立和断开所造成的开销，减轻了服务器端的负载</p></li><li><p>管道（pipeline）网络传输：</p><ul><li>在同一个TCP连接里，客户端可以发起多个请求，不需要等待回应，即可再发送请求，<strong>减少了整体的响应时间</strong></li><li>问题：解决了请求的队头阻塞，但是没有解决响应的队头阻塞问题，并且没有使用</li></ul></li><li><p>队头阻塞：</p><p>当顺序发送的请求队列有一个请求没有没处理时，其他后面的请求都无法处理，一直阻塞</p></li></ul><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ul><li><p>避免发送HTTP请求：</p><p>通过缓存技术，将响应的数据缓存在本地，获取本地数据的速度肯定要大于网路传输的速度</p></li><li><p>减少HTTP请求次数：</p><ul><li><p>减少重定向请求次数：</p><p>将重定向工作交给代理服务器来完成，不用经过客户端</p></li><li><p>合并请求：</p><ul><li>减少了重复发送的HTTP头部</li><li>解决方法：合并资源，到客户端后再将资源分解</li></ul></li><li><p>延迟发送请求：</p><p>按需获取，不需要所有资源都加载</p></li></ul></li><li><p>减少HTTP响应的数据大小</p><p>对相应的资源进行压缩</p><ul><li><p>无损压缩：</p><p>信息不会被破环，可以完全恢复成压缩前的模样</p></li><li><p>有损压缩：</p><p>牺牲一些质量来减少数据量、提高压缩比。用于压缩多媒体数据，音频、视频、图片等</p></li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了SSL/TLS安全协议使得报文能够加密传输</p><p>TCP三次握手之后，再进行SSL/TLS的握手过程，才可以进行加密报文传输</p><h4 id="HTTP-的风险和-HTTPS-的解决"><a href="#HTTP-的风险和-HTTPS-的解决" class="headerlink" title="HTTP 的风险和 HTTPS 的解决"></a>HTTP 的风险和 HTTPS 的解决</h4><p>安全上存在三个风险</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p>HTTPS的<code>SSL/TLS</code>协议的 解决办法：</p><ul><li>信息加密：交互信息无法被窃取 （混合加密）</li><li>校验机制：无法篡改通信内容 （摘要算法+数字签名）</li><li>身份证书：保证身份的准确性（数字证书）</li></ul><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的方式</p><ul><li>再通信建立前采用<strong>非对称加密</strong>的方式，交换会话密钥:key:，后续就不再使用非对称加密</li><li>再通信过程中全部使用<strong>对称加密</strong>的会话密钥:key:加密明文数据</li></ul><p>采用混合加密的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换</li><li><strong>非对称加密</strong>，使用公钥和私钥，解决了密钥交换问题但速度慢</li></ul><h5 id="摘要算法和数字签名"><a href="#摘要算法和数字签名" class="headerlink" title="摘要算法和数字签名"></a>摘要算法和数字签名</h5><p>利用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的指纹，所得哈希值是唯一的，且无法通过哈希值推导出内容</p><p>通过摘要算法可以保证内容不会被篡改，但是无法保证整个内容有没有被替换出去，缺少客户端收到的消息来源于服务端的证明</p><p>采用<strong>非对称加密算法</strong>来解决这个问题：</p><ul><li>一个公钥，公开给所有人</li><li>一个私钥，必须由本人管理，不可泄漏</li></ul><p>两个密钥可以互相加密或者解密，流程不同，目的也不同</p><ul><li><p><strong>公钥加密，私钥解密</strong>：</p><ul><li><strong>保证内容传输的安全</strong></li><li>被公钥加密的内容，其他人是无法解密的，只有持有私钥的人才能解密</li></ul></li><li><p><strong>私钥加密，公钥解密</strong>：</p><ul><li>保证消息不会被冒充</li><li>私钥不可泄漏，如果公钥能够正常解密出私钥加密的内容，就说明这个消息是来源于持有私钥身份的人发送的</li></ul></li></ul><p>数字签名算法：就是通过私钥加密，公钥解密的方式来确认消息的身份，加密的是消息内容的哈希值而不是消息内容本身</p><p>非对称加密的主要用途在于，确认消息的身份，一般不用非对称加密来加密消息内容，比较消耗性能</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><ul><li>已经保证了消息的完整性</li><li>保证了消息来源的可靠性</li></ul><p>但是缺少身份验证的环节，可以私钥和公钥都被替换掉了</p><p>因此，提出数字证书：</p><p>「个人信息 + 公钥 + 数字签名」打包成一个数字证书</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419110359781.png" alt="image-20230419110359781" style="zoom: 80%;" /></p><h4 id="HTTPS建立连接的流程"><a href="#HTTPS建立连接的流程" class="headerlink" title="HTTPS建立连接的流程"></a>HTTPS建立连接的流程</h4><p>SSL/TLS 协议的基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥</li><li>双方协商生产会话密钥</li><li>双方采用会话密钥进行加密通信</li></ul><p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法和 ECDHE 算法 。</p><h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程"></p><ul><li>第一次握手：客户端发送 「<strong>Client Hello</strong>」里面有TLS版本号，随机数C，密码套件列表</li><li>第二次握手：<ul><li>服务器端发送「<strong>Server Hello</strong>」，里面有确认的TLS版本号，随机数S，密码套件（RSA）</li><li>服务器端「<strong>Server Certificate</strong>」，里面有数字证书</li><li>服务端发了「<strong>Server Hello Done</strong>」消息，告诉打招呼完毕</li></ul></li><li>第三次握手：<ul><li>客户端发送「<strong>Client Key Exchange</strong>」，里面包含加密后的随机数A，此时客户端已经有三个随机数，生成了<strong>会话密钥（Master Secret）</strong>。</li><li>客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务器开始使用加密方式发送消息</li><li>客户端发一个「<strong>Finish</strong>」</li></ul></li><li>第四次握手：<ul><li>服务器端发「<strong>Change Cipher Spec</strong>」告诉客户端开始使用加密方式发送消息</li><li>服务器端发「<strong>Finish</strong>」</li><li>服务器端会发「<strong>Encrypted Handshake Message</strong>」消息，让客户端验证对称密钥是否可以正常使用</li></ul></li></ul><h5 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h5><p>不支持前向保密</p><p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解</p><h4 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h4><p><strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p><p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p><ul><li><p>第一次握手：客户端发送 「<strong>Client Hello</strong>」里面有TLS版本号，随机数C，密码套件列表</p></li><li><p>第二次握手：</p><ul><li><p>服务端发送「<strong>Server Hello</strong>」消息，里面有确认的TLS版本号，随机数S，密码套件（ECDHE）</p></li><li><p>服务器端发送「<strong>Server Certificate</strong>」，里面有数字证书</p></li><li>服务器端发送「<strong>Server Key Exchange</strong>」，里面有选择的椭圆曲线，椭圆曲线的公钥，密钥留在服务器内</li><li>服务端发送「<strong>Server Hello Done</strong>」消息，告诉打招呼完毕</li></ul></li></ul><p><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p><ul><li><p>第三次握手：</p><ul><li>客户端发送「<strong>Client Key Exchange</strong>」，里面有椭圆曲线的公钥，私钥留在客户端内</li><li>客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</li><li>客户端会发「<strong>Encrypted Handshake Message</strong>」消息，让服务器端验证对称密钥是否可以正常使用</li></ul></li><li><p>第四次握手：</p><ul><li>服务端 发「<strong>Change Cipher Spec</strong>」告诉客户端开始使用加密方式发送消息</li><li>服务器端会发「<strong>Encrypted Handshake Message</strong>」消息，让客户端验证对称密钥是否可以正常使用</li></ul></li></ul><p>ECDHE密钥协商算法支持前向保密</p><h4 id="HTTPS一定安全可靠么"><a href="#HTTPS一定安全可靠么" class="headerlink" title="HTTPS一定安全可靠么"></a>HTTPS一定安全可靠么</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img"></p><p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p><h4 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h4><ul><li>性能损耗：<ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul></li><li><p>硬件优化：</p><ul><li><strong>HTTPS 协议是计算密集型，而不是 I/O 密集型</strong></li><li>选择好的CPU</li><li>选择可以<strong>支持 AES-NI 特性的 CPU</strong></li></ul></li><li><p>软件优化：</p><ul><li>软件升级：<ul><li>将 Linux 内核从 2.x 升级到 4.x；</li><li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li></ul></li><li>协议优化：<ul><li>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高。</li><li><strong>选用 ECDHE 密钥交换</strong>，支持「False Start」，<strong>而且安全性也高，具备前向安全性</strong></li></ul></li><li>TLS升级：<ul><li>TLS 1.2 升级成 TLS 1.3，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</li><li><strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</li></ul></li></ul></li><li><p>证书优化：</p><ul><li>证书传输优化：选择ECDSA证书</li><li>证书验证优化：</li></ul></li><li><p>会话复用：</p><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p><ul><li><p>Session ID：<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong></p><p>问题：</p><ul><li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li><li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li></ul></li><li><p>Session Ticket：<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p></li></ul><p>二者都<strong>不具备前向安全性</strong></p></li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h4 id="HTTP-1-1的问题"><a href="#HTTP-1-1的问题" class="headerlink" title="HTTP/1.1的问题"></a>HTTP/1.1的问题</h4><ul><li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li><li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li><li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li><li><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；</li><li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li></ul><h4 id="HTTP-2兼容HTTP-1-1"><a href="#HTTP-2兼容HTTP-1-1" class="headerlink" title="HTTP/2兼容HTTP/1.1"></a>HTTP/2兼容HTTP/1.1</h4><h4 id="改进方面"><a href="#改进方面" class="headerlink" title="改进方面"></a>改进方面</h4><ul><li>头部压缩：<ul><li><strong>HPACK</strong> 算法压缩头部数据</li></ul></li><li>二进制帧：<ul><li>将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率</li></ul></li><li>并发传输：<ul><li>通过 Stream，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量</li></ul></li><li>服务器主动推送资源：<ul><li>根据Stream的编号来实现推送，偶数号 Stream 发送资源给客户端。</li><li>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</li></ul></li></ul><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419115607305.png" alt="image-20230419115607305" style="zoom:80%;" /></p><ul><li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</li><li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li><li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</li></ul><p><strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419115832102.png" alt="image-20230419115832102"></p><h4 id="缺陷：-1"><a href="#缺陷：-1" class="headerlink" title="缺陷："></a>缺陷：</h4><ul><li><p>队头阻塞：</p><ul><li>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</li><li>比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。    <img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419120120966.png" alt="image-20230419120120966"></li></ul></li><li><p>TCP 与 TLS 的握手时延迟：</p><ul><li>TCP 三次握手和 TLS 四次握手（TLS 1.2）需要 3 个 RTT 的时延才能发出请求数据</li></ul></li><li>网络迁移需要重新连接：<ul><li>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的</li><li>如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手</li></ul></li></ul><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>针对HTTP/2中的问题，提出了HTTP/3来解决，主要就是使用了UDP协议，并且「应用层」实现了 <strong>QUIC 协议</strong>，让UDP协议变得可靠了</p><h4 id="QUIC协议的特点"><a href="#QUIC协议的特点" class="headerlink" title="QUIC协议的特点"></a>QUIC协议的特点</h4><ul><li>无队头阻塞：<ul><li>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream</li><li>QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</li><li>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li></ul></li><li><p>更快的连接建立：</p><ul><li>QUIC 协议握手，这个握手过程只需要 1 RTT</li><li><strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，</strong></li></ul></li><li><p>连接迁移：</p><ul><li>QUIC 协议通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</li><li>即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接</li></ul></li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/da970d16a205fb48d6a8bea14498814d.png" alt="四层网络协议"></p><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p><p>RPC 调用的协议目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</p><p>内部集群的微服务之间则采用 RPC 协议进行通讯。</p><p><strong>HTTP/2.0</strong> 在 <strong>HTTP/1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC</p><h4 id="HTTP和RPC的区别"><a href="#HTTP和RPC的区别" class="headerlink" title="HTTP和RPC的区别"></a>HTTP和RPC的区别</h4><ul><li><p>服务发现</p><ul><li><strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong>去解析得到它背后的 IP 地址，默认 80 端口</li><li><strong>RPC</strong> 的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，想要访问某个服务，就去这些中间服务去获得 IP 和端口信息</li></ul></li><li><p>底层连接形式：</p><ul><li><strong>HTTP/1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>Keep Alive</strong>）</li><li><strong>RPC</strong> 协议，除了长连接以外，建个<strong>连接池</strong>，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong></li><li><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池</strong>，比如 <strong>Go</strong> 就是这么干的。</li></ul></li><li>传输的内容：<ul><li>HTTP/1.1，传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>Json</strong> 来<strong>序列化</strong>结构体数据。比较冗余</li><li>RPC，因为它定制化程度更高，采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据</li></ul></li></ul><h3 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h3><p>场景需求：<strong>服务器主动发消息给客户端的场景</strong></p><p>三种方式：</p><h4 id="使用-HTTP-不断轮询："><a href="#使用-HTTP-不断轮询：" class="headerlink" title="使用 HTTP 不断轮询："></a>使用 HTTP 不断轮询：</h4><p><strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p><p>一种「<strong>伪</strong>」服务器推的形式，是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p><p>常见方式：<strong>扫码登录</strong>：<strong>前端</strong>不知道扫没扫，向<strong>后端</strong>服务器询问</p><p>但这样，会有两个比较明显的问题：</p><ul><li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li><li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li></ul><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><ul><li>先将HTTP 请求<strong>超时设置的很大</strong>，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></li><li>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/1058a96ba35215c0f30accc3ff5bb824.png" alt="图片"></p><h4 id="WebScoket-1"><a href="#WebScoket-1" class="headerlink" title="WebScoket"></a>WebScoket</h4><p><strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>，适用于客户端和服务器之间都要互相主动发大量数据的场景。</p><p>WebScoket建立流程：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/f4edd3018914fe6eb38fad6aa3fd2d65.png" alt="图片" style="zoom:80%;" /></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-IP</title>
      <link href="/mingyry/248e04fe.html"/>
      <url>/mingyry/248e04fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-IP"><a href="#计算机网络-IP" class="headerlink" title="计算机网络-IP"></a>计算机网络-IP</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p><h3 id="IP基本认识"><a href="#IP基本认识" class="headerlink" title="IP基本认识"></a>IP基本认识</h3><p>IP 在 TCP/IP 参考模型中处于第三层，也就是<strong>网络层</strong></p><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong></p><blockquote><p>网络层与数据链路层有什么关系呢？</p><p><strong>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p></blockquote><p>在网络中数据包传输中也是如此，<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><h3 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h3><p>IP 地址（IPv4 地址）由 <code>32</code> 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。</p><p>而人类为了方便记忆采用了<strong>点分十进制</strong>的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 <code>4</code> 组，每组以「<code>.</code>」隔开，再将每组转换成十进制。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/4.jpg" alt=""></p><p>IP 地址最大值也就是</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/5.jpg" alt=""></p><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/7.jpg" alt=""></p><blockquote><p>什么是 A、B、C 类地址？ </p></blockquote><p>A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/8.jpg" alt="img"></p><blockquote><p>A、B、C 分类地址最大主机个数是如何计算的呢？</p></blockquote><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul><p>最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/9.jpg" alt="img"></p><blockquote><p>广播地址用于什么？</p></blockquote><p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p><p>广播地址可以分为本地广播和直接广播两种。</p><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li></ul><blockquote><p>什么是 D、E 类地址？</p></blockquote><p>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/12.jpg" alt="img"></p><blockquote><p>多播地址用于什么？</p></blockquote><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p><p>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/13.jpg" alt="单播、广播、多播通信" style="zoom:80%;" /></p><p>多播使用的 D 类地址，其前四位是 <code>1110</code> 就表示是多播地址，而剩下的 28 位是多播的组编号。</p><p>从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：</p><ul><li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li><li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li><li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li></ul><blockquote><p>IP分类的优点</p></blockquote><p>不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/14.jpg" alt="IP 分类判断" style="zoom:67%;" /></p><blockquote><p>IP 分类的缺点</p></blockquote><p><em>缺点一</em></p><p><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</p><p><em>缺点二</em></p><p>A、B、C类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p><ul><li>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</li><li>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li></ul><p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决。</p><h4 id="CIDR无分类地址"><a href="#CIDR无分类地址" class="headerlink" title="CIDR无分类地址"></a>CIDR无分类地址</h4><p>32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><blockquote><p>怎么划分网络号和主机号的呢？</p></blockquote><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得 IP 地址更加具有灵活性。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/15.jpg" alt="img" style="zoom:67%;" /></p><p>还有另一种划分网络号与主机号形式，那就是<strong>子网掩码</strong>，掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p><p><strong>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/16.jpg" alt="img" style="zoom: 80%;" /></p><blockquote><p>为什么要分离网络号和主机号？</p></blockquote><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p><p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p><blockquote><p> 怎么进行子网划分？</p></blockquote><p>子网掩码还有一个作用，那就是<strong>划分子网</strong>。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。形式如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/18.jpg" alt="img"></p><ul><li>未做子网划分的 ip 地址：网络地址＋主机地址</li><li>做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421100351993.png" alt="image-20230421100351993"></p><h4 id="公有-IP-地址与私有-IP-地址"><a href="#公有-IP-地址与私有-IP-地址" class="headerlink" title="公有 IP 地址与私有 IP 地址"></a>公有 IP 地址与私有 IP 地址</h4><p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/22.jpg" alt="img"></p><h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。</p><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。</p><p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有<strong>相同网络地址</strong>的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/25.jpg" alt="IP 地址与路由控制"></p><ol><li>主机 A 要发送一个 IP 包，其源地址是 <code>10.1.1.30</code> 和目标地址是 <code>10.1.2.10</code>，由于没有在主机 A 的路由表找到与目标地址 <code>10.1.2.10</code> 相同的网络地址，于是包被转发到默认路由（路由器 <code>1</code> ）</li><li>路由器 <code>1</code> 收到 IP 包后，也在路由器 <code>1</code> 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 <code>10.1.0.2</code> 这台路由器 <code>2</code></li><li>路由器 <code>2</code> 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 <code>2</code> 的 <code>10.1.2.1</code> 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机</li></ol><h4 id="IP-分片与重组"><a href="#IP-分片与重组" class="headerlink" title="IP 分片与重组"></a>IP 分片与重组</h4><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，其中，我们最常见数据链路是以太网，它的 MTU 是 <code>1500</code> 字节。</p><p>当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。</p><p>分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，<strong>路由器是不会进行重组</strong>的。</p><p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 <code>MSS</code> 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p><h4 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h4><p>IPv6 的地址是 <code>128</code> 位的，这可分配的地址数量是大的惊人</p><p>但 IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相比于 IPv4 能带来更好的网络体验。</p><p>但是因为 IPv4 和 IPv6 不能相互兼容，所以不但要我们电脑、手机之类的设备支持，还需要网络运营商对现有的设备进行升级，所以这可能是 IPv6 普及率比较慢的一个原因。</p><blockquote><p>IPv6 地址的结构</p></blockquote><p>IPv6 的地址主要有以下类型地址：</p><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/29.jpg" alt="IPv6地址结构"></p><h4 id="IPv4-首部与-IPv6-首部"><a href="#IPv4-首部与-IPv6-首部" class="headerlink" title="IPv4 首部与 IPv6 首部"></a>IPv4 首部与 IPv6 首部</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/31.jpg" alt="IPv4 首部与 IPv6 首部的差异"></p><p>IPv6 相比 IPv4 的首部改进：</p><ul><li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li></ul><h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><ul><li>DNS 域名解析</li><li>ARP 与 RARP 协议</li><li>DHCP 动态获取 IP 地址</li><li>NAT 网络地址转换</li><li>ICMP 互联网控制报文协议</li><li>IGMP 因特网组管理协议</li></ul><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p><strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。</p><blockquote><p>域名的层级关系</p></blockquote><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/32.jpg" alt="DNS 树状结构" style="zoom:80%;" /></p><blockquote><p>域名解析的工作流程</p></blockquote><p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：</p><ol><li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。</p><p>然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。</p><p>ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。</p><ul><li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机</li></ul><blockquote><p>RARP 协议你知道是什么吗？</p></blockquote><p><strong>已知 MAC 地址求 IP 地址</strong>，将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p><p>需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/35.jpg" alt="RARP" style="zoom:80%;" /></p><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP 动态获取 IP 地址</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/36.jpg" alt="DHCP 工作流程" style="zoom: 80%;" /></p><p>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p><p>这 4 个步骤：</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li></ul><p>DHCP 交互中，<strong>全程都是使用 UDP 广播通信</strong>。</p><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址</li></ul><blockquote><p>用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p></blockquote><p>为了解决这一问题，就出现了 <strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/37.jpg" alt=" DHCP 中继代理" style="zoom:80%;" /></p><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li></ul><p>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。</p><p>于是，提出了一种<strong>网络地址转换 NAT</strong> 的方法，再次缓解了 IPv4 地址耗尽的问题。</p><p>NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/38.jpg" alt="NAT"></p><p>由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。</p><p>因此，可以把 IP 地址 + 端口号一起进行转换。</p><p>这样，就用一个全球 IP 地址就可以了，这种转换技术就叫<strong>网络地址与端口转换 NAPT。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/39.jpg" alt="NAPT"></p><p><strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p><blockquote><p>缺点</p></blockquote><p>由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><blockquote><p>如何解决 NAT 潜在的问题呢？</p></blockquote><p><em>第一种就是改用 IPv6</em></p><p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。</p><p><em>第二种 NAT 穿透技术</em></p><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><blockquote><p>ICMP 功能都有啥？</p></blockquote><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/4.jpg" alt="ICMP 目标不可达消息"></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p><blockquote><p>ICMP 类型</p></blockquote><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/41.jpg" alt="常见的 ICMP 类型" style="zoom:67%;" /></p><h4 id="IGMP-Internet组管理协议"><a href="#IGMP-Internet组管理协议" class="headerlink" title="IGMP(Internet组管理协议)"></a>IGMP(Internet组管理协议)</h4><p>在前面我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/42.jpg" alt="组播模型"></p><p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong></p><ul><li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h3><p>重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103655610.png" alt="image-20230421103655610"></p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103716689.png" alt="image-20230421103716689"></p><p> ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p>加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103805334.png" alt="image-20230421103805334"></p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103850220.png" alt="image-20230421103850220"></p><h3 id="断网了，还能-ping-通-127-0-0-1-吗？"><a href="#断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="断网了，还能 ping 通 127.0.0.1 吗？"></a>断网了，还能 ping 通 127.0.0.1 吗？</h3><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>执行 ping 0.0.0.0 ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP</title>
      <link href="/mingyry/96599ed7.html"/>
      <url>/mingyry/96599ed7.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-TCP"><a href="#计算机网络-TCP" class="headerlink" title="计算机网络-TCP"></a>计算机网络-TCP</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p><h3 id="TCP基础知识"><a href="#TCP基础知识" class="headerlink" title="TCP基础知识"></a>TCP基础知识</h3><h4 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230534096.png" alt="TCP 头格式"></p><ul><li>序列号：由计算机生成的随机数作为其初始值。<strong>用来解决网络包乱序问题。</strong></li><li>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li><li>控制位：<ul><li>ACK：1，确认应答有效</li><li>RST：1，出现异常需要强制断开连接</li><li>SYN：1，表示希望建立连接</li><li>FIN：1，表示希望断开连接</li></ul></li></ul><h4 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h4><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421110503510.png" alt="image-20230421110503510"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421110541154.png" alt="image-20230421110541154"></p><h4 id="TCP的概念"><a href="#TCP的概念" class="headerlink" title="TCP的概念"></a>TCP的概念</h4><p>TCP是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p><ul><li>面向连接：一对一连接，无法一对多</li><li>可靠的：保证报文一定能够到达接收端</li><li>字节流：TCP报文有序但是无边界</li></ul><h4 id="唯一确定TCP连接"><a href="#唯一确定TCP连接" class="headerlink" title="唯一确定TCP连接"></a>唯一确定TCP连接</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230433082.png" alt="TCP 四元组"></p><p>最大TCP连接数=客户端的IP数 * 客户端的端口数</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><div class="table-container"><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>需要建立连接</td><td>不需要建立连接</td></tr><tr><td>一对一</td><td>一对一、一对多、多对多</td></tr><tr><td>可靠交付数据</td><td>尽最大努力交付</td></tr><tr><td>有拥塞控制和流量控制</td><td>无</td></tr><tr><td>20字节首部开销（无选项字段下）</td><td>8字节，固定不变</td></tr><tr><td>流式传输，无边界</td><td>包传输，有边界</td></tr><tr><td>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片</td><td>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片</td></tr></tbody></table></div><h5 id="TCP-和-UDP-可以使用同一个端口"><a href="#TCP-和-UDP-可以使用同一个端口" class="headerlink" title="TCP 和 UDP 可以使用同一个端口"></a>TCP 和 UDP 可以使用同一个端口</h5><h4 id="TCP-面向字节流"><a href="#TCP-面向字节流" class="headerlink" title="TCP 面向字节流"></a>TCP 面向字节流</h4><blockquote><p>为什么 TCP 是面向字节流的协议？</p></blockquote><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p><blockquote><p>如何解决粘包？</p></blockquote><p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p><p>一般有三种方式分包的方式：</p><ul><li><p>固定长度的消息；</p></li><li><p>特殊字符作为边界；</p><ul><li><p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p></li><li><p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p></li></ul></li><li><p>自定义消息结构。</p><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p></li></ul><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419164333417.png" alt="image-20230419164333417" style="zoom:80%;" /></p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><p>Linux查看TCP状态：<code>netstat -napt</code></p><h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><p>三个方面分析三次握手的原因：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h5 id="原因1：避免历史连接"><a href="#原因1：避免历史连接" class="headerlink" title="原因1：避免历史连接"></a>原因1：避免历史连接</h5><p><strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230525514.png" alt="三次握手避免历史连接" style="zoom:80%;" /></p><blockquote><p>如果是两次握手，没办法阻止历史连接</p><p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p></blockquote><h5 id="原因2：同步双方初始序列号"><a href="#原因2：同步双方初始序列号" class="headerlink" title="原因2：同步双方初始序列号"></a>原因2：同步双方初始序列号</h5><p>序列号在 TCP 连接中占据着非常重要的作用</p><ul><li><p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，</p></li><li><p>当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，</p></li><li><p><strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步</strong></p></li></ul><blockquote><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p></blockquote><h5 id="原因3：避免资源浪费"><a href="#原因3：避免资源浪费" class="headerlink" title="原因3：避免资源浪费"></a>原因3：避免资源浪费</h5><ul><li>两次握手会大量建立多个冗余的无效连接，造成不必要的资源浪费</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230636571.png" alt="两次握手会造成资源浪费" style="zoom:67%;" /></p><h4 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419165608471.png" alt="image-20230419165608471"></p><p>过程如下：</p><ul><li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。</li><li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li><li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li></ul><p>每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收</p><h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230633447.png" alt="MTU 与 MSS"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>当TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p><p>当TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p><h4 id="握手丢失情况"><a href="#握手丢失情况" class="headerlink" title="握手丢失情况"></a>握手丢失情况</h4><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><p>客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p><ul><li>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li><li>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</li><li>达到最大重传次数（tcp_syn_retries ）后，等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p><ul><li>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li><li><strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><ul><li>当服务端重传 SYN-ACK 报文后，达到最大重传次数（ tcp_synack_retrie），于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接</li></ul><h3 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h3><h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><p>TCP 断开连接是通过<strong>四次挥手</strong>方式。</p><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:80%;" /></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code>（报文在网络中存在的最长时间） 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><h4 id="挥手丢失情况"><a href="#挥手丢失情况" class="headerlink" title="挥手丢失情况"></a>挥手丢失情况</h4><h5 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h5><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p><ul><li>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，<strong>重传 FIN 报文</strong>，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</li><li>当客户端达到最大重传次数后，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。</li></ul><h5 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h5><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p><ul><li><p>ACK 报文是不会重传的，如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文（第一次挥手），直到收到服务端的第二次挥手，或者达到最大的重传次数。</p></li><li><p>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</p></li></ul><blockquote><p>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态</p><ul><li>close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</li><li>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。形成死等。</li></ul></blockquote><h5 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h5><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。这时候服务器端还是可以发送数据的</p><p>服务端处于 <code>CLOSE_WAIT</code> 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 <code>LAST_ACK</code> 状态，等待客户端返回 ACK 来确认连接关闭。</p><ul><li>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</li><li>当服务端重传第三次挥手报文的次数达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 <code>FIN_WAIT_2</code> 状态是有时长限制的，如果<code>tcp_fin_timeout</code> 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接</li></ul><h5 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h5><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态.</p><p><strong>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</strong></p><ul><li>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会<strong>重发 FIN 报文</strong>，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</li><li>当服务端重传第三次挥手报文达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li><li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接.</li></ul><h4 id="TIME-WAIT的情况"><a href="#TIME-WAIT的情况" class="headerlink" title="TIME_WAIT的情况"></a>TIME_WAIT的情况</h4><h5 id="1-为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#1-为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="1. 为什么 TIME_WAIT 等待的时间是 2MSL？"></a>1. 为什么 TIME_WAIT 等待的时间是 2MSL？</h5><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，<strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><h5 id="2-为什么需要-TIME-WAIT-状态？"><a href="#2-为什么需要-TIME-WAIT-状态？" class="headerlink" title="2. 为什么需要 TIME_WAIT 状态？"></a>2. 为什么需要 TIME_WAIT 状态？</h5><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；<ul><li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文， 但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li><li>TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，保证所有的数据报文都会被丢弃</li></ul></li><li>保证「被动关闭连接」的一方，能被正确的关闭<ul><li>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></li></ul></li></ul><h5 id="3-TIME-WAIT-过多有什么危害？"><a href="#3-TIME-WAIT-过多有什么危害？" class="headerlink" title="3. TIME_WAIT 过多有什么危害？"></a>3. TIME_WAIT 过多有什么危害？</h5><ul><li>第一是，<strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是，<strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><h5 id="4-服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#4-服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="4. 服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>4. 服务器出现大量 TIME_WAIT 状态的原因有哪些？</h5><p>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><ul><li><p><em>第一个场景：HTTP 没有使用长连接</em></p><ul><li><strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</li></ul></li><li><p><em>第二个场景：HTTP 长连接超时</em></p><ul><li>HTTP 长连接具有超时时间，超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong></li><li>一般是网络问题导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时</li></ul></li><li><em>第三个场景：HTTP 长连接的请求数量达到上限</em><ul><li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接</li><li><strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接</li><li><strong>对于一些 QPS（每秒请求数） 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong></li><li>解决办法：调大 nginx 的 keepalive_requests 参数就行</li></ul></li></ul><h5 id="5-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#5-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="5. 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>5. 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom:80%;" /></p><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul><p>当收到合法SYN时，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p><p>当收到非法SYN时，<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p><h5 id="6-如果-TIME-WAIT-状态持续时间过短或者没有，会有什么问题？"><a href="#6-如果-TIME-WAIT-状态持续时间过短或者没有，会有什么问题？" class="headerlink" title="6.如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？"></a>6.如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</h5><p><code>tcp_tw_reuse</code> 的作用是让客户端快速复用处于 <code>TIME_WAIT</code> 状态的端口，相当于跳过了 <code>TIME_WAIT</code> 状态，这可能会出现这样的两个问题：</p><ul><li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li><li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li></ul><h4 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h4><p>如果「被动关闭方」<strong>没有调用 close 函数关闭连接</strong>，那么就<strong>无法发出 FIN 报文</strong>，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p><strong>通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>客户端出现故障指的是客户端的<strong>主机发生了宕机，或者断电的场景</strong>。发生这种情况的时候，如果服务端<strong>一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机</strong>这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p><ol><li><p>TCP存在<strong>保活机制</strong>（keepalive）：</p><ul><li><p>一个时间段内，如果没有任何连接相关的活动，TCP 保活机制每隔一个时间间隔，发送一个探测报文</p></li><li><p>该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应</p></li><li><p>则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></li></ul></li><li><p>心跳机制</p><ul><li>设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，</li><li>如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></li></ul></li></ol><h4 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><p><strong>总结：</strong></p><p>如果「<strong>客户端进程崩溃</strong>」，客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手。</p><p>但是，「<strong>客户端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看服务端会不会发送数据？</p><ul><li>如果服务端会发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 <code>tcp_retries2</code> 设置的值计算出一个阈值）后，会断开 TCP 连接；</li><li>如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？<ul><li>如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；</li><li>如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。</li></ul></li></ul><h4 id="拔掉网线后，-原本的-TCP-连接还存在吗"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗"></a>拔掉网线后， 原本的 TCP 连接还存在吗</h4><p>两种场景来讨论：</p><ol><li><h5 id="拔掉网线后，有数据传输："><a href="#拔掉网线后，有数据传输：" class="headerlink" title="拔掉网线后，有数据传输："></a>拔掉网线后，有数据传输：</h5><ul><li>如果服务端发送了数据报文，那么在<strong>服务端重传次数没有达到最大值之前</strong>，客户端就插回了网线，那么双方原本的 TCP 连接还是能<strong>正常存在</strong>，就好像什么事情都没有发生。</li><li>如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数<strong>达到了最大值时</strong>，服务端就会断开 TCP 连接。<strong>等到客户端插回网线后，向服务端发送了数据</strong>，因为服务端已经<strong>断开了与客户端相同四元组的 TCP 连接</strong>，所以就会回 <strong>RST</strong> 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</li></ul></li><li><h5 id="没有数据传输的情况："><a href="#没有数据传输的情况：" class="headerlink" title="没有数据传输的情况："></a>没有数据传输的情况：</h5><ul><li>如果双方都没有开启 TCP keepalive 机制，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li><li>开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li></ul></li></ol><h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><h4 id="三次握手的细节："><a href="#三次握手的细节：" class="headerlink" title="三次握手的细节："></a>三次握手的细节：</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419224841011.png" alt="image-20230419224841011" style="zoom:67%;" /></p><p><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h4 id="四次挥手细节："><a href="#四次挥手细节：" class="headerlink" title="四次挥手细节："></a>四次挥手细节：</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230538308.png" alt="客户端调用 close 过程"></p><ul><li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li><li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong></li><li>当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li></ul><h5 id="warning-没有-accept，也能建立-TCP-连接："><a href="#warning-没有-accept，也能建立-TCP-连接：" class="headerlink" title=":warning: 没有 accept，也能建立 TCP 连接："></a>:warning: 没有 accept，也能建立 TCP 连接：</h5><p><code>accpet</code> 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket</p><p>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开</p><h5 id="warning-没有-listen，也能建立-TCP-连接："><a href="#warning-没有-listen，也能建立-TCP-连接：" class="headerlink" title=":warning:没有 listen，也能建立 TCP 连接："></a>:warning:没有 listen，也能建立 TCP 连接：</h5><p>客户端是可以自己连自己形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h5 id="warning-没有-listen，发送数据："><a href="#warning-没有-listen，发送数据：" class="headerlink" title=":warning:没有 listen，发送数据："></a>:warning:没有 listen，发送数据：</h5><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><h3 id="TCP可靠性"><a href="#TCP可靠性" class="headerlink" title="TCP可靠性"></a>TCP可靠性</h3><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p>如果数据在传输过程中丢失了，TCP会用<strong>重传机制</strong>解决：</p><h5 id="1-超时重传"><a href="#1-超时重传" class="headerlink" title="1. 超时重传"></a>1. 超时重传</h5><p>设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8.jpg" alt="RTO 应略大于 RTT" style="zoom:50%;" /></p><p>TCP 的策略是<strong>超时间隔加倍。</strong></p><p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p><h5 id="2-快速重传"><a href="#2-快速重传" class="headerlink" title="2. 快速重传"></a>2. 快速重传</h5><p><strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/10.jpg" alt="快速重传机制" style="zoom: 80%;" /></p><p>存在的问题：<strong>重传的时候，是重传一个，还是重传所有。</strong></p><h5 id="3-SACK-选择性确认"><a href="#3-SACK-选择性确认" class="headerlink" title="3. SACK (选择性确认)"></a>3. SACK (<strong>选择性确认</strong>)</h5><p>在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><h5 id="4-Duplicate-SACK"><a href="#4-Duplicate-SACK" class="headerlink" title="4. Duplicate SACK"></a>4. Duplicate SACK</h5><p><strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><p>好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><h5 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h5><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg?" alt="img"></p><p><strong>可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</strong></p><p>SUN.DUA：指向发送窗口的第一个字节</p><h5 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口<img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20.jpg" alt="接收窗口"></h5><p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>发送窗口和接收窗口的被动态调节</p><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭</strong></p><blockquote><p>窗口关闭潜在的危险</p><p>当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/24.jpg" alt="窗口关闭潜在的危险"></p><p>TCP 解决窗口关闭时，潜在的死锁现象：</p><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p></blockquote><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>流量控制是避免「发送方」的数据填满「接收方」的缓存</p><p><strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><p>拥塞控制主要是四个算法：</p><h5 id="1-慢启动："><a href="#1-慢启动：" class="headerlink" title="1. 慢启动："></a>1. 慢启动：</h5><p>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。<strong>2的倍数增长</strong></p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」</li></ul><h5 id="2-拥塞避免算法："><a href="#2-拥塞避免算法：" class="headerlink" title="2. 拥塞避免算法："></a>2. 拥塞避免算法：</h5><p>每当收到一个 ACK 时，cwnd 增加 1/cwnd。<strong>线性增长</strong></p><p>触发了重传机制，也就进入了「拥塞发生算法」。</p><h5 id="3-拥塞发生："><a href="#3-拥塞发生：" class="headerlink" title="3. 拥塞发生："></a>3. 拥塞发生：</h5><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传<ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul></li><li>快速重传<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul></li></ul><h5 id="4-快速恢复："><a href="#4-快速恢复：" class="headerlink" title="4. 快速恢复："></a>4. 快速恢复：</h5><p>算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 <code>ssthresh</code> 的值，原因是该 ACK 确认了新的数据，说明从 <code>duplicated ACK</code> 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419231410090.png" alt="image-20230419231410090" style="zoom:80%;" /></p><h3 id="TCP半连接队列和全连接队列"><a href="#TCP半连接队列和全连接队列" class="headerlink" title="TCP半连接队列和全连接队列"></a>TCP半连接队列和全连接队列</h3><h4 id="什么是-TCP-半连接队列和全连接队列？"><a href="#什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="什么是 TCP 半连接队列和全连接队列？"></a>什么是 TCP 半连接队列和全连接队列？</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3.jpg" alt="半连接队列与全连接队列"></p><ul><li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK</li><li>客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li></ul><h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务</p><p><strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog：<ul><li>网卡接收数据包的速度大于内核处理的速度时</li></ul></li><li>增大 TCP 半连接队列：</li><li>开启 tcp_syncookies：<ul><li>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</li></ul></li><li>减少 SYN+ACK 重传次数：<ul><li>减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</li></ul></li></ul><h4 id="TCP-全连接队列溢出"><a href="#TCP-全连接队列溢出" class="headerlink" title="TCP 全连接队列溢出"></a>TCP 全连接队列溢出</h4><p>当服务端并发处理大量请求时，如果 <strong>TCP 全连接队列过小</strong>，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5/11.jpg" alt="全连接队列溢出"></p><blockquote><p>如何增大 TCP 全连接队列呢？</p></blockquote><p><strong>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong>。</p><ul><li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li><li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li></ul><h4 id="TCP-半连接队列溢出"><a href="#TCP-半连接队列溢出" class="headerlink" title="TCP 半连接队列溢出"></a>TCP 半连接队列溢出</h4><p><strong>增大半连接队列，</strong></p><ul><li><strong>不仅增大 tcp_max_syn_backlog 的值，</strong></li><li><strong>还要增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。</li></ul><h3 id="TCP协议的缺陷"><a href="#TCP协议的缺陷" class="headerlink" title="TCP协议的缺陷"></a>TCP协议的缺陷</h3><h4 id="升级-TCP-的工作很困难"><a href="#升级-TCP-的工作很困难" class="headerlink" title="升级 TCP 的工作很困难"></a>升级 TCP 的工作很困难</h4><p>很多 TCP 协议的新特性，都是需要客户端和服务端同时支持才能生效的，并且TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核。</p><h4 id="TCP-建立连接的延迟"><a href="#TCP-建立连接的延迟" class="headerlink" title="TCP 建立连接的延迟"></a>TCP 建立连接的延迟</h4><p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。</p><h4 id="TCP-存在队头阻塞问题"><a href="#TCP-存在队头阻塞问题" class="headerlink" title="TCP 存在队头阻塞问题"></a>TCP 存在队头阻塞问题</h4><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。</p><h4 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p><h3 id="TCP面试问题"><a href="#TCP面试问题" class="headerlink" title="TCP面试问题"></a>TCP面试问题</h3><h4 id="1-SYN-报文什么时候情况下会被丢弃？"><a href="#1-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="1. SYN 报文什么时候情况下会被丢弃？"></a>1. SYN 报文什么时候情况下会被丢弃？</h4><ul><li>半连接队列满了：<ul><li>如果开启syncookies功能，即使半连接队列满了，也不会丢弃syn包</li><li>增大半连接队列，<strong>增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong></li></ul></li><li>全连接队列满了：<ul><li>调大 accpet 队列的最大长度，调大的方式是通过<strong>调大 backlog 以及 somaxconn 参数。</strong></li></ul></li></ul><h4 id="2-已建立连接的TCP，收到SYN会发生什么？"><a href="#2-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="2. 已建立连接的TCP，收到SYN会发生什么？"></a>2. 已建立连接的TCP，收到SYN会发生什么？</h4><p>客户端再上线发起SYN握手，服务器怎么应对？</p><ul><li><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong><ul><li>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</li><li>旧连接里处于 Established 状态的服务端，如果服务端发送了数据包给客户端，客户的内核就会回 RST 报文，服务端收到后就会释放连接。</li><li>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li></ul></li><li><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong><br>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样<ul><li><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></li><li><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></li></ul></li></ul><h4 id="3-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.四次挥手中收到乱序的 FIN 包会如何处理？</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;" /></p><ul><li><p>在 <strong>FIN_WAIT_2</strong> 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「<strong>乱序队列</strong>」，并不会进入到 TIME_WAIT 状态。</p></li><li><p>等再次收到前面被网络延迟的数据包时，会<strong>判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据</strong>，如果能在乱序队列中找到与<strong>当前报文的序列号保持顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p></li></ul><h4 id="4-HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#4-HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="4. HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>4. HTTPS 中 TLS 和 TCP 能同时握手吗？</h4><p><em>HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLSv1.2 四次握手</em></p><p>可以同时握手，两个前提同时满足才可以：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><h5 id="TCP-Fast-Open"><a href="#TCP-Fast-Open" class="headerlink" title="TCP Fast Open"></a>TCP Fast Open</h5><p><strong>想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程</strong></p><p>如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。</p><h5 id="TLSv1-3"><a href="#TLSv1-3" class="headerlink" title="TLSv1.3"></a>TLSv1.3</h5><p><strong>会话恢复</strong>机制，在<strong>重连 TLSv1.3 只需要 0-RTT</strong>，</p><h5 id="TCP-Fast-Open-TLSv1-3"><a href="#TCP-Fast-Open-TLSv1-3" class="headerlink" title="TCP Fast Open + TLSv1.3"></a>TCP Fast Open + TLSv1.3</h5><p>在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，<strong>在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。</strong></p><p>如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。</p><p><strong>因此如果「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的。</strong></p><p><strong>如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成。</strong></p><h4 id="5-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？"><a href="#5-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？" class="headerlink" title="5. TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？"></a>5. TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？</h4><p><strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/52f35dcbe24a4ca7abb23f292837c707.png" alt="在这里插入图片描述"></p><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><blockquote><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></blockquote><h4 id="6-TCP-序列号和确认号是如何变化的？"><a href="#6-TCP-序列号和确认号是如何变化的？" class="headerlink" title="6. TCP 序列号和确认号是如何变化的？"></a>6. TCP 序列号和确认号是如何变化的？</h4><p><strong>发送的 TCP 报文：</strong></p><ul><li><strong>公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li><li><strong>公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-UDP</title>
      <link href="/mingyry/d8da6227.html"/>
      <url>/mingyry/d8da6227.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-UDP"><a href="#计算机网络-UDP" class="headerlink" title="计算机网络-UDP"></a>计算机网络-UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230439961.png" alt="UDP 头部格式"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC协议来实现UDP的可靠传输，已经应用在了HTTP/3上。</p><p>拿 HTTP/3 举例子，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/ab3283383013b707d1420b6b4cb8517c.png" alt="img"></p><h3 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a>QUIC 是如何实现可靠传输的？</h3><p>Packet Number 单调递增的两个好处：</p><ul><li><p>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。</p></li><li><p>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</p></li></ul><p>一个 Packet 报文中可以存放多个 QUIC Frame。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6a94d41ef3d14cb6b7846e73da6c3104.png" alt="img" style="zoom:80%;" /></p><p>每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。</p><p>我这里只举例 Stream 类型的 Frame 格式，Stream 可以认为就是一条 HTTP 请求，它长这样：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/536298d2c54a43b699026bffe0f85010.png" alt="img" style="zoom:80%;" /></p><ul><li>Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li><li>Offset 作用：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li><li>Length 作用：指明了 Frame 数据的长度。</li></ul><p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong></p><p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题</p><h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><blockquote><p>TCP 队头阻塞的问题，其实就是<strong>接收窗口的队头阻塞问题</strong>。</p><p><strong>TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留</strong>，</p></blockquote><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><ul><li><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li><li><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li></ul><h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><p>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法，相当于将 TCP 的拥塞控制算法照搬过来了。</p><h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/4cad213f5125432693e0e2a512c2d1a1.png" alt="img"></p><h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识</title>
      <link href="/mingyry/1ad06ab1.html"/>
      <url>/mingyry/1ad06ab1.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a>数据库基础知识</h1><h2 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h2><p>JDBC (Java Database Connectivity) 是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来范文数据库的标准Java类库，（java.sql, javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</p><h3 id="1-2-数据存储技术"><a href="#1-2-数据存储技术" class="headerlink" title="1.2 数据存储技术"></a>1.2 数据存储技术</h3><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO（Java Data Object）技术</li><li>第三方O/R工具，如Hibernate，Mybatis等</li></ul><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC</p><h2 id="2-获取数据库连接"><a href="#2-获取数据库连接" class="headerlink" title="2. 获取数据库连接"></a>2. 获取数据库连接</h2><h3 id="2-1-Driver-接口实现类"><a href="#2-1-Driver-接口实现类" class="headerlink" title="2.1 Driver 接口实现类"></a>2.1 Driver 接口实现类</h3><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动：com.mysql.jdbc.Driver</li></ul><h3 id="2-2-加载和注册JDBC驱动"><a href="#2-2-加载和注册JDBC驱动" class="headerlink" title="2.2 加载和注册JDBC驱动"></a>2.2 加载和注册JDBC驱动</h3><ul><li><p>加载驱动：加载JDBC驱动需要调用Class类的静态方法forName()，向其传递要加载的JDBC驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>;</li></ul></li><li><p>注册驱动：DriverManager类是驱动程序管理器类，负责管理驱动程序</p><ul><li>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</li><li>通常不用显式调用DriverManager类的registerDriver()方法来注册，因为Driver接口的驱动程序类都包含了静态代码块，会在创建时自动调用方法。</li></ul></li></ul><h3 id="2-3-URL"><a href="#2-3-URL" class="headerlink" title="2.3 URL"></a>2.3 URL</h3><ul><li>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。</li><li>JDBC URL 的标准由三部分组成，各部分间用冒号分割。<ul><li>jdbc：子协议：子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依照不同的子协议而变化，用子名称的目的是为了定位数据库提供足够多的信息。包含<strong>主机名</strong>（对应服务端的ip地址），端口号，数据库名</li></ul></li></ul><p>举例：<br><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135140020.png" alt="image-20230516135140020"></p><h3 id="2-4-用户名和密码"><a href="#2-4-用户名和密码" class="headerlink" title="2.4 用户名和密码"></a>2.4 用户名和密码</h3><ul><li>user，password 可以用“属性名=属性值”方式告诉数据库</li><li>可以调用DriverManager类的getConnection()方法建立到数据库的连接</li></ul><h3 id="2-5-连接方式"><a href="#2-5-连接方式" class="headerlink" title="2.5 连接方式"></a>2.5 连接方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">//1.加载配置文件 </span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);       <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); </span><br><span class="line">    pros.load(is); </span><br><span class="line">    <span class="comment">//2.读取配置信息 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>); </span><br><span class="line">    <span class="comment">//3.加载驱动 </span></span><br><span class="line">    Class.forName(driverClass); </span><br><span class="line">    <span class="comment">//4.获取连接 </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=root </span><br><span class="line">password=abc123 </span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test </span></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="3-使用PreparedStatement实现CRUD操作"><a href="#3-使用PreparedStatement实现CRUD操作" class="headerlink" title="3. 使用PreparedStatement实现CRUD操作"></a>3. 使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-Statement的弊端"><a href="#3-1-Statement的弊端" class="headerlink" title="3.1 Statement的弊端"></a>3.1 Statement的弊端</h3><ul><li>问题一：存在拼串操作、繁琐</li><li><p>问题二：存在SQL注入问题</p></li><li><p>SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令（如：SELECT user，password FROM user_table WHERE user=’a’ OR 1 = ‘AND password = ‘ OR ‘1’ = ‘1’）利用系统的SQL引擎完成恶意行为的做法。</p></li><li>使用PreparedStatement取代Statement可以防范SQL注入</li></ul><h3 id="3-2-PreparedStatement的使用"><a href="#3-2-PreparedStatement的使用" class="headerlink" title="3.2 PreparedStatement的使用"></a>3.2 PreparedStatement的使用</h3><h4 id="3-2-1-PreparedStatement介绍"><a href="#3-2-1-PreparedStatement介绍" class="headerlink" title="3.2.1 PreparedStatement介绍"></a>3.2.1 PreparedStatement介绍</h4><ul><li>通过调用Connection对象的preparedStatement(String sql) 方法获取PreparedStatement对象</li></ul><h4 id="3-2-2-PreparedStatement的优势"><a href="#3-2-2-PreparedStatement的优势" class="headerlink" title="3.2.2 PreparedStatement的优势"></a>3.2.2 PreparedStatement的优势</h4><ul><li>代码的可读性和可维护性</li><li><p>PreparedStatement能最大可能提高性能：</p><ul><li>DBServer会对预编译语句提供性能优化</li><li>（语法检查，语义检查，翻译成二进制命令，缓存）</li></ul></li><li><p>PreparedStatement可以防止SQL注入</p></li></ul><h3 id="3-3-实现看代码"><a href="#3-3-实现看代码" class="headerlink" title="3.3 实现看代码"></a>3.3 实现看代码</h3><h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><h4 id="处理查询结果"><a href="#处理查询结果" class="headerlink" title="处理查询结果"></a>处理查询结果</h4><h3 id="3-4-资源的释放"><a href="#3-4-资源的释放" class="headerlink" title="3.4 资源的释放"></a>3.4 资源的释放</h3><ul><li>释放ResultSet，Statement，Connection</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放</li><li>可以在finally中关闭，保证即使其他代码出现异常，资源也一定能被关闭。</li></ul><h2 id="4-操作大型字段BLOB"><a href="#4-操作大型字段BLOB" class="headerlink" title="4. 操作大型字段BLOB"></a>4. 操作大型字段BLOB</h2><ul><li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接。</li><li>MySQL的四种BLOB类型（除了在存储的最大信息量上不同外，他们是等同的）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135217940.png" alt="image-20230516135217940" style="zoom: 67%;" /></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：max_allowed_packet = 16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h2 id="5-批量插入"><a href="#5-批量插入" class="headerlink" title="5. 批量插入"></a>5. 批量插入</h2><p>当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句;</li><li>clearBatch()：清空缓存的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */</span><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection(); </span><br><span class="line">    <span class="comment">//1.设置为不自动提交数据 </span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>; </span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123; </span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i); </span><br><span class="line">                                    </span><br><span class="line">        <span class="comment">//1.“攒”sql </span></span><br><span class="line">        ps.addBatch();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//2.执行 </span></span><br><span class="line">            ps.executeBatch(); </span><br><span class="line">            <span class="comment">//3.清空 </span></span><br><span class="line">            ps.clearBatch(); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.提交数据 </span></span><br><span class="line">    conn.commit(); </span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">    JDBCUtils.closeResource(conn, ps); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-数据库事务"><a href="#6-数据库事务" class="headerlink" title="6. 数据库事务"></a>6. 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li>事务：一组逻辑操作单元，使数据从一种转台变换到另一种状态</li><li>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被<strong>提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所做的所有修改，整个事务<strong>回滚(rollback)</strong>到最初状态。</li><li>为了保证数据库中的数据的一致性，数据的操作应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚</p></li><li><p>数据什么时候意味着提交？</p><ul><li>当一个连接对象被创建时，默认情况下时自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p>JDBC程序中为了让多个SQL语句作为一个事务执行：</p><ul><li>调用Connection对象的setAutoCommit(false);以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用commit()；方法提交事务</li><li>在出现异常时，调用rollback()；方法回滚事务</li></ul><blockquote><p>若此时Connection没有被关闭，还可能被重复使用，则需要恢复其自动提交状态setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a><strong>6.3</strong> 事务的ACID属性</h3><ol><li><strong>原子性（Atomicity）</strong> </li></ol><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><ol><li><strong>一致性（Consistency）</strong> </li></ol><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p><ol><li><strong>隔离性（Isolation）</strong> </li></ol><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ol><li><strong>持久性（Durability）</strong> </li></ol><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><p><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p></li><li><p><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</p></li><li><p><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</p></li></ul><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高,数据一致性就越好,但并发性越弱。</strong></p><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135252180.png" alt="image-20230516135252180"></p><ul><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li><li><p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ</strong>。</p></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 <strong>在MySql中设置隔离级别</strong></h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation,表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation</span><br></pre></td></tr></table></figure></li><li><p>设置当前mySQL连接的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 授予通过网络方式登陆的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privialeges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;;</span><br><span class="line"># 给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="8-数据库连接池"><a href="#8-数据库连接池" class="headerlink" title="8. 数据库连接池"></a>8. 数据库连接池</h2><h3 id="8-1-数据库连接池的必要性"><a href="#8-1-数据库连接池的必要性" class="headerlink" title="8.1 数据库连接池的必要性"></a>8.1 数据库连接池的必要性</h3><ul><li>传统模式的缺陷<ul><li>需要数据库连接的时候，向数据库要求一个连接，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。</li><li>对于每一次数据库连接，使用完后都得断开。（思考：何为java的内存泄露？）</li><li>这种开发不能控制被创建的连接对象数。</li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li>为了解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕后再放回。</li><li>数据库连接池负责分配、管理和释放数据库连接，<strong>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong></li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数zhanyou 阿是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li><li><p>工作原理：<br><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135331428.png" alt="image-20230516135331428" style="zoom:67%;" /></p></li><li><p>数据库连接池技术的优点：</p><ol><li>资源重用<br>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li><li>更快的系统反应速度<br>数据库连接池在初始化过程中，已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</li><li>新的资源分配手段<br>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</li><li>统一的连接管理，避免数据库连接泄露<br>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li></ol></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC的数据库连接池使用 javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由服务器(Weblogic,WebSphere,Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong>是Apache提供的数据库连接池。tomcat服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong>是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。Hibernate官方推荐使用。</li><li><strong>Proxool</strong>是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li><strong>BoneCP</strong>是一个开源组织提供的数据库连接池，速度快。</li><li><strong>Druid</strong>是阿里提供的数据库连接池，据说集DBCP、C3P0、Proxool优点于一身的数据库连接池，但是速度不确定是否有BoneCP快。</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯是也经常把DataSource称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库的访问速度</strong>。</li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是数据库连接的工厂，因此 整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close()；但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123; </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection(); </span><br><span class="line">    <span class="keyword">return</span> conn; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span>  // 同时可以有5条sql语句在读取数据库</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-Druid-德鲁伊-数据库连接池"><a href="#8-3-2-Druid-德鲁伊-数据库连接池" class="headerlink" title="8.3.2 Druid(德鲁伊)数据库连接池"></a>8.3.2 Druid(德鲁伊)数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection; </span><br><span class="line"><span class="keyword">import</span> java.util.Properties; </span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource; </span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>)); </span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection(); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true </span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root </span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456 </span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10 // 初始化建立物理连接的个数。</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20 // 最大连接池的数量</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000 // 获取连接时最大等待时间</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall // 配置扩展插件，监控统计filters:start  日志filters:log4  防御sql注入filters:wall</span></span><br></pre></td></tr></table></figure><h2 id="9-Apache-DBUtils实现CRUD操作"><a href="#9-Apache-DBUtils实现CRUD操作" class="headerlink" title="9. Apache-DBUtils实现CRUD操作"></a>9. Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils-简介"><a href="#9-1-Apache-DBUtils-简介" class="headerlink" title="9.1 Apache-DBUtils 简介"></a>9.1 Apache-DBUtils 简介</h3><ul><li>commons-dbutils 是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</li><li>API介绍：<ul><li>org.apache.commons.dbutils.QueryRunner  提供数据库操作的一系列重载的update()和query()操作</li><li>org.apache.commons.dbutils.ResultSetHandler  用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现</li><li>工具类：org.apache.commons.dbutils.DbUtils</li></ul></li></ul><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWithTx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接的操作（ </span></span><br><span class="line">        <span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">        <span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid </span></span><br><span class="line">        <span class="comment">//2.对数据表进行一系列CRUD操作 </span></span><br><span class="line">        <span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0) </span></span><br><span class="line">        <span class="comment">//version2.0的增删改 public void update(Connection conn,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类 </span></span><br><span class="line">        <span class="comment">//提交数据 conn.commit(); </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//回滚数据 conn.rollback(); </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123; </span><br><span class="line">            e1.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="comment">//3.关闭连接等操作 </span></span><br><span class="line">        <span class="comment">//① JDBCUtils.closeResource(); </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
