<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo+butterfly博客搭建过程中的问题</title>
      <link href="/mingyry/8ff17a6a.html"/>
      <url>/mingyry/8ff17a6a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简单且功能强大的博客框架。支持Markdown（或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。</p><h2 id="每个目录下的网页设置"><a href="#每个目录下的网页设置" class="headerlink" title="每个目录下的网页设置"></a>每个目录下的网页设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm new page [对应目录的名字]</span><br></pre></td></tr></table></figure><p>会在对应的目录下生成一个index.md文件，但是要<strong>注意不要在archives目录下生成文件</strong>(看到其他博文中说的)</p><p>然后针对每个目录下的index.md，可以设置图片等等操作</p><p>这是index页面可以设置的属性</p><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title:   【必需】页面标题</span><br><span class="line">date:    【必需】页面创建日期</span><br><span class="line">updated:  【可选】页面更新日期</span><br><span class="line">type:【必需】标签、分类和友情链接三个页面需要配置(就是你设置的标签，分类，友链目录的名字)</span><br><span class="line">comments:【可选】显示页面评论模块(默认 true)</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords:【可选】页面关键字</span><br><span class="line">top_img:【可选】页面顶部图片</span><br><span class="line">mathjax:【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex:【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside:【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer:【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink:【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>留言板页面只需要写上内容，然后开启评论即可</p><p>音乐界面只需要关闭评论，并且将aplayer设置为true</p><h2 id="音乐盒的设置"><a href="#音乐盒的设置" class="headerlink" title="音乐盒的设置"></a>音乐盒的设置</h2><p>使用方法请参考插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> </p><p>本博客使用的是MeingJS，主要比较简单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">简单示例</span> <span class="string">(id,</span> <span class="string">server,</span> <span class="string">type)</span>  <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">%</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">进阶示例</span> <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">&quot;autoplay&quot;</span> <span class="string">&quot;mutex:false&quot;</span> <span class="string">&quot;listmaxheight:340px&quot;</span> <span class="string">&quot;preload:none&quot;</span> <span class="string">&quot;theme:#ad7a86&quot;</span><span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure><p>有关 <code>&#123;% meting %&#125;</code> 的选项列表如下:</p><div class="table-container"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div><p>如何获取网易云的id呢，需要上网页版的网易云音乐</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417110339346.png" alt="image-20230417110339346"></p><p>可以看到地址栏中出现了id和playlist，把这两个替换到对应的选项中即可</p><p>然后音乐平台选择netease</p><p>如果要是放单曲，则只需要song和对应的id即可</p><h3 id="全局aplayer的设置"><a href="#全局aplayer的设置" class="headerlink" title="全局aplayer的设置"></a>全局aplayer的设置</h3><p>如何添加全局 Aplayer 播放，请参考 <a href="https://butterfly.js.org/posts/507c070f/">这篇文章</a></p><h2 id="valine-评论设置"><a href="#valine-评论设置" class="headerlink" title="valine 评论设置"></a>valine 评论设置</h2><h3 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h3><p>如何快速开始Valiee 请参考 <a href="https://valine.js.org/quickstart.html">这篇文章</a></p><p>我们可以针对Valine进行魔改，增加他的一些功能</p><h3 id="魔改版"><a href="#魔改版" class="headerlink" title="魔改版"></a>魔改版</h3><p>首先要下载Valine.min.js文件  <a href="https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js">https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js</a></p><p>替换掉<code>themes/butterfly/source/js/Valine.min.js</code>原生 <code>js</code> 文件(如果当前目录没有就创建一个)，然后在<code>_config.butterfly.yml</code>中找到valine，将其设置为我们新生成的文件位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line"><span class="attr">option:</span></span><br><span class="line">        <span class="comment"># main_css:</span></span><br><span class="line">        <span class="comment"># main:</span></span><br><span class="line">        <span class="comment"># utils:</span></span><br><span class="line">        <span class="comment"># translate:</span></span><br><span class="line">        <span class="comment"># local_search:</span></span><br><span class="line">        <span class="comment"># algolia_js:</span></span><br><span class="line">        <span class="comment"># algolia_search:</span></span><br><span class="line">        <span class="comment"># instantsearch:</span></span><br><span class="line">        <span class="comment"># docsearch_js:</span></span><br><span class="line">        <span class="comment"># docsearch_css:</span></span><br><span class="line">        <span class="comment"># pjax:</span></span><br><span class="line">        <span class="comment"># gitalk:</span></span><br><span class="line">        <span class="comment"># gitalk_css:</span></span><br><span class="line">        <span class="comment"># blueimp_md5:</span></span><br><span class="line">    <span class="attr">valine:</span> <span class="string">/js/Valine.min.js</span></span><br></pre></td></tr></table></figure><p>然后我们寻找到<code>themes/butterfly/layout/includes/third-party/comments/</code>目录下的<code>valine.pug</code>文件  打开文件，寻找到下面的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadValine</span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initValine</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> valine = <span class="keyword">new</span> <span class="title class_">Valine</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">      <span class="attr">el</span>: <span class="string">&#x27;#vcomment&#x27;</span>,</span><br><span class="line">      <span class="attr">appId</span>: <span class="string">&#x27;#&#123;theme.valine.appId&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">appKey</span>: <span class="string">&#x27;#&#123;theme.valine.appKey&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">placeholder</span>: <span class="string">&#x27;#&#123;theme.valine.placeholder&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">avatar</span>: <span class="string">&#x27;#&#123;theme.valine.avatar&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">serverURLs</span>: <span class="string">&#x27;#&#123;theme.valine.serverURLs&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">emojiMaps</span>: !&#123;emojiMaps&#125;,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="string">&#x27;#&#123;theme.valine.pageSize&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">master</span>: <span class="string">&#x27;3451cd11a28a25de7691d4d856b929d3&#x27;</span>,   <span class="comment">//博主邮箱md5加密32位小写</span></span><br><span class="line">      <span class="attr">tagMeta</span>: [<span class="string">&quot;博主&quot;</span>, <span class="string">&quot;小伙伴&quot;</span>, <span class="string">&quot;访客&quot;</span>],     <span class="comment">//标识字段名</span></span><br><span class="line">      <span class="attr">friends</span>: [<span class="string">&#x27;b412f37e42d89e15c8aaf065934eb62e&#x27;</span>],  <span class="comment">//小伙伴邮箱Md5</span></span><br><span class="line">      <span class="attr">enableQQ</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">enableQQ</span>&#125;,</span><br><span class="line">      <span class="attr">lang</span>: <span class="string">&#x27;#&#123;theme.valine.lang&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>,</span><br><span class="line">      <span class="attr">visitor</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">visitor</span>&#125;</span><br><span class="line">    &#125;, !&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(theme.<span class="property">valine</span>.<span class="property">option</span>)&#125;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外打开<code>_config.butterfly.yml</code>, 寻找到对应的valine的目录位置，针对性的进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">JnVNUuheue1XlmfbyvgSY1Oe-gzGzoHsz</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">bVRKDRonMGGQ5U4Me0xmipvT</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="string">欢迎在博客中留言！</span></span><br><span class="line">                <span class="number">1</span><span class="string">.昵称输入QQ号可以自动识别头像和QQ邮箱</span></span><br><span class="line">                <span class="number">2</span><span class="string">.博客留言中昵称和email必须填写</span></span><br><span class="line">                <span class="number">3</span><span class="string">.欢迎留下网址方便互相回访</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">https://jnvnuuhe.lc-cn-n1-shared.com</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">nick</span>, <span class="string">mail</span>]</span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>在<code>valine.pug</code>中设置之后，你再去配置<code>_config.butterfly.yml</code> valine才会生效</p><p><strong>需要注意的是</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">placeholder:</span> <span class="string">字符串中如果包含\n则valine会启动失败，页面无评论栏</span></span><br></pre></td></tr></table></figure><p>网上推荐的解决办法是加入$&10; 这个转移符合，但是我加入也失败，希望有新的解决办法</p><h2 id="博客加载优化"><a href="#博客加载优化" class="headerlink" title="博客加载优化"></a>博客加载优化</h2><p>博客优化流程，参考<a href="https://akilar.top/posts/7c16c4bb/">https://akilar.top/posts/7c16c4bb/</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154926819.png" alt="image-20230417154926819"></p><h3 id="第一步-利用Picgo-腾讯云来作为图床"><a href="#第一步-利用Picgo-腾讯云来作为图床" class="headerlink" title="第一步 利用Picgo+腾讯云来作为图床"></a>第一步 利用Picgo+腾讯云来作为图床</h3><p>我选择利用<a href="https://cloud.tencent.com/">腾讯云</a>来存储图片</p><p>腾讯云的COS存储会给予用户免费6个月 60个G的存储空间，但是每次读写COS Bucket都会产生额外的花费，可以购买流量包，很便宜。</p><blockquote><p>注意，如果是通过外网服务器来访问腾讯云的Bucket (例如博客部署在Github pages上)，需要额外购买外网下行流量包</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153109286.png" alt="image-20230417153109286" style="zoom:80%;" /></p><p>最后就是这样都利用资源包抵扣了</p><h3 id="第二步-替换Butterfly主题中的-jsDelivr-CDN链接"><a href="#第二步-替换Butterfly主题中的-jsDelivr-CDN链接" class="headerlink" title="第二步 替换Butterfly主题中的 jsDelivr CDN链接"></a>第二步 替换Butterfly主题中的 jsDelivr CDN链接</h3><p>现在 JsDeliver已经不支持国内的访问了，很慢很慢，所以我们要替换他的链接</p><p>所以我们需要替换JsDeliver的地址，寻找到<code>themes/butterfly/_config.yml</code>中的CDN选项</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153943597.png" alt="image-20230417153943597"></p><p>首先可以将第三方js配置成unpkg，这个访问能快一些，此外，option能够自定义主题所用到的所有的cdn</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154040489.png" alt="image-20230417154040489"></p><p>cdn的选择可以参考以下博客</p><p> <a href="https://blog.zhheo.com/p/790087d9.html">Butterfly CDN链接更改指南，替换jsdelivr提升访问速度</a></p><p><a href="https://anzhiy.cn/posts/fe76.html">目前可用cdn整理</a></p><blockquote><p>注意，如果存在hexo-butterfly-tag-plugins 包，里面使用了mindmap这个挂件，他是使用 JsDeliver进行访问的，需要把这个包进行卸载，npm uninstall hexo-butterfly-tag-plugins</p><p>如果出现其他的不在主题下的js文件利用 JsDeliver 进行加速，都需要卸载其对应的包，能够加快访问速度</p></blockquote><h2 id="博客访问优化"><a href="#博客访问优化" class="headerlink" title="博客访问优化"></a>博客访问优化</h2><h3 id="第一步就是项目托管到自动部署平台上"><a href="#第一步就是项目托管到自动部署平台上" class="headerlink" title="第一步就是项目托管到自动部署平台上"></a>第一步就是项目托管到自动部署平台上</h3><p><a href="https://www.netlify.com/">Netlify</a>或者<a href="https://dash.zeabur.com/">Zeabur</a>（这个是国内开发的，但是服务器还是国外的）能够部分提高访问速度</p><h3 id="第二步：国内快速访问"><a href="#第二步：国内快速访问" class="headerlink" title="第二步：国内快速访问"></a>第二步：国内快速访问</h3><h4 id="第一种-利用Cloudflare进行反向代理"><a href="#第一种-利用Cloudflare进行反向代理" class="headerlink" title="第一种 利用Cloudflare进行反向代理"></a>第一种 利用Cloudflare进行反向代理</h4><p>CloudFlare 是通过反向代理（reverse proxy）提供网站加速服务，为站长解决了 JPG / JS / CSS 这些静态文件到 CDN 上的问题，并且通过它部署在全球各大洲的缓存结点服务器</p><h4 id="第二种-直接部署在云服务器上"><a href="#第二种-直接部署在云服务器上" class="headerlink" title="第二种 直接部署在云服务器上"></a>第二种 直接部署在云服务器上</h4><p>每个云服务器都可以部署hexo，但是都需要域名进行过备案，网上教程很多</p><h4 id="第三种-利用全站CDN进行访问加速"><a href="#第三种-利用全站CDN进行访问加速" class="headerlink" title="第三种 利用全站CDN进行访问加速"></a>第三种 利用全站CDN进行访问加速</h4><p>也需要域名进行备案，此外CDN服务一般都是付费使用的</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机</title>
      <link href="/mingyry/18701caa.html"/>
      <url>/mingyry/18701caa.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><strong>JDK1.8之后的运行区域:</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p>其中线程包含：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享的：</p><ul><li>堆</li><li>方法区（1.8之后移除了）换成了元空间</li><li>直接内存</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器，为了线程切换后能够恢复到正确的执行位置，因此每个线程都需要有一个独立的程序计数器</p><p>两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>多线程下，可以记录当前线程的执行位置，当线程发生切换后，能够返回到上次的运行位置</li></ul><p>注意：程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈也称为栈帧，生命周期和线程相同，每一个方法调用都会有一个对应的栈帧被压入，每一个方法调用结束后都有一个栈帧被弹出</p><p>虚拟机栈的组成如下图</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/stack-area.png" alt="Java 虚拟机栈"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>存放编译器可知的各种数据类型（boolean、int、char等）和对象引用（reference类型，它不同于对象本身（对象实际的所在内存空间在堆中），可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与次对象相关的位置）</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>用于存放方法执行过程中产生的中间计算结果。另外，临时变量也会放在操作数栈中</p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>将符号引用转换为调用方法的直接引用，当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。</p><h5 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h5><p>栈帧随着方法的调用而创建，随着方法结束而销毁。无论方法正常返回还是异常完成都算在方法的结束，因此方法必须有返回值</p><h5 id="栈中出现的错误"><a href="#栈中出现的错误" class="headerlink" title="栈中出现的错误"></a>栈中出现的错误</h5><ul><li><code>StackOverFlowError</code>：若栈的内存大小不允许动态扩展，函数调用陷入无限循环，导致栈中被压入太多的栈帧而占用太多的空间。当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，会抛出异常</li><li><code>OutOfMemoryError</code>：若栈的内存大小可以动态扩展，当虚拟机在动态扩展栈时候无法申请到足够的内存空间，则抛出异常</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为虚拟机所使用到的<strong>Native</strong>（非Java的方法，一般是c或者c++的方法）方法服务</p><p>栈内结构和虚拟机栈类似</p><p>也会出现<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>两个错误</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>此内存区域唯一目的是存放对象实例，几乎所有的对象实例以及数组都是在这里分配内存（例外：开启逃逸分析：某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存）</p><p>堆是垃圾收集器管理的主要区域，也被称为GC堆，垃圾收集的具体内容放到<a href="#Java 垃圾回收">Java垃圾回收</a></p><h5 id="堆中出现的错误"><a href="#堆中出现的错误" class="headerlink" title="堆中出现的错误"></a>堆中出现的错误</h5><p>最容易出现的是<code>OutOfMemoryError</code>错误，有几种表现形式：</p><ul><li><code>GC Overhead Limit Exceeded</code>：当JVM花费太多时间执行垃圾回收并且只能回收到很少的堆空间时，就会发生此错误</li><li><code>Java heap space</code>：创建对象时，堆内存中的空间不足以存放新创建的对象，会引发此错误</li></ul><h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p>JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的区域，目的为了避免字符串的重复创建</p><p>JDK1.7之前存放在永久代中，JDK1.7后字符串常量池和静态变量存放在Java堆中</p><p>转移的原因是因为永久代（方法区实现）的GC回收效率太低，放在堆中可以更高效的回收字符串内存</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>是JVM运行时数据区域的一块逻辑区域，是个个线程共享的内存区域</p><p>方法区存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></p><h5 id="方法区和永久代以及元空间的关系"><a href="#方法区和永久代以及元空间的关系" class="headerlink" title="方法区和永久代以及元空间的关系"></a>方法区和永久代以及元空间的关系</h5><p>类似于接口和类的关系</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p>为什么要将永久代替换为元空间：</p><ul><li>永久代有JVM设置的固定大小的上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，溢出的几率更小</li><li>元空间存放类的元数据，空间越大可加载的类越多</li><li>JDK8中虚拟机合并不需要额外设置永久代</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class文件中存放编译器生成的各种字面量和符合引用的常量池表</p><p>字面量就是源代码中的固定值的表示法包括整数、浮点数和字符串字面量。常见的符合引用（就是以一组符合来描述所引用的对象，并不一定是已经加载到虚拟机中的内容）包括类符合引用、字段符号引用、方法符合引用、接口方法符合引用</p><p>当常量池无法再申请到内存是会抛出<code>OutOfMemoryError</code>错误</p><blockquote><p>常量池中存放着引用，实际对象还是存放在Java 堆中</p><p>Animal an = new Animal()；</p><p>an：引用   Animal：对象</p><p>Java中都是通过引用来操作对象的</p></blockquote><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时的数据区的一部分，而是通过JNI的方式在本地内存上分配的，也会出现<code>OutOfMemoryError</code>错误</p><h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><h4 id="第一步：类加载检查"><a href="#第一步：类加载检查" class="headerlink" title="第一步：类加载检查"></a>第一步：类加载检查</h4><p>虚拟机遇到一条new指令时，先检查这个指令的参数能否在运行时常量池中定位到这个类的符号引用，检查这个符号引用所代表的类是否被加载过、解析和初始化过。</p><p>如果没有，则执行类加载的过程</p><h4 id="第二步：分配内存"><a href="#第二步：分配内存" class="headerlink" title="第二步：分配内存"></a>第二步：分配内存</h4><p>在类加载检查通过后，把堆中的一块确定大小的内存划分出来，分配给新生对象</p><p>分配方式：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整的情况下</li><li>原理：根据分界指针，分配内存</li><li>GC收集器：Serial，ParNew</li></ul></li><li><p>空闲列表：</p><ul><li>使用场合：堆内存不规整的情况下</li><li>原理：虚拟机维护一个列表，表中记录哪些内存块可用</li><li>GC收集器：CMS</li></ul></li><li><p>以上方式的使用取决于内存是否规整，就是GC收集器的算法使用的是<code>标记-清除</code>还是<code>标记-整理</code>，<code>标记-复制</code>内存也是规整的</p></li></ul><p>内存分配的并发解决：</p><ul><li>CAS+失败重试：乐观锁，保证分配方式的原子性</li><li>TLAB：预先为Eden区分配内存，首先在TLAB分配，分配需要空间大于TLAB则采取上述CAS进行内存分配</li></ul><h4 id="第三步：初始化零值"><a href="#第三步：初始化零值" class="headerlink" title="第三步：初始化零值"></a>第三步：初始化零值</h4><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头），保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用</p><h4 id="第四步：设置对象头"><a href="#第四步：设置对象头" class="headerlink" title="第四步：设置对象头"></a>第四步：设置对象头</h4><p>虚拟机需要对对象进行必要的设置，将对象信息存放在对象头中，例如信息有类的元数据信息、对象的哈希码、对象的GC分代年龄等信息</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6nlu6vcab7.png" alt="img"></p><h4 id="第五步：执行init方法"><a href="#第五步：执行init方法" class="headerlink" title="第五步：执行init方法"></a>第五步：执行init方法</h4><p>安装程序员的意愿进行初始化</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/f9c822367eaf5200222a8bf604629fa7.png" alt="img"></p><ol><li>对象头：存储自身运行时的数据<pre><code>            类型指针（确定该对象是哪个类的实例）</code></pre></li><li>实例数据：真正存储的有效信息</li><li>对齐填充：对象大小必须是8字节的整数倍</li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。访问方式有两种：</p><ul><li><p>使用句柄：reference中存储的是对象的句柄地址，句柄中包含对象实例数据与对象类型数据的具体地址信息，优点是稳定，对象被移动只需要改变句柄中的实例数据指针就可以</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p></li><li><p>直接引用：reference中存储的直接就是对象的地址，优点是访问速度快</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p></li></ul><h2 id="Java-垃圾回收"><a href="#Java-垃圾回收" class="headerlink" title="Java 垃圾回收"></a>Java 垃圾回收</h2><h3 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h3><p>JDK7及以前，堆内存分为三部分：</p><ul><li>新生代内存：Eden区和两个Survivor区S0和S1</li><li>老生代</li><li>永久代</li></ul><p>JDK8之后永久代被元空间所取代，元空间使用直接内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/hotspot-heap-structure.41533631.png" alt="hotspot-heap-structure"></p><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><ul><li>对象优先在Eden区分配</li><li>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，如果对象放不进去S0或者S1，那么就利用<strong>分配担保机制</strong>将新生代对象提前转移到老年代中</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代：<ul><li>虚拟机给每一个对象一个对象年龄（Age）计数器</li><li>现在Eden区中进行分配</li><li>经过一次Minor  GC 进入到Survivor，岁数赋值为1</li><li>每熬过一次Minor GC，Age+1</li><li>当年龄达到阈值，则放入老年代（当累积的某个年龄超过了Survivor区的50%时，取这个值和最大阈值中的小值作为阈值）</li></ul></li><li>内存一般分配情况：<ul><li>新生代（1/3）：Eden：S0：S1=8：1：1</li><li>老年代（2/3）</li></ul></li></ul><h4 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h4><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集（Partial GC）：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代垃圾进行收集（eden区满时）</li><li>老年代收集（MajorGC / Old GC）：只对老年代进行垃圾收集（）</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li></ul><p>整堆收集（Full GC）：收集是整个Java堆和方法区（新生代晋升大小超过老年代的空间大小会在永久代分配空间不足，或者系统调用垃圾回收算法）</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>为了确保在Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间：只要老年代的来纳许空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC</p><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加1</li><li>当引用失效，计数器就减1</li><li>任何时候计数器为0的对象就是不可能再被使用的</li></ul><p>弊端：难以解决对象之间互相循环引用的问题</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Gc Roots 的对象为起点，向下搜索，当一个对象到 GC Roots没有任何的引用链相连的话，则证明此对象时不可用的需要被回收</p><p>作为GC Roots的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h5 id="对象可以回收就一定会回收么？"><a href="#对象可以回收就一定会回收么？" class="headerlink" title="对象可以回收就一定会回收么？"></a>对象可以回收就一定会回收么？</h5><p>回收之前需要经历两次标记，第一次时可达性分析法中不可达的对象进行标记，被判定的对象放在一个队列里进行二次标记，如果这时候还没有与其他对象建立关联，那么就被回收</p><h4 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h4><ul><li>强引用：最普遍的引用，垃圾回收器不会回收它。当内存空间不足时，只会抛出<code>OutOfMemoryError</code>错误</li><li>软引用：内存空间足够时不会回收，当内存空间不足时，会回收这些对象的内存</li><li>弱引用：一旦发现弱引用对象，不管当前内存空间足够与否，都会回收它的内存。但是垃圾收集器的线程优先级是较低的，不一定会执行的很早</li><li>虚引用：虚引用必须和引用队列使用</li></ul><h4 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h4><p>字符串常量：没有任何一个String对象引用该字符串常量时</p><h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><ul><li>该类的所有实例对象都被回收，堆中不存在该类的实例对象</li><li>加载该类的类加载器也被回收</li><li>该类对应的类对象没有再其他地方被引用，也没有再审核地方通过反射访问该类的方法</li></ul><p>这时候可以回收，不一定会回收</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>先标记出不需要回收的对象，再标记完成后统一回收掉没有被标记的对象。最基础的收集算法</p><p>问题：</p><p>​    1. 效率不足</p><pre><code>2. 空间问题（会出现大量不连续的碎片）</code></pre><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230418145507754.png" alt="image-20230418145507754"></p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中的一块。当把这一块内存使用完后，将还存活的对象复制到另一块去</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/90984624.e8c186ae.png" alt="复制算法"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代特点提出的一种标记算法，标记过程和标记-清除算法一样，但是后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/94057049.22c58294.png" alt="标记-整理算法 "></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，就是根据堆中的各个年代类选择合适的垃圾收集算法</p><h5 id="HotSpot为什么要分为新生代和老年代"><a href="#HotSpot为什么要分为新生代和老年代" class="headerlink" title="HotSpot为什么要分为新生代和老年代"></a>HotSpot为什么要分为新生代和老年代</h5><p>因为有大量对象会被直接收集，放在新生代中使用合适的垃圾收集算法可以付出少量的成本，对于存活几率比较高的对象放到老年代中，使用合适的垃圾收集算法进行处理</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现，更具具体的应用场景选择适合自己的垃圾收集器</p><h4 id="Serial（串行）-收集器"><a href="#Serial（串行）-收集器" class="headerlink" title="Serial（串行） 收集器"></a>Serial（串行） 收集器</h4><p>最基本的垃圾收集器，单线程，重点是在垃圾收集工作时需要暂停其他所有的工作线程</p><p>新生代：标记-复制，老年代：标记-整理</p><p>简单高效</p><h4 id="ParNew-收集器（Serial的多线程版本）"><a href="#ParNew-收集器（Serial的多线程版本）" class="headerlink" title="ParNew 收集器（Serial的多线程版本）"></a>ParNew 收集器（Serial的多线程版本）</h4><p>新生代：标记-复制，老年代：标记-整理</p><p>许多Server模式下的虚拟机的首要选择</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>关注点在吞吐量（高效率的利用CPU）。吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</p><p>新生代：标记-复制，老年代：标记-整理</p><p>JDK1.8的默认收集器，默认使用Parallel Scavenge + Parallel Old</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial 收集器的老年代版本，是一个单线程的收集器，和Parallel Scavenge收集器搭配使用</p><h4 id="Parallel-Olde-收集器"><a href="#Parallel-Olde-收集器" class="headerlink" title="Parallel Olde 收集器"></a>Parallel Olde 收集器</h4><p>Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。注重用户体验的应用上使用。</p><p>第一款真正意义上的并发收集器，让垃圾收集线程和用户线程同时工作</p><p>四个步骤：</p><ul><li>初始标记：暂停所有线程，并记录下与root直接相连的对象，执行速度较快</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。此外会跟踪记录发生引用更新的地方</li><li>重新标记：为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，停顿时间一般比初始标记时间长，比并发标记时间短</li><li>并发清除：开启用户线程，同时GC线程开始堆未标记的区域做清扫</li></ul><p>优点：并发回收，低停顿</p><p>缺点：对CPU资源敏感，无法处理浮动垃圾（标记之后，连接该对象的可达性链路断开，该对象称为浮动垃圾），使用的回收算法是标记-清除，会产生大量空间碎片</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征</p><ul><li>并行和并发：能够充分利用CPU和多核环境的硬件优势</li><li>分代收集：保留了分代的概念</li><li>空间整合：整体来看基于标记-整理算法，局部基于标记-复制</li><li>可预测的停顿：一大优势，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ul><p>收集步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region</p><h2 id="Java-类加载"><a href="#Java-类加载" class="headerlink" title="Java 类加载"></a>Java 类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>整个生命周期可以概括为7个阶段：加载、验证、准备、解析、初始化、使用和卸载。</p><p>顺序如下图所示：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:50%;" /></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载Class类型的文件主要分为三步：加载-&gt;连接-&gt;初始化，连接过程又分为三步：验证-&gt;准备-&gt;解析。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口（通过<a href="# 类加载器">类加载器和双亲委派模型</a>）</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保Class文件的字节流中的信息符合《Java虚拟机规范》的全部约束要求</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class文件格式检查）：常量池中的常量是否有不被支持的类型</li><li>元数据验证（字节码语义检查）：该类是否有父类，该类是否继承了不允许继承的类</li><li>字节码验证（程序语义检查）：函数的参数类型是否正确，对象的类型转换是否合理</li><li>符号引用验证（类的正确性检查）：类使用的字段是否存在，是否有合适的访问权限</li></ol><p>该阶段抛出的异常有：</p><ul><li><code>java.lang.IllegalAccessError</code>：访问或修改无权限的字段或者调用无权限访问的方法</li><li><code>java.lang.NoSuchFieldError</code>：访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><p><code>java.lang.NoSuchMethodError</code>：访问一个指定的方法，而该方法不存在时，抛出该异常。</p></li><li><p>……</p></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>是正式为类变量分配内存并设置类变量初始值的阶段</p><ol><li>进行内存分配的只有类变量（被<code>static</code>修饰的变量）</li><li>静态变量放在堆中而不是在永久代中</li><li>初始值一般是该数据类型下默认的零值，如果加上<code>final</code>修饰的话，在准备阶段就会被赋值成想要的值</li></ol><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>是虚拟机将常量池内的符号引用替换为直接引用的过程，就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行初始化方法<code>&lt;clinit&gt;()</code>的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码</p><p>类的初始化方法是多线程安全的，只有以下六种情况会触发类的初始化：</p><ol><li>当遇到<code>new</code>，<code>getstatic</code>，<code>putstatic</code>或者<code>invokestatic</code>这4条字节码指令时。</li><li>使用<code>java.lang.reflect</code>包中的方法对垒进行反射调用时，如<code>`Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code>等</li><li>初始化一个类， 要先初始化其父类</li><li>虚拟机启动时，需要先初始化一个要执行的主类，具有main方法的那个类</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li><li>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在JVM的生命周期中，被jvm自带的类加载器加载的类是不会被卸载的，只有我们自己定义的类加载器加载的类是可能被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载步骤</li><li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code></li><li>数组类不是通过类加载器创建的，是由JVM直接生成的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">classClass&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    privatefinalClassLoader classLoader;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载器的主要作用就是加载Java类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）Class对象一般在元空间中</p><h4 id="类加载器的加载规则"><a href="#类加载器的加载规则" class="headerlink" title="类加载器的加载规则"></a>类加载器的加载规则</h4><p>JVM不会一次性加载所有的类，而是根据需要去动态加载。在具体用到的时候才会去加载</p><h4 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h4><ol><li><code>BootstraoClassLoader</code>（启动类加载器）：最顶层的加载器，由C++实现，没有父级，主要用来加载JDK内部和核心类库</li><li><code>ExensionClassLoader</code>（扩展类加载器）：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量所指定的路径下的所有类</li><li><code>AppClassLoader</code>（应用程序类加载器）：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li></ol><blockquote><p>:rainbow: 拓展一下：</p><ul><li><strong><code>rt.jar</code></strong> ： rt 代表“RunTime”，<code>rt.jar</code>是Java基础类库，包含Java doc里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载</li></ul></blockquote><ol><li>用户自定义的类加载器：</li></ol><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><ul><li>加载器类使用委托模型来搜索类和资源</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器</li><li>加载器实例用在试图亲自查找类或者资源前，将搜索类或者资源的任务委派给其父类的加载器</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 80%;" /></p><p>面向对象编程中，有一条经典的设计原则：组合优于继承，多用组合少用继承</p><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接/链接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ul><li>在类加载时，先判断当前类是否被加载过，已经被加载的类会直接返回，否则尝试加载</li><li>类加载器在进行类加载的时候，先不尝试加载该类，而是把请求委派给父类加载器来完成（调用父类的<code>loadClass()</code>方法），最终所有的请求都会会回到顶层的启动类加载器中</li><li>只有当父加载器无法加载该类时（它的搜索范围中没有找到所需的类），子加载器使用<code>findClass()</code>方法来加载类</li></ul><h5 id="如何判断两个java类是否相同"><a href="#如何判断两个java类是否相同" class="headerlink" title="如何判断两个java类是否相同"></a>如何判断两个java类是否相同</h5><ul><li>要看类的全类名是否相同</li><li>要看加载此类的类加载器是否一样</li></ul><h5 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h5><p>保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不会被篡改。不会出现我自定义的类加载器来加载<code>java.lang.Object</code>类</p><h5 id="打破双亲委派模型"><a href="#打破双亲委派模型" class="headerlink" title="打破双亲委派模型"></a>打破双亲委派模型</h5><p>自定义加载器需要继承<code>ClassLoader</code>。如果不想打破双亲委派模型，就重写<code>ClassLoader</code>中的<code>findClass()</code>方法，如果想要打破双亲委派模型，需要重写<code>loadClass()</code>方法</p><p>打破双亲委派模型的场景：Tomcat场景,(保证在一个tomcat上运行的多个web应用程序之间存在相同类（全限定类名一样）但具体操作不一样的类 不冲突；)，  JNDI服务（java Naming and Directory Interface，java命名和目录接口），Spring（Spring对用户程序进行组织和管理，应用程序一般存放在WEB-INF目录下，由WebAppClassLoader类加载器加载；<br>而Spring由Common类加载器或Shared类加载器加载；Spring如何加载WEB-INF下的应用程序呢？使用线程上下文类加载器。）</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>参考：<a href="https://blog.csdn.net/LXMXHJ/article/details/124876571">https://blog.csdn.net/LXMXHJ/article/details/124876571</a></p><h3 id="JVM监控的工具（JVM的相关指令）"><a href="#JVM监控的工具（JVM的相关指令）" class="headerlink" title="JVM监控的工具（JVM的相关指令）"></a>JVM监控的工具（JVM的相关指令）</h3><div class="table-container"><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps【选项 】 [主机ip或域名]</td><td>输出JVM中运行的进程状态信息</td></tr><tr><td>jstack 【选项】 【进程ID】</td><td>查看某个Java进程内的线程堆栈信息</td></tr><tr><td>jmap【选项】【进程ID】</td><td>查看堆内存的使用状况并且生成堆转储快照</td></tr><tr><td>jhat</td><td>用于分析heapdump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td>jstat 【选项】 【进程ID】 [间隔时间 ] [查询次数]</td><td>用于查看各个功能和区域的统计信息（如：类加载、编译相关信息统计，各个内存区域GC概况和统计）主要内存信息统计</td></tr><tr><td>jinfo 【选项】【进程ID】</td><td>查看和调整JVM启动和运行参数。</td></tr><tr><td>jconsole</td><td>javaGUI监控工具，可以以图形化的形式显示各种数据，并可以通过远程连接监控远程的服务器的jvm进程</td></tr><tr><td>Linux下的top</td><td>查看当前所有进程的使用情况，CPU占有率，内存使用情况，服务器负载状态等参数</td></tr><tr><td>Visual VM:多合一故障处理工具</td><td>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></td></tr></tbody></table></div><ul><li><strong><code>jps</code></strong>：类似于ps命令，-l（输出主类的全名，如果是jar包，输出Jar路径），-v（输出虚拟机进程启动时JVM参数），-m（输出传递给Java进程main()函数的参数）</li><li><p><strong>jstat -gc PID</strong>：查看即时内存使用情况、垃圾回收统计信息，用于分析GC情况</p></li><li><p><strong>heapdump</strong>：</p><ul><li><p>概念：<br>heapdump，又被称为堆转存文件，是一个java进程在某个时间点上的内存快照。</p></li><li><p>解释：<br>具有很多种类型；<br>总体上heapdump在触发快照的时候都保存了java对象和类的信息。<br>通常在写heapdump文件前会触发一次FullGC，则该文件保存的都是FullGC后留下来的对象信息。</p><p>| 信息                      | 说明                                           |<br>| ————————————- | ——————————————————————— |<br>| 对象信息                  | 类、成员变量、直接量以及引用值                 |<br>| 类信息                    | 类加载器、名称、超类、静态成员                 |<br>| Garbage Collections Roots | JVM可达的对象                                  |<br>| 线程栈以及本地变量        | 获取快照时的线程栈信息，以及局部变量的详细信息 |</p></li></ul></li><li><p><strong><code>jhat</code></strong>: 访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p></li></ul><h3 id="利用监控工具调优"><a href="#利用监控工具调优" class="headerlink" title="利用监控工具调优"></a>利用监控工具调优</h3><p>监控工具作用：</p><ul><li><p>堆信息查看<br>查看堆空间大小分配（年轻代、老年代、持久态分配）；<br>提供即时的垃圾回收功能；<br>垃圾监控；<br>查看堆内类、对象信息查看（类型、数量等）；<br>对象引用情况查看；<br><strong>可解决：年轻代、老年代大小划分是否合理、内存泄露、垃圾回收算法设置是否合理。</strong></p></li><li><p>线程监控<br>线程信息监控：系统线程数量；<br>线程状态监控：各线程都处于什么状态下；<br>Dump线程详细情况：线程内部运行情况；<br>死锁检查；</p></li><li>热点分析<br>CPU热点：检查系统哪方面占用CPU时间较长；<br>内存热点：检查哪些对象在系统中数量最大；<br>明确热点问题，有针对性的进行系统的瓶颈查找和系统优化。</li><li>快照<br>快照是系统运行到某一时刻的一个定格。<br>依赖快照可以根据系统运行时刻、对象（或类、线程）的不同，快速找到问题。</li><li>内存泄漏<br>内存泄漏一般可以理解为系统资源（堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收，从而导致新的资源分配请求无法完成，引起系统错误。</li></ul><h3 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h3><h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><ol><li><p>显式指定对内存<code>–Xms</code>和<code>-Xmx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure></li></ol><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><ol><li><p>显式新生代内存大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br><span class="line">或者</span><br><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure></li></ol><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况</p></blockquote><ol><li><p>显式指定各比值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</span><br><span class="line">例如：4，表示新生代：老年代=1：4</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio（幸存代）--- 设置两个 Survivor 区和 eden 的比值</span><br><span class="line">例如：8，表示两个Survivor:Eden=2：8</span><br></pre></td></tr></table></figure></li><li><p>显式指定永久代/元空间的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）</p></li><li><p>Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p></li></ul><h4 id="垃圾回收器相关"><a href="#垃圾回收器相关" class="headerlink" title="垃圾回收器相关"></a>垃圾回收器相关</h4><h5 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h5><div class="table-container"><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>-XX：UseSerialGC</td><td>设置串行收集器</td></tr><tr><td>-XX：UseParallelGC</td><td>设置<strong>并行</strong>收集器</td></tr><tr><td>-XX：UseParallelOldGC</td><td>设置并行老年代收集器</td></tr><tr><td>-XX：UseConcMarkSweepGC</td><td>设置<strong>CMS并发</strong>收集器</td></tr></tbody></table></div><h5 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：PrintGC</td><td>开启打印gc信息</td></tr><tr><td>-XX：PrintGCDetails</td><td>打印gc详细信息</td></tr><tr><td>-XX：PrintGCTimeStamps</td><td>打印gc所经历时间的详细信息</td></tr><tr><td>-Xloggc：filename</td><td>将gc日志输出到文件</td></tr></tbody></table></div><h5 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：ParallelGCThreads = n</td><td>设置并行收集器收集时使用的CPU数</td></tr><tr><td>-XX：MaxGCPauseMillis = n</td><td>设置并行收集最大暂停时间</td></tr><tr><td>-XX：GCTimeRatio = n</td><td>设置垃圾回收时间占程序运行时间的百分比</td></tr></tbody></table></div><h5 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：CMSIncrementalMode</td><td>设置为增量模式。适用于单CPU情况</td></tr><tr><td>-XX：ParallelGCThreads = n</td><td>设置并发收集器年轻代收集方式为并发收集时，使用的CPU数。并发收集线程数</td></tr></tbody></table></div><h5 id="IDEA中的JVM的配置："><a href="#IDEA中的JVM的配置：" class="headerlink" title="IDEA中的JVM的配置："></a>IDEA中的JVM的配置：</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8d350bc15c0e47059d858f27621d11ea.png" alt="在这里插入图片描述"></p><h3 id="编译器与运行期的优化"><a href="#编译器与运行期的优化" class="headerlink" title="编译器与运行期的优化"></a>编译器与运行期的优化</h3><h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4><ul><li>java语言的编译期就是一段不确定的操作过程：<br>它可能指前端编译器把java文件转变成class字节码文件的过程，也可以指虚拟机后端运行期间编译器（JIT，Just In Time Compiler）把字节码变成机器码的过程。</li><li>它可以分为三类编译过程：<br>前端编译：把.java文件转变为.class文件<br>后端编译：把字节码（.class文件）转变为机器码<br>静态提前编译：直接把.java文件编译成本地机器代码</li></ul><h5 id="编译器的编译过程——前端编译（java→class）"><a href="#编译器的编译过程——前端编译（java→class）" class="headerlink" title="编译器的编译过程——前端编译（java→class）"></a>编译器的编译过程——前端编译（java→class）</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/9d9bc90f84514762a2a8da30b11bb2a9.png" alt="在这里插入图片描述"></p><p><strong>字节码生成</strong><br>javac编译的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外进行少量的代码添加和转换工作。</p><h4 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h4><p>java最初是通过解释器（interpreter）进行解释执行的。当虚拟机发现某方法或代码块的运行很频繁时，会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，运行时，虚拟机会将这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）</p><p><strong>解释器与即时编译器</strong> 区别</p><div class="table-container"><table><thead><tr><th>区别</th><th>解释器</th><th>即时编译器</th></tr></thead><tbody><tr><td>作用</td><td>将字节码解释为机器码，下次遇到相同的字节码，还会进行重复解释</td><td>字节码解释为机器码，存入Code Cache，下次遇到相同的字节码，不再编译直接解释</td></tr><tr><td>特点</td><td>将字节码解释为所有平台通用的机器码</td><td>根据平台类型，生成平台特定的机器码</td></tr></tbody></table></div><h5 id="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"><a href="#为何HotSpot虚拟机要使用解释器与编译器并存的框架？" class="headerlink" title="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"></a>为何HotSpot虚拟机要使用解释器与编译器并存的框架？</h5><p>HotSpot采用解释器与编译器并存的框架，是因为两者皆有优势。</p><ul><li>解释器：<br>逐条转换，保留源代码；<br>程序员可以快速启动和执行，消耗内存小；（成本低，后期效率低）</li><li>编译器：<br>一次性转换，不保留源代码；<br>随着代码频繁执行会将代码编译成本地机器码；（成本高、后期效率高）</li><li>解释器与编译器配合使用：<br>当程序需要迅速启动和执行的时候，解释器可以率先发挥作用，省去编译时间，立即执行；<br>程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以提高执行效率；<br>当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之可以使用编译执行提升效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/mingyry/4a17b156.html"/>
      <url>/mingyry/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/mingyry/c24675b4.html"/>
      <url>/mingyry/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Select语句的执行流程"><a href="#Select语句的执行流程" class="headerlink" title="Select语句的执行流程"></a>Select语句的执行流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:80%;" /></p><ul><li>Server 层负责建立连接、分析和执行SQL语句</li><li>存储引擎层负责数据的存储和提取</li></ul><h4 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h4><p>进行身份认证和权限认证：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="第二步：查询缓存（8-0版本后移除）"><a href="#第二步：查询缓存（8-0版本后移除）" class="headerlink" title="第二步：查询缓存（8.0版本后移除）"></a>第二步：查询缓存（8.0版本后移除）</h4><p>执行查询语句时会先去查询缓存（Query Cache）里查找缓存，缓存是以key-value的形式存在的，如果查询到缓存，直接返回value给客户端</p><h4 id="第三步：解析器"><a href="#第三步：解析器" class="headerlink" title="第三步：解析器"></a>第三步：解析器</h4><ul><li>词法分析。根据输入的字符串构建SQL语法树</li><li>语法分析。根据语法规则，判断输入的SQL语句是否满足语法条件</li></ul><blockquote><p>这步不会去检查表是否存在或者表中的字段是否存在</p></blockquote><h4 id="第四步：执行SQL语句"><a href="#第四步：执行SQL语句" class="headerlink" title="第四步：执行SQL语句"></a>第四步：执行SQL语句</h4><h5 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h5><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将<code>select*</code>中的<code>*</code>替换成表上的所有的列</li></ul><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>负责将SQL语句按照最优方案去执行（选择索引的方式）</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</p><h3 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h3><ol><li>使用连接器进行身份认证和权限认证</li><li>使用解析器进行词法分析（构建SQL语法树）与语法分析（判断SQL语句是否满足语法条件）</li><li>开启事务，用于失败后回滚，记录相应的undo log</li><li>执行SQL更新语句（预处理器，优化器，执行器），同时将更新的记录写入到redo log中，但是redo log 不会立即写入磁盘，而是寻找合适的时机写入（WAL 技术）</li><li>更新语句执行完成后，开始记录该语句对应的bin log，将bin log保存到bin cache中，在事务提交时，才会刷新到磁盘中</li><li>事务提交，采用两阶段<ul><li>prepare阶段：将redo log对应的事务状态设置为prepare，将redo log写入到磁盘中</li><li>commit阶段：将bin cache中的bin log刷新到磁盘中，事务状态设置为commit</li></ul></li><li>一条更新语句执行完成</li></ol><h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><p>5.5版本之前使用MyISAM，5.5版本之后使用InnoDB</p><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><div class="table-container"><table><thead><tr><th style="text-align:left">InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td style="text-align:left">支持行级锁</td><td>仅支持表级锁</td></tr><tr><td style="text-align:left">支持外键</td><td>不支持外键</td></tr><tr><td style="text-align:left">支持事务</td><td>不提供事务支持</td></tr><tr><td style="text-align:left">支持数据库崩溃后的安全恢复</td><td>不支持安全恢复</td></tr><tr><td style="text-align:left">数据文件就是索引文件</td><td>索引文件和数据文件分离</td></tr></tbody></table></div><h3 id="MySql的数据存储"><a href="#MySql的数据存储" class="headerlink" title="MySql的数据存储"></a>MySql的数据存储</h3><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><ul><li>db.opt，存储当前数据库的默认字符集和字符效验规则</li><li>*.frm，表结构的存储文件</li><li>*.ibd，表数据的存储文件，也称为表空间文件</li></ul><h4 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom: 80%;" /></p><ol><li><strong>行（row）：</strong></li></ol><p>​        数据库的记录都是按照行来存放的，每一行有不同的行格式和存储结构</p><ol><li><p><strong>页（page）：</strong></p><p>InnoDB的数据是按照页的单位进行读写，默认每个页的大小为16KB</p></li><li><p><strong>区（extent）：</strong></p><p>当表中的数据量较大时，按照区为单位进行空间分配，每个区的大小为1MB</p></li><li><p><strong>段（segment）：</strong></p><ul><li>索引段：存放B+树的非叶子节点的集合</li><li>数据段：存放B+树叶子节点的集合</li><li>回滚段：存放回滚数据区的集合，MVCC就是利用了回滚段实现查询数据</li></ul></li></ol><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>Compact（5.1版本后使用）Dynamic和Compressed（5.5版本后使用）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"  /></p><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ol><li>变长字段长度列表：存储varchar的真实数据占用的字节数</li><li>NULL值列表：需要用整数个字节的位表示，也是逆序存放，列数不足整数个字节，高位补0<ul><li>二进制位的值为1，该列的值不为NULL</li><li>二进制位的值为0，该列的值为NULL</li></ul></li><li>记录头信息，5字节</li></ol><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ol><li>row_id：如果指定了主键或者唯一约束列，就无row_id，如果没有指定，会添加row_id，大小为6字节</li><li>trx_id：事务的id，表明该数据是由哪个事务生成的，必需存在，6字节</li><li>roll_pointer：记录上一个版本的指针。roll_pointer是必需的，7字节</li></ol><h5 id="varchar（n）的最大取值是多少"><a href="#varchar（n）的最大取值是多少" class="headerlink" title="varchar（n）的最大取值是多少"></a>varchar（n）的最大取值是多少</h5><p>MySQL规定所有列的字节长度不能超过65535个字节</p><p>1字节NULL值列表，2字节的变长字段长度列表</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>B+树索引，Hash索引，Full-Text索引</p><div class="table-container"><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Full-Text索引</td><td>Yes</td><td>Yes</td><td>No</td></tr></tbody></table></div><h5 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h5><ol><li>B+树和B树：<ul><li>B+树只有在叶子节点存储数据，B树的非叶子节点也存储数据</li><li>B+树采用双链表结构，可以使用基于范围的顺序查找</li><li>B+树的搜索更加稳定，必须要搜索到叶子节点</li></ul></li><li>B+树和二叉树<ul><li>B+树的高度一般在3~4层，二叉树的高度太高，因此B+树所进行的磁盘I/O操作比较少</li></ul></li><li>B+树和Hash索引<ul><li>Hash索引在等值查询时比较快，但是不适合进行范围查询</li></ul></li></ol><h4 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h4><p>聚簇索引（主键索引）和二级索引（辅助索引）</p><ul><li>聚簇索引：B+树的叶子节点存放的是实际数据</li><li>二级索引：B+树的叶子节点存放的是主键值而不是实际数据</li></ul><h4 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h4><p>主键索引、唯一索引、普通索引、前缀索引</p><ul><li>主键索引：创建表时，将主键字段作为主键索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>唯一索引：建立在唯一字段上的索引，一个表可以有多个唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> <span class="keyword">unique</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> INDEX [索引名] <span class="keyword">ON</span> [表名] (表的列名)</span><br></pre></td></tr></table></figure><ul><li>普通索引：建立在普通字段上的索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><ul><li>前缀索引：建立在字段类型为char、varchar、binary、varbinary列上，使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h4 id="按照字段个数分类"><a href="#按照字段个数分类" class="headerlink" title="按照字段个数分类"></a>按照字段个数分类</h4><p>单列索引、联合索引（复合索引）</p><p>联合索引：将多个字段组合成一个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>在联合索引的遍历过程中，对联合索引所包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><h5 id="索引区分度（区分度-column字段的不同值的个数-表的总行数）"><a href="#索引区分度（区分度-column字段的不同值的个数-表的总行数）" class="headerlink" title="索引区分度（区分度=column字段的不同值的个数/表的总行数）"></a>索引区分度（区分度=column字段的不同值的个数/表的总行数）</h5><p>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到</p><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="需要创建索引的情况"><a href="#需要创建索引的情况" class="headerlink" title="需要创建索引的情况"></a>需要创建索引的情况</h4><ul><li>字段有唯一性限制</li><li>经常在<code>WHERE</code>查询条件的字段，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段，这样在查询时不需要再去排序</li></ul><h4 id="不需要创建索引的情况"><a href="#不需要创建索引的情况" class="headerlink" title="不需要创建索引的情况"></a>不需要创建索引的情况</h4><ul><li><code>WHERE</code>,<code>GROUP BY</code>,<code>ORDER BY</code>里面用不到的字段</li><li>字段中存在大量的重复数据，如果某个值出现在表中的数据行的百分比很高时，一般会忽略索引，进行全表扫描（一般查询的结果集超过了总行数的25%，就没必要走索引了）</li><li>表数据太少</li><li>经常更新的字段不需要创建索引，电商项目的用户余额</li></ul><h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h3><ul><li>前缀索引优化：目的是减少索引字段的大小</li><li>覆盖索引优化：所查询的列在索引表中直接找到，避免回表</li><li>主键索引最好是自增的：插入新记录的时候不需要重新移动数据</li><li>索引最好是NOT NULL：null导致优化器做索引选择时比较复杂，此外null会导致产生NULL值列表</li></ul><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul><li>使用左或者左右模糊匹配，<code>like %XX</code>或者<code>like %xx%</code></li><li>在查询条件中对索引列进行了函数，计算，隐式类型转换</li><li>联合索引不遵循最左匹配原则</li><li>WHERE子句中OR前面使用索引，后面不使用索引，前面索引失效</li></ul><h3 id="面试额外问题"><a href="#面试额外问题" class="headerlink" title="面试额外问题"></a>面试额外问题</h3><h4 id="MySQL单表不要超过2000W行么？"><a href="#MySQL单表不要超过2000W行么？" class="headerlink" title="MySQL单表不要超过2000W行么？"></a>MySQL单表不要超过2000W行么？</h4><p>索引结构不会影响单表最大行数，2000W也只是推荐值，超过这个值会导致B+树的层级过高，影响查询的性能</p><h4 id="MySQL使用like-“-x”，索引一定失效么"><a href="#MySQL使用like-“-x”，索引一定失效么" class="headerlink" title="MySQL使用like “%x”，索引一定失效么"></a>MySQL使用like “%x”，索引一定失效么</h4><p>不一定，如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，会走全扫描二级索引树（type=index）</p><h4 id="count的性能"><a href="#count的性能" class="headerlink" title="count的性能"></a>count的性能</h4><p>count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</p><p>count(1)：表示1这个表达式不为NULL的记录有多少个，其实就是统计表中有多少个记录，此外读取记录时不会读取任何的字段值</p><p>count(*) = count(1) &gt; count(主键字段) 在执行时，如果表中存在二级索引，优化器会选择使用二级索引进行扫描</p><h5 id="大表count-的优化"><a href="#大表count-的优化" class="headerlink" title="大表count(*)的优化"></a>大表count(*)的优化</h5><ol><li>近似值：使用show table status 或者 explain命令来估算</li><li>使用额外表来保存计数值</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>A-原子性：事务是最小的执行单位，不允许分割，要么全部完成，要么全部不完成（利用undo log 来保证）</li><li>I-隔离性：并发访问数据库，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的（锁机制和MVCC来保证）</li><li>D-持久性：事务处理结束后，对数据的修改是永久的，系统故障也不会丢失（利用redo log 来保证）</li><li>C-一致性：事务操作前和操作后，数据保持一致</li></ul><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读取另一个事务未提交的数据，并且另一个事务进行了回滚操作</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片" style="zoom:80%;" /></p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>A读取数据，B也读取数据，A先修改，B后修改，A的修改被丢失</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务多次读取同一个数据，另一个事务将数据进行了修改，该事务两次读取的数据不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:80%;" /></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取某个范围的数据，另一个事务插入数据，该事务所读取的范围不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交，指一个事务没有提交时，它做的变更就能够让其他事务所读取</li><li>读已提交，允许读取并发事务已经提交的数据</li><li>可重复读，一个事务在执行过程中看到的数据跟这个事务启动时看到的数据时一致的</li><li>串行化，会对记录加上读写锁，最高的隔离级别</li></ul><p>各个隔离级别所克服的问题</p><ul><li><p>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</p></li><li><p>在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</p></li><li><p>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</p></li><li><p>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</p></li></ul><p>MySQL的默认隔离级别是<code>可重复读</code>，但是很大程度上解决了幻读现象，解决方案为：</p><ul><li>针对快照读(select 语句)，通过MVCC方式解决幻读</li><li>针对当前读(select … for update 等语句)，通过锁（next-key lock）的方式解决幻读</li></ul><h3 id="MVCC（多版本并发控制的实现）"><a href="#MVCC（多版本并发控制的实现）" class="headerlink" title="MVCC（多版本并发控制的实现）"></a>MVCC（多版本并发控制的实现）</h3><p>MVCC通过Read View、undo log、隐藏字段中的 trx_id（最后一次更新该记录的事务id）和 roll_pointer（指向旧版本的记录）来实现的</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:80%;" /></p><p>整个记录的示意图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:80%;" /></p><p>在创建Read View 后，记录中的trx_id被划分为三种情况：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:80%;" /></p><ol><li>记录的 trx_id 小于 Read View中的<code>min_trx_id</code>的值，表示该版本的记录是在创建Read View前已经提交的事务生成的，所以该版本的记录对当前事务可见</li><li>记录的 trx_id 大于 Read View中的<code>max_trx_id</code>的值，表示该版本的记录是在创建Read View后才启动的事务所生成的，因此该版本的记录不可见</li><li>如果记录的 trx_id 在 Read View的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在m_ids 列表中：<ul><li>如果在<code>m_ids</code>列表中，说明生成该版本的事务还未提交，因此该版本的记录<strong>不可见</strong></li><li>如果不在<code>m_ids</code>列表中，说明生成该版本的事务已被提交，因此该版本的记录<strong>可见</strong></li></ul></li></ol><p>如果当前记录的版本对当前事务不可见，那么事务会沿着undo log的链条，利用roll_pointer寻找旧版本的记录，找到符合Read View版本的记录</p><h3 id="MySQL完全解决幻读了么？"><a href="#MySQL完全解决幻读了么？" class="headerlink" title="MySQL完全解决幻读了么？"></a>MySQL完全解决幻读了么？</h3><p>没有</p><ol><li>当事务A查询记录不存在，但是它更新这条记录，就会看到另一个事务所插入的数据</li><li>A事务快照读，B事务插入一个数据并且提交，A事务在进行当前读，发现读取到了B事务提交的数据，发生了幻读</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h3><ol><li><p>全局锁：整个数据库只有只读状态</p></li><li><p>表级锁：</p><ul><li><p>表锁：读锁和写锁</p></li><li><p>元数据锁：MDL读锁和MDL写锁，对表执行CRUD操作时，防止其他线程对这个表结构做变更</p></li><li><p>意向锁：意向共享锁和意向独占锁时表级锁，会与表锁发生冲突，不会与行级锁发生冲突</p><p>表锁和行锁满足：读读共享，读写互斥，写写互斥</p></li><li><p>AUTO-INC锁：不指定主键值时，自增给主键赋值</p></li></ul></li><li><p>行级锁：</p><ul><li>Record Lock，记录锁，锁住一条记录，记录锁有S锁（共享锁）和X锁（读写锁）之分</li><li>Gap Lock，间隙锁，锁定一个范围，不包含记录本身，两个事务之间的间隙锁互相兼容</li><li>Next-Key Lock，临键锁，记录锁+间隙锁</li></ul></li></ol><h3 id="MySQL加锁过程"><a href="#MySQL加锁过程" class="headerlink" title="MySQL加锁过程"></a>MySQL加锁过程</h3><p>MySQL加锁过程</p><ol><li>原则：<ul><li>前开后闭区间，基本单位，next-key lock</li><li>查找过程中访问到的对象才能加锁</li></ul></li><li>优化1：索引上的等值查询，给唯一索引加锁时，临键锁退化成记录锁</li><li>优化2：索引上的等值查询，没访问到时，向右遍历时且最后一个值不满足等值条件时，退化为间隙锁</li><li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul><li>当查询的记录<strong>存在</strong>，临键锁会退化成记录锁</li><li>当查询的记录<strong>不存在</strong>，临键锁退化成间隙锁，查找id=2的例子如下：</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%B4%E9%9A%99%E9%94%81.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><ul><li>查询范围{大于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&gt;15的例子如下，如果是id&gt;=15，那么id=15的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E15.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>查询范围{小于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&lt;5的例子如下，如果是id&lt;=15，那么id=5的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E5.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h4><p>当进行等值查询时，不仅为唯一索引加锁，还要对主键索引加锁，但是只对符合查询条件的主键索引加记录锁</p><ul><li>当查询记录{存在}，间隙锁加临键锁，并且给主键索引加记录锁，例如查找age=22的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>当查询记录{不存在}，只加间隙锁，例如查找age=25的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h4><p>所使用的索引所加的锁都是next-key lock，不会退化成间隙锁或记录锁，符合查询条件的主键索引都加入记录锁</p><p>例如查询 age&gt;=22的例子如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h4><p>如果没有走索引，就会走全表扫描，对全表的记录都加锁</p><p>可以开启安全更新模式，将<code>sql_safe_updates</code>设置为1</p><h3 id="记录锁-间隙锁可以防止删除操作而导致的幻读么"><a href="#记录锁-间隙锁可以防止删除操作而导致的幻读么" class="headerlink" title="记录锁+间隙锁可以防止删除操作而导致的幻读么"></a>记录锁+间隙锁可以防止删除操作而导致的幻读么</h3><p>可以</p><h3 id="MySQL-死锁了怎么办"><a href="#MySQL-死锁了怎么办" class="headerlink" title="MySQL 死锁了怎么办"></a>MySQL 死锁了怎么办</h3><p>死锁需要四种必要条件：互斥，持有并等待，不能抢占，循环等待</p><p>MySQL有两种策略来{打破循环等待}：</p><ul><li>设置事务等待锁的超时时间：默认50秒，超时后事务主动回滚，锁释放</li><li>开启主动死锁检测：发现死锁后，主动回滚死锁链条中的某一个事务</li></ul><h3 id="导致死锁的原因"><a href="#导致死锁的原因" class="headerlink" title="导致死锁的原因"></a>导致死锁的原因</h3><p>一般为A和B事务都加入了间隙锁，因为间隙锁相互兼容，下一步的插入需要获取插入意向锁就互相等待了</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h3><ul><li>插入时，记录主键值，回滚时则删除主键对应记录</li><li>删除时，记录这条记录的所有内容，回滚时，将内容组成的记录插入回表中</li><li>更新时，记录被更新列的旧值，回滚时，更新回旧值</li></ul><h4 id="undo-log-什么时候刷盘的（持久化到磁盘）"><a href="#undo-log-什么时候刷盘的（持久化到磁盘）" class="headerlink" title="undo log 什么时候刷盘的（持久化到磁盘）"></a>undo log 什么时候刷盘的（持久化到磁盘）</h4><p>undo log和数据页的刷盘策略一样，都是通过redo log来保证持久化</p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>InnoDB存储引擎设计了缓冲池（Buffer Pool）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><ul><li>当读取数据时，如果数据存在缓冲池中，客户端回直接读取缓冲池中的数据</li><li>当修改数据时，如果数据存在缓冲池中，将数据所在页标记为脏页，脏页不会立即写入磁盘，而是寻找合适机会再写入</li></ul><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h3><p>因为Buffer Pool是基于内存的，万一断电重启，脏页数据就会丢失</p><p>为了防止上述问题，当一条记录需要更新的时候，存储引擎会先更新内存（同时标记为脏页），然后将本次修改以redo log的形式记录下来</p><p>WAL技术：写操作不是立即写到磁盘上，而是先写日志，然后寻找合适的时间再写入到磁盘中</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><h4 id="redo-log的具体操作"><a href="#redo-log的具体操作" class="headerlink" title="redo log的具体操作"></a>redo log的具体操作</h4><p>redo log是物理页，记录某个数据页做了什么修改，在事务提交时，先将redo log 持久化到磁盘中</p><p>redo log使用的好处：</p><ol><li>实现事务的持久性，让MySQL有了崩溃恢复的能力</li><li>将写操作从{随机写}变成{顺序写}，提高了MySQL写入磁盘的性能</li></ol><p>但是redo log 不是直接写入磁盘，而是通过自己的缓存 redo log buffer 持久化到磁盘</p><h4 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h4><ul><li>MySQL正常关闭时</li><li>redo log buffer 中的写入量大于redo log buffer内存空间的一半时</li><li>后台线程每隔1s，就将redo log buffer 持久化到磁盘（崩溃可能会丢失1秒事务的数据）</li><li>每次事务提交时，都将缓存在redo log buffer 的redo log 持久化到磁盘</li></ul><h4 id="redo-log日志满了怎么办"><a href="#redo-log日志满了怎么办" class="headerlink" title="redo log日志满了怎么办"></a>redo log日志满了怎么办</h4><p>redo log日志满了，MySQL不会执行新的更新操作，会被阻塞（并发量大的系统，需要设置适当的redo log的大小），引擎会标记干净页，对旧的redo log记录进行擦除</p><h3 id="bin-log日志"><a href="#bin-log日志" class="headerlink" title="bin log日志"></a>bin log日志</h3><p>是MySQL在Server层实现的日志，所有的存储引擎都可以使用</p><h4 id="redo-log-和-bin-log的区别"><a href="#redo-log-和-bin-log的区别" class="headerlink" title="redo log 和 bin log的区别"></a>redo log 和 bin log的区别</h4><div class="table-container"><table><thead><tr><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>InnoDB存储引擎实现的日志</td><td>MySQL的Server层实现的日志，所有引擎都可以使用</td></tr><tr><td>物理日志</td><td>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中</td></tr><tr><td>循环写</td><td>追加写，写满一个文件，会创建一个新的文件</td></tr><tr><td>用于故障恢复</td><td>备份恢复和主从复制</td></tr></tbody></table></div><h4 id="bin-log的刷盘时机"><a href="#bin-log的刷盘时机" class="headerlink" title="bin log的刷盘时机"></a>bin log的刷盘时机</h4><p>事务执行过程中，先把日志写到 bin log cache（Server 层的 cache），事务提交的时候，再把 bin log cache 写到 bin log 文件中。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的过程："><a href="#主从复制的过程：" class="headerlink" title="主从复制的过程："></a>主从复制的过程：</h4><ol><li><p>写入bin log：</p><p>主库收到客户端提交的事务请求后，写入bin log，提交事务，更新本地存储数据</p></li><li><p>同步bin log：</p><p>从库创建专门的I/O线程，连接主控的log dump线程，接受主库的bin log日志，再把日志写入到relay log暂存日志中，返回复制成功的响应</p></li><li><p>回放bin log：</p><p>从库创建一个回访bin log的线程，读取relay log暂存日志，回放bin log中的更新存储引擎中的数据，实现主从一致性</p></li></ol><p>一般写操作在主库中，读操作在从库中，一般从库2个，备份库一个</p><h4 id="主从复制的模型"><a href="#主从复制的模型" class="headerlink" title="主从复制的模型"></a>主从复制的模型</h4><ul><li>同步复制：所有从库都复制成功返回响应才完成线程</li><li>异步复制：不会等待bin log 同步到各从库，就返回客户端的结果，当主库宕机，数据就会丢失</li><li>半同步复制：不需要等待所有从库都返回响应，只需要一个从库响应就可以</li></ul><h3 id="两阶段提交的意义"><a href="#两阶段提交的意义" class="headerlink" title="两阶段提交的意义"></a>两阶段提交的意义</h3><h2 id="MySQL的优化"><a href="#MySQL的优化" class="headerlink" title="MySQL的优化"></a>MySQL的优化</h2><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>数据库对象名称必须使用小写字母并用下划线分割</li><li>数据库名称禁止使用MySQL的保留关键字</li><li>临时库表必须以<code>tem_</code>为前缀，日期为后缀，备份表必须以<code>bak_</code>为前缀，日期为后缀</li><li>所有存储相同数据的列名和列类型必须一致，防止出现隐式类型转换</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><ul><li>所有表使用InnoDB存储引擎</li><li>库和表的字符集统一使用UTF8，如果存储emoji表情，采用utf8mb4字符集</li><li>表和字段需要添加注释</li><li>尽量控制单表的数据量的大小，一般是500万以内，多了就需要分库分表</li><li>经常使用的列放到一个表中</li><li>禁止建立预留字段</li><li>禁止在数据库中存储文件（图片或者视频音频）这类的大的二进制数据，一般这类数据存储于文件服务器中，数据库只存储文件地址信息</li></ul><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><ul><li>优先选择符合存储需要的最小的数据类型</li><li>对于非负型的数据，使用无符号的整型来存储</li><li>小数值类型使用TINYINT类型</li><li>尽可能把所有的列都定义为NOT NULL</li><li>使用TIMESTAMP或者DATETIME类型来存储时间</li><li>使用DECIMAL类型来存储金额类数据</li></ul><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><ul><li>限制单表索引数量，建议单表索引数量不超过5个</li><li>禁止给表中的每一类都建立索引，因为可以使用联合索引</li><li>每个表中都需要主键</li><li>将WHERE，ORDER BY，GROUP BY，DISTINCT中的字段建立索引，或者将多表join的关联列建立索引</li><li><p>避免建立冗余索引和重复索引，例如index（a,b,c）、index(a,b)</p></li><li><p>对频繁的查询优先考虑覆盖索引</p></li><li><p><strong>避免使用外键约束，数据的关联性在业务端实现，需要在表与表之间的关联键上建立索引</strong></p></li></ul><h3 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h3><ul><li>优化对性能影响较大的SQL语句，利用慢查询日志，EXPLAIN</li><li>避免使用select *，无法走覆盖索引</li><li>禁止使用不包含字段列表的INSERT语句</li><li><strong>使用预编译语句进行数据库的操作</strong></li><li>避免数据类型的隐式转换</li><li><strong>避免使用子查询，把子查询优化为join操作</strong></li><li>避免使用JOIN关联太多的表，建议不超过五个</li><li>将批量操作代替单次操作</li><li>将in代替or，or有时候不会走索引</li><li>禁止使用order by rand()进行随机排序</li><li>在明显不会有重复值时使用UNION ALL 而不是 UNION，因为UNION会去重，影响效率</li><li>禁止跨库查询</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><ul><li><p>避免大批量的写操作，要分批多次进行操作</p></li><li><p>对于打包使用pt-online-schema-change来修改表结构</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a><br><a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven3.1</title>
      <link href="/mingyry/d1df8b0a.html"/>
      <url>/mingyry/d1df8b0a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Maven的两大功能"><a href="#Maven的两大功能" class="headerlink" title="Maven的两大功能"></a>Maven的两大功能</h3><ol><li><p>构建</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java源程序编译成*.class字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包：<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个Maven工程经过打包操作生成的jar包或者war包存入Maven的本地仓库</li><li>部署：<ul><li>部署jar包：把一个jar包部署到Nexus私服服务器上</li><li>部署war包：借助相关Maven插件（例如cargo），将war包部署到Tomcat服务器上</li></ul></li></ul></li><li><p>依赖</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar包的下载：使用Maven之后，jar包会从规范的远程仓库下载到本地</li><li>jar包之间的依赖：通过依赖的传递性自动完成</li><li>jar包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul></li><li><p>Maven的工作机制</p></li></ol><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208095706353.png" alt="image-20230208095706353"></p><h3 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h3><ol><li>关注Maven的核心配置文件：conf/settings.xml，修改本地仓库，防止体积太大拖慢c盘运行速度。</li></ol><p>​    <localRepository>D:\maven-repository</localRepository></p><ol><li>配置镜像仓库，使Maven下载jar包更快</li><li>配置Maven工程的基础JDK版本，一般使用JDK1.8</li><li>配置Maven的环境变量 MAVEN_HOME</li></ol><h3 id="使用Maven的步骤"><a href="#使用Maven的步骤" class="headerlink" title="使用Maven的步骤"></a>使用Maven的步骤</h3><h4 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h4><ol><li>根据Maven的坐标找到本地仓库中对应的jar包</li></ol><p>​    使用三个『向量』在『Maven的仓库』中<strong>唯一的定位</strong>到一个『jar』包。</p><ul><li>groupId：公司或组织的 id</li><li>artifactId：一个项目或者是项目中的一个模块的 id</li><li>version：版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的jar包在Maven本地仓库中的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><ol><li>Maven自动生成的pom.xml解读</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>Maven的核心概念：POM</p><ul><li>含义：Project Object Model。项目对象模型。和POM类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</li><li>模型化思想：POM表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事务抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</li><li>对应的配置文件：POM理念体现在Maven工程根目录下pom.xml这个配置文件中。所以这个pom.xml配置文件就是Maven工程的核心配置文件。其实学习Maven就是学习这个文件怎么配置，各个配置有什么用</li></ul></li><li><p>Maven核心概念：约定的目录结构</p><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208102035142.png" alt="image-20230208102035142"></p></li></ol><ul><li>约定目录结构的意义：为了让构建过程尽可能自动化完成，所以必须约定目录结构的作用</li><li>约定大于配置：Maven对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建Maven工程后，还需要针对各个目录的位置进行详细的配置，肯定非常麻烦。</li></ul><p>​       目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码</p><h4 id="执行Maven的构建命令"><a href="#执行Maven的构建命令" class="headerlink" title="执行Maven的构建命令"></a>执行Maven的构建命令</h4><ol><li><p>要求</p><p>运行Maven中的构建操作相关的命令时，必须进入到pom.xml所在的目录。</p></li><li><p>清理操作</p><p>mvn clean      删除target目录</p></li><li><p>编译操作</p><p>主程序编译：mvn compile</p><p>测试程序编译： mvn test-compile</p><p>主程序编译结果存放目录：target/classes</p><p>测试程序编译结果存放目录：target/test-classes</p></li><li><p>测试操作</p><p>mvn test </p><p>测试报告存放目录：target/surefire-reports</p></li><li><p>打包操作</p><p>mvn package</p><p>打包的结果——jar包，存放的目录：target</p></li><li><p>安装操作</p><p>mvn install</p><p>安装是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据他的坐标生成的。</p><p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ol><h4 id="Maven中的依赖问题"><a href="#Maven中的依赖问题" class="headerlink" title="Maven中的依赖问题"></a>Maven中的依赖问题</h4><ol><li><p>依赖范围：</p><p>标签的位置：dependencies/dependency/scope</p><p>标签的可选值：compile/test/provided/system/runtime/import</p><p>结论：</p><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“服务器上已经有了，你就别带啦！”</p></li><li><p>依赖的传递性：</p><ul><li>概念：A依赖B，B依赖C，那么在A没有配置对C的依赖的情况下，A里面能不能直接使用C？</li><li>传递的原则：在A依赖B，B依赖C的前提下，C是否能够传递到A，取决于B依赖C时使用的依赖范围。<ul><li>B依赖C时使用<strong>compile</strong>范围：可以传递</li><li>B依赖C时使用<strong>test</strong>或<strong>provided</strong>范围：不能传递，所以需要这样的jar包时，就必须在需要的地方明确配置依赖才可以。</li></ul></li></ul></li><li><p>依赖的排除</p><ul><li><p>概念：当A依赖B，B依赖C而且C可以传递到A的时候，A不想要C，需要在A里面把C排除掉。而往往这种情况都是为了避免jar包之间的冲突。</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img027.2faff879.png" alt="img">所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><ul><li><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用excludes标签配置依赖的排除  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="Maven继承"><a href="#Maven继承" class="headerlink" title="Maven继承"></a>Maven继承</h4><ul><li><p>概念：</p><p>Maven工程之间，A工程继承B工程</p><ul><li>B工程：父工程</li><li>A工程：子工程</li></ul><p>本质上是A工程的pom.xml中的配置继承了B工程中pom.xml的配置</p></li><li><p>作用：</p><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个project下面，创建了很多个module。</li><li>每一个module都需要配置自己的依赖信息。</li></ul><p>它的需求是：</p><ul><li>在每一个module中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同jar包，他们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的jar包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的jar包；又能够将以往的经验沉淀下来，节约时间和精力。</p></li><li><p>操作：</p><ul><li><p>创建父工程：只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p></li><li><p>创建模块工程：需要进入 pro03-maven-parent 工程的根目录，然后运行 mvn archetype:generate 命令来创建模块工程。</p></li><li><p>下面 modules 和 module 标签是聚合功能的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;  </span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro04-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro05-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro06-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure></li><li><p>解读子工程的pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置依赖的统一管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子工程中引用那些被父工程管理的依赖：关键点：省略版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中升级依赖信息的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>在父工程中声明自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h4><p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><blockquote><p>概念的对应关系：</p><p>从继承角度看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合角度看：</p><ul><li>总工程</li><li>模块工程</li></ul></blockquote><ol><li><p>好处</p><ul><li>一键执行Maven命令：很多构建命令都可以在“总工程”中一键执行</li><li>配置聚合之后，各个模块工程会在总工程中展示以一个列表，让项目中的各个模块一目了然。</li></ul></li><li><p>聚合的配置：在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Maven其他核心概念"><a href="#Maven其他核心概念" class="headerlink" title="Maven其他核心概念"></a>Maven其他核心概念</h3><ol><li>生命周期：在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li><li>插件和目标：<ul><li>插件：Maven的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。</li><li>目标：一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</li></ul></li><li>仓库：<ul><li>本地仓库：在当前电脑上，为电脑上所有的Maven工程服务</li><li>远程仓库：官方或者其他组织维护的 Maven 仓库</li></ul></li></ol><p>​    Maven 远程仓库可以分为：</p><p>​        <strong>中央仓库</strong> ：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a href="https://search.maven.org/">查询地址open in new window</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</p><p>​        <strong>私服</strong> ：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</p><p>​        <strong>其他的公共仓库</strong> ：有一些公共仓库是未来加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</p><p><strong>Maven 依赖包寻找顺序：</strong></p><ol><li><p>先去本地仓库找寻，有的话，直接使用。</p></li><li><p>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</p></li><li><p>远程仓库没有找到的话，会报错。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识</title>
      <link href="/mingyry/1ad06ab1.html"/>
      <url>/mingyry/1ad06ab1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h2><p>JDBC (Java Database Connectivity) 是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来范文数据库的标准Java类库，（java.sql, javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</p><h3 id="1-2-数据存储技术"><a href="#1-2-数据存储技术" class="headerlink" title="1.2 数据存储技术"></a>1.2 数据存储技术</h3><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO（Java Data Object）技术</li><li>第三方O/R工具，如Hibernate，Mybatis等</li></ul><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC</p><h2 id="2-获取数据库连接"><a href="#2-获取数据库连接" class="headerlink" title="2. 获取数据库连接"></a>2. 获取数据库连接</h2><h3 id="2-1-Driver-接口实现类"><a href="#2-1-Driver-接口实现类" class="headerlink" title="2.1 Driver 接口实现类"></a>2.1 Driver 接口实现类</h3><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动：com.mysql.jdbc.Driver</li></ul><h3 id="2-2-加载和注册JDBC驱动"><a href="#2-2-加载和注册JDBC驱动" class="headerlink" title="2.2 加载和注册JDBC驱动"></a>2.2 加载和注册JDBC驱动</h3><ul><li><p>加载驱动：加载JDBC驱动需要调用Class类的静态方法forName()，向其传递要加载的JDBC驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>;</li></ul></li><li><p>注册驱动：DriverManager类是驱动程序管理器类，负责管理驱动程序</p><ul><li>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</li><li>通常不用显式调用DriverManager类的registerDriver()方法来注册，因为Driver接口的驱动程序类都包含了静态代码块，会在创建时自动调用方法。</li></ul></li></ul><h3 id="2-3-URL"><a href="#2-3-URL" class="headerlink" title="2.3 URL"></a>2.3 URL</h3><ul><li>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。</li><li>JDBC URL 的标准由三部分组成，各部分间用冒号分割。<ul><li>jdbc：子协议：子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依照不同的子协议而变化，用子名称的目的是为了定位数据库提供足够多的信息。包含<strong>主机名</strong>（对应服务端的ip地址），端口号，数据库名</li></ul></li></ul><p>举例：<br><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220720100751524.png" alt="image-20220720100751524" style="zoom: 33%;" />   </p><h3 id="2-4-用户名和密码"><a href="#2-4-用户名和密码" class="headerlink" title="2.4 用户名和密码"></a>2.4 用户名和密码</h3><ul><li>user，password 可以用“属性名=属性值”方式告诉数据库</li><li>可以调用DriverManager类的getConnection()方法建立到数据库的连接</li></ul><h3 id="2-5-连接方式"><a href="#2-5-连接方式" class="headerlink" title="2.5 连接方式"></a>2.5 连接方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">//1.加载配置文件 </span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);       <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); </span><br><span class="line">    pros.load(is); </span><br><span class="line">    <span class="comment">//2.读取配置信息 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>); </span><br><span class="line">    <span class="comment">//3.加载驱动 </span></span><br><span class="line">    Class.forName(driverClass); </span><br><span class="line">    <span class="comment">//4.获取连接 </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=root </span><br><span class="line">password=abc123 </span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test </span></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="3-使用PreparedStatement实现CRUD操作"><a href="#3-使用PreparedStatement实现CRUD操作" class="headerlink" title="3. 使用PreparedStatement实现CRUD操作"></a>3. 使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-Statement的弊端"><a href="#3-1-Statement的弊端" class="headerlink" title="3.1 Statement的弊端"></a>3.1 Statement的弊端</h3><ul><li>问题一：存在拼串操作、繁琐</li><li><p>问题二：存在SQL注入问题</p></li><li><p>SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令（如：SELECT user，password FROM user_table WHERE user=’a’ OR 1 = ‘AND password = ‘ OR ‘1’ = ‘1’）利用系统的SQL引擎完成恶意行为的做法。</p></li><li>使用PreparedStatement取代Statement可以防范SQL注入</li></ul><h3 id="3-2-PreparedStatement的使用"><a href="#3-2-PreparedStatement的使用" class="headerlink" title="3.2 PreparedStatement的使用"></a>3.2 PreparedStatement的使用</h3><h4 id="3-2-1-PreparedStatement介绍"><a href="#3-2-1-PreparedStatement介绍" class="headerlink" title="3.2.1 PreparedStatement介绍"></a>3.2.1 PreparedStatement介绍</h4><ul><li>通过调用Connection对象的preparedStatement(String sql) 方法获取PreparedStatement对象</li></ul><h4 id="3-2-2-PreparedStatement的优势"><a href="#3-2-2-PreparedStatement的优势" class="headerlink" title="3.2.2 PreparedStatement的优势"></a>3.2.2 PreparedStatement的优势</h4><ul><li>代码的可读性和可维护性</li><li><p>PreparedStatement能最大可能提高性能：</p><ul><li>DBServer会对预编译语句提供性能优化</li><li>（语法检查，语义检查，翻译成二进制命令，缓存）</li></ul></li><li><p>PreparedStatement可以防止SQL注入</p></li></ul><h3 id="3-3-实现看代码"><a href="#3-3-实现看代码" class="headerlink" title="3.3 实现看代码"></a>3.3 实现看代码</h3><h3 id="3-4-资源的释放"><a href="#3-4-资源的释放" class="headerlink" title="3.4 资源的释放"></a>3.4 资源的释放</h3><ul><li>释放ResultSet，Statement，Connection</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放</li><li>可以在finally中关闭，保证即使其他代码出现异常，资源也一定能被关闭。</li></ul><h2 id="4-操作大型字段BLOB"><a href="#4-操作大型字段BLOB" class="headerlink" title="4. 操作大型字段BLOB"></a>4. 操作大型字段BLOB</h2><ul><li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接。</li><li>MySQL的四种BLOB类型（除了在存储的最大信息量上不同外，他们是等同的）</li></ul><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220720104340416.png" alt="image-20220720104340416" style="zoom:33%;" /></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：max_allowed_packet = 16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h2 id="5-批量插入"><a href="#5-批量插入" class="headerlink" title="5. 批量插入"></a>5. 批量插入</h2><p>当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句;</li><li>clearBatch()：清空缓存的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */</span><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection(); </span><br><span class="line">    <span class="comment">//1.设置为不自动提交数据 </span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>; </span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123; </span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i); </span><br><span class="line">                                    </span><br><span class="line">        <span class="comment">//1.“攒”sql </span></span><br><span class="line">        ps.addBatch();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//2.执行 </span></span><br><span class="line">            ps.executeBatch(); </span><br><span class="line">            <span class="comment">//3.清空 </span></span><br><span class="line">            ps.clearBatch(); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.提交数据 </span></span><br><span class="line">    conn.commit(); </span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">    JDBCUtils.closeResource(conn, ps); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-数据库事务"><a href="#6-数据库事务" class="headerlink" title="6. 数据库事务"></a>6. 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li>事务：一组逻辑操作单元，使数据从一种转台变换到另一种状态</li><li>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被<strong>提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所做的所有修改，整个事务<strong>回滚(rollback)</strong>到最初状态。</li><li>为了保证数据库中的数据的一致性，数据的操作应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚</p></li><li><p>数据什么时候意味着提交？</p><ul><li>当一个连接对象被创建时，默认情况下时自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p>JDBC程序中为了让多个SQL语句作为一个事务执行：</p><ul><li>调用Connection对象的setAutoCommit(false);以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用commit()；方法提交事务</li><li>在出现异常时，调用rollback()；方法回滚事务</li></ul><blockquote><p>若此时Connection没有被关闭，还可能被重复使用，则需要恢复其自动提交状态setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a><strong>6.3</strong> 事务的ACID属性</h3><ol><li><strong>原子性（Atomicity）</strong> </li></ol><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><ol><li><strong>一致性（Consistency）</strong> </li></ol><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p><ol><li><strong>隔离性（Isolation）</strong> </li></ol><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ol><li><strong>持久性（Durability）</strong> </li></ol><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><p><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p></li><li><p><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</p></li><li><p><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</p></li></ul><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高,数据一致性就越好,但并发性越弱。</strong></p><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220720112051169.png" alt="image-20220720112051169" style="zoom: 50%;" /></p><ul><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li><li><p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ</strong>。</p></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 <strong>在MySql中设置隔离级别</strong></h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation,表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation</span><br></pre></td></tr></table></figure></li><li><p>设置当前mySQL连接的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 授予通过网络方式登陆的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privialeges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;;</span><br><span class="line"># 给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="8-数据库连接池"><a href="#8-数据库连接池" class="headerlink" title="8. 数据库连接池"></a>8. 数据库连接池</h2><h3 id="8-1-数据库连接池的必要性"><a href="#8-1-数据库连接池的必要性" class="headerlink" title="8.1 数据库连接池的必要性"></a>8.1 数据库连接池的必要性</h3><ul><li>传统模式的缺陷<ul><li>需要数据库连接的时候，向数据库要求一个连接，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。</li><li>对于每一次数据库连接，使用完后都得断开。（思考：何为java的内存泄露？）</li><li>这种开发不能控制被创建的连接对象数。</li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li>为了解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕后再放回。</li><li>数据库连接池负责分配、管理和释放数据库连接，<strong>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong></li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数zhanyou 阿是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li><li><p>工作原理：<br><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20220721094252130.png" alt="image-20220721094252130" style="zoom:80%;" /></p></li><li><p>数据库连接池技术的优点：</p><ol><li>资源重用<br>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li><li>更快的系统反应速度<br>数据库连接池在初始化过程中，已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</li><li>新的资源分配手段<br>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</li><li>统一的连接管理，避免数据库连接泄露<br>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li></ol></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC的数据库连接池使用 javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由服务器(Weblogic,WebSphere,Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong>是Apache提供的数据库连接池。tomcat服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong>是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。Hibernate官方推荐使用。</li><li><strong>Proxool</strong>是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li><strong>BoneCP</strong>是一个开源组织提供的数据库连接池，速度快。</li><li><strong>Druid</strong>是阿里提供的数据库连接池，据说集DBCP、C3P0、Proxool优点于一身的数据库连接池，但是速度不确定是否有BoneCP快。</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯是也经常把DataSource称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库的访问速度</strong>。</li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是数据库连接的工厂，因此 整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close()；但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123; </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection(); </span><br><span class="line">    <span class="keyword">return</span> conn; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span>  // 同时可以有5条sql语句在读取数据库</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-Druid-德鲁伊-数据库连接池"><a href="#8-3-2-Druid-德鲁伊-数据库连接池" class="headerlink" title="8.3.2 Druid(德鲁伊)数据库连接池"></a>8.3.2 Druid(德鲁伊)数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection; </span><br><span class="line"><span class="keyword">import</span> java.util.Properties; </span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource; </span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>)); </span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection(); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true </span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root </span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456 </span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10 // 初始化建立物理连接的个数。</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20 // 最大连接池的数量</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000 // 获取连接时最大等待时间</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall // 配置扩展插件，监控统计filters:start  日志filters:log4  防御sql注入filters:wall</span></span><br></pre></td></tr></table></figure><h2 id="9-Apache-DBUtils实现CRUD操作"><a href="#9-Apache-DBUtils实现CRUD操作" class="headerlink" title="9. Apache-DBUtils实现CRUD操作"></a>9. Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils-简介"><a href="#9-1-Apache-DBUtils-简介" class="headerlink" title="9.1 Apache-DBUtils 简介"></a>9.1 Apache-DBUtils 简介</h3><ul><li>commons-dbutils 是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</li><li>API介绍：<ul><li>org.apache.commons.dbutils.QueryRunner  提供数据库操作的一系列重载的update()和query()操作</li><li>org.apache.commons.dbutils.ResultSetHandler  用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现</li><li>工具类：org.apache.commons.dbutils.DbUtils</li></ul></li></ul><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWithTx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接的操作（ </span></span><br><span class="line">        <span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">        <span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid </span></span><br><span class="line">        <span class="comment">//2.对数据表进行一系列CRUD操作 </span></span><br><span class="line">        <span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0) </span></span><br><span class="line">        <span class="comment">//version2.0的增删改 public void update(Connection conn,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类 </span></span><br><span class="line">        <span class="comment">//提交数据 conn.commit(); </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//回滚数据 conn.rollback(); </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123; </span><br><span class="line">            e1.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="comment">//3.关闭连接等操作 </span></span><br><span class="line">        <span class="comment">//① JDBCUtils.closeResource(); </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
