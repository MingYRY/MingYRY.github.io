<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/13/hello-world/"/>
      <url>/2023/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/04/13/MySQL/"/>
      <url>/2023/04/13/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Select语句的执行流程"><a href="#Select语句的执行流程" class="headerlink" title="Select语句的执行流程"></a>Select语句的执行流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:80%;" /></p><ul><li>Server 层负责建立连接、分析和执行SQL语句</li><li>存储引擎层负责数据的存储和提取</li></ul><h4 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h4><p>进行身份认证和权限认证：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="第二步：查询缓存（8-0版本后移除）"><a href="#第二步：查询缓存（8-0版本后移除）" class="headerlink" title="第二步：查询缓存（8.0版本后移除）"></a>第二步：查询缓存（8.0版本后移除）</h4><p>执行查询语句时会先去查询缓存（Query Cache）里查找缓存，缓存是以key-value的形式存在的，如果查询到缓存，直接返回value给客户端</p><h4 id="第三步：解析器"><a href="#第三步：解析器" class="headerlink" title="第三步：解析器"></a>第三步：解析器</h4><ul><li>词法分析。根据输入的字符串构建SQL语法树</li><li>语法分析。根据语法规则，判断输入的SQL语句是否满足语法条件</li></ul><blockquote><p>这步不会去检查表是否存在或者表中的字段是否存在</p></blockquote><h4 id="第四步：执行SQL语句"><a href="#第四步：执行SQL语句" class="headerlink" title="第四步：执行SQL语句"></a>第四步：执行SQL语句</h4><h5 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h5><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将<code>select*</code>中的<code>*</code>替换成表上的所有的列</li></ul><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>负责将SQL语句按照最优方案去执行（选择索引的方式）</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</p><h3 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h3><ol><li>使用连接器进行身份认证和权限认证</li><li>使用解析器进行词法分析（构建SQL语法树）与语法分析（判断SQL语句是否满足语法条件）</li><li>开启事务，用于失败后回滚，记录相应的undo log</li><li>执行SQL更新语句（预处理器，优化器，执行器），同时将更新的记录写入到redo log中，但是redo log 不会立即写入磁盘，而是寻找合适的时机写入（WAL 技术）</li><li>更新语句执行完成后，开始记录该语句对应的bin log，将bin log保存到bin cache中，在事务提交时，才会刷新到磁盘中</li><li>事务提交，采用两阶段<ul><li>prepare阶段：将redo log对应的事务状态设置为prepare，将redo log写入到磁盘中</li><li>commit阶段：将bin cache中的bin log刷新到磁盘中，事务状态设置为commit</li></ul></li><li>一条更新语句执行完成</li></ol><h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><p>5.5版本之前使用MyISAM，5.5版本之后使用InnoDB</p><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><div class="table-container"><table><thead><tr><th style="text-align:left">InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td style="text-align:left">支持行级锁</td><td>仅支持表级锁</td></tr><tr><td style="text-align:left">支持外键</td><td>不支持外键</td></tr><tr><td style="text-align:left">支持事务</td><td>不提供事务支持</td></tr><tr><td style="text-align:left">支持数据库崩溃后的安全恢复</td><td>不支持安全恢复</td></tr><tr><td style="text-align:left">数据文件就是索引文件</td><td>索引文件和数据文件分离</td></tr></tbody></table></div><h3 id="MySql的数据存储"><a href="#MySql的数据存储" class="headerlink" title="MySql的数据存储"></a>MySql的数据存储</h3><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><ul><li>db.opt，存储当前数据库的默认字符集和字符效验规则</li><li>*.frm，表结构的存储文件</li><li>*.ibd，表数据的存储文件，也称为表空间文件</li></ul><h4 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom: 80%;" /></p><ol><li><strong>行（row）：</strong></li></ol><p>​        数据库的记录都是按照行来存放的，每一行有不同的行格式和存储结构</p><ol><li><p><strong>页（page）：</strong></p><p>InnoDB的数据是按照页的单位进行读写，默认每个页的大小为16KB</p></li><li><p><strong>区（extent）：</strong></p><p>当表中的数据量较大时，按照区为单位进行空间分配，每个区的大小为1MB</p></li><li><p><strong>段（segment）：</strong></p><ul><li>索引段：存放B+树的非叶子节点的集合</li><li>数据段：存放B+树叶子节点的集合</li><li>回滚段：存放回滚数据区的集合，MVCC就是利用了回滚段实现查询数据</li></ul></li></ol><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>Compact（5.1版本后使用）Dynamic和Compressed（5.5版本后使用）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"  /></p><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ol><li>变长字段长度列表：存储varchar的真实数据占用的字节数</li><li>NULL值列表：需要用整数个字节的位表示，也是逆序存放，列数不足整数个字节，高位补0<ul><li>二进制位的值为1，该列的值不为NULL</li><li>二进制位的值为0，该列的值为NULL</li></ul></li><li>记录头信息，5字节</li></ol><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ol><li>row_id：如果指定了主键或者唯一约束列，就无row_id，如果没有指定，会添加row_id，大小为6字节</li><li>trx_id：事务的id，表明该数据是由哪个事务生成的，必需存在，6字节</li><li>roll_pointer：记录上一个版本的指针。roll_pointer是必需的，7字节</li></ol><h5 id="varchar（n）的最大取值是多少"><a href="#varchar（n）的最大取值是多少" class="headerlink" title="varchar（n）的最大取值是多少"></a>varchar（n）的最大取值是多少</h5><p>MySQL规定所有列的字节长度不能超过65535个字节</p><p>1字节NULL值列表，2字节的变长字段长度列表</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>B+树索引，Hash索引，Full-Text索引</p><div class="table-container"><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Full-Text索引</td><td>Yes</td><td>Yes</td><td>No</td></tr></tbody></table></div><h5 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h5><ol><li>B+树和B树：<ul><li>B+树只有在叶子节点存储数据，B树的非叶子节点也存储数据</li><li>B+树采用双链表结构，可以使用基于范围的顺序查找</li><li>B+树的搜索更加稳定，必须要搜索到叶子节点</li></ul></li><li>B+树和二叉树<ul><li>B+树的高度一般在3~4层，二叉树的高度太高，因此B+树所进行的磁盘I/O操作比较少</li></ul></li><li>B+树和Hash索引<ul><li>Hash索引在等值查询时比较快，但是不适合进行范围查询</li></ul></li></ol><h4 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h4><p>聚簇索引（主键索引）和二级索引（辅助索引）</p><ul><li>聚簇索引：B+树的叶子节点存放的是实际数据</li><li>二级索引：B+树的叶子节点存放的是主键值而不是实际数据</li></ul><h4 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h4><p>主键索引、唯一索引、普通索引、前缀索引</p><ul><li>主键索引：创建表时，将主键字段作为主键索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>唯一索引：建立在唯一字段上的索引，一个表可以有多个唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> <span class="keyword">unique</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> INDEX [索引名] <span class="keyword">ON</span> [表名] (表的列名)</span><br></pre></td></tr></table></figure><ul><li>普通索引：建立在普通字段上的索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><ul><li>前缀索引：建立在字段类型为char、varchar、binary、varbinary列上，使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h4 id="按照字段个数分类"><a href="#按照字段个数分类" class="headerlink" title="按照字段个数分类"></a>按照字段个数分类</h4><p>单列索引、联合索引（复合索引）</p><p>联合索引：将多个字段组合成一个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>在联合索引的遍历过程中，对联合索引所包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><h5 id="索引区分度（区分度-column字段的不同值的个数-表的总行数）"><a href="#索引区分度（区分度-column字段的不同值的个数-表的总行数）" class="headerlink" title="索引区分度（区分度=column字段的不同值的个数/表的总行数）"></a>索引区分度（区分度=column字段的不同值的个数/表的总行数）</h5><p>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到</p><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="需要创建索引的情况"><a href="#需要创建索引的情况" class="headerlink" title="需要创建索引的情况"></a>需要创建索引的情况</h4><ul><li>字段有唯一性限制</li><li>经常在<code>WHERE</code>查询条件的字段，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段，这样在查询时不需要再去排序</li></ul><h4 id="不需要创建索引的情况"><a href="#不需要创建索引的情况" class="headerlink" title="不需要创建索引的情况"></a>不需要创建索引的情况</h4><ul><li><code>WHERE</code>,<code>GROUP BY</code>,<code>ORDER BY</code>里面用不到的字段</li><li>字段中存在大量的重复数据，如果某个值出现在表中的数据行的百分比很高时，一般会忽略索引，进行全表扫描（一般查询的结果集超过了总行数的25%，就没必要走索引了）</li><li>表数据太少</li><li>经常更新的字段不需要创建索引，电商项目的用户余额</li></ul><h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h3><ul><li>前缀索引优化：目的是减少索引字段的大小</li><li>覆盖索引优化：所查询的列在索引表中直接找到，避免回表</li><li>主键索引最好是自增的：插入新记录的时候不需要重新移动数据</li><li>索引最好是NOT NULL：null导致优化器做索引选择时比较复杂，此外null会导致产生NULL值列表</li></ul><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul><li>使用左或者左右模糊匹配，<code>like %XX</code>或者<code>like %xx%</code></li><li>在查询条件中对索引列进行了函数，计算，隐式类型转换</li><li>联合索引不遵循最左匹配原则</li><li>WHERE子句中OR前面使用索引，后面不使用索引，前面索引失效</li></ul><h3 id="面试额外问题"><a href="#面试额外问题" class="headerlink" title="面试额外问题"></a>面试额外问题</h3><h4 id="MySQL单表不要超过2000W行么？"><a href="#MySQL单表不要超过2000W行么？" class="headerlink" title="MySQL单表不要超过2000W行么？"></a>MySQL单表不要超过2000W行么？</h4><p>索引结构不会影响单表最大行数，2000W也只是推荐值，超过这个值会导致B+树的层级过高，影响查询的性能</p><h4 id="MySQL使用like-“-x”，索引一定失效么"><a href="#MySQL使用like-“-x”，索引一定失效么" class="headerlink" title="MySQL使用like “%x”，索引一定失效么"></a>MySQL使用like “%x”，索引一定失效么</h4><p>不一定，如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，会走全扫描二级索引树（type=index）</p><h4 id="count的性能"><a href="#count的性能" class="headerlink" title="count的性能"></a>count的性能</h4><p>count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</p><p>count(1)：表示1这个表达式不为NULL的记录有多少个，其实就是统计表中有多少个记录，此外读取记录时不会读取任何的字段值</p><p>count(*) = count(1) &gt; count(主键字段) 在执行时，如果表中存在二级索引，优化器会选择使用二级索引进行扫描</p><h5 id="大表count-的优化"><a href="#大表count-的优化" class="headerlink" title="大表count(*)的优化"></a>大表count(*)的优化</h5><ol><li>近似值：使用show table status 或者 explain命令来估算</li><li>使用额外表来保存计数值</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>A-原子性：事务是最小的执行单位，不允许分割，要么全部完成，要么全部不完成（利用undo log 来保证）</li><li>I-隔离性：并发访问数据库，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的（锁机制和MVCC来保证）</li><li>D-持久性：事务处理结束后，对数据的修改是永久的，系统故障也不会丢失（利用redo log 来保证）</li><li>C-一致性：事务操作前和操作后，数据保持一致</li></ul><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读取另一个事务未提交的数据，并且另一个事务进行了回滚操作</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片" style="zoom:80%;" /></p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>A读取数据，B也读取数据，A先修改，B后修改，A的修改被丢失</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务多次读取同一个数据，另一个事务将数据进行了修改，该事务两次读取的数据不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:80%;" /></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取某个范围的数据，另一个事务插入数据，该事务所读取的范围不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交，指一个事务没有提交时，它做的变更就能够让其他事务所读取</li><li>读已提交，允许读取并发事务已经提交的数据</li><li>可重复读，一个事务在执行过程中看到的数据跟这个事务启动时看到的数据时一致的</li><li>串行化，会对记录加上读写锁，最高的隔离级别</li></ul><p>各个隔离级别所克服的问题</p><ul><li><p>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</p></li><li><p>在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</p></li><li><p>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</p></li><li><p>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</p></li></ul><p>MySQL的默认隔离级别是<code>可重复读</code>，但是很大程度上解决了幻读现象，解决方案为：</p><ul><li>针对快照读(select 语句)，通过MVCC方式解决幻读</li><li>针对当前读(select … for update 等语句)，通过锁（next-key lock）的方式解决幻读</li></ul><h3 id="MVCC（多版本并发控制的实现）"><a href="#MVCC（多版本并发控制的实现）" class="headerlink" title="MVCC（多版本并发控制的实现）"></a>MVCC（多版本并发控制的实现）</h3><p>MVCC通过Read View、undo log、隐藏字段中的 trx_id（最后一次更新该记录的事务id）和 roll_pointer（指向旧版本的记录）来实现的</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:80%;" /></p><p>整个记录的示意图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:80%;" /></p><p>在创建Read View 后，记录中的trx_id被划分为三种情况：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:80%;" /></p><ol><li>记录的 trx_id 小于 Read View中的<code>min_trx_id</code>的值，表示该版本的记录是在创建Read View前已经提交的事务生成的，所以该版本的记录对当前事务可见</li><li>记录的 trx_id 大于 Read View中的<code>max_trx_id</code>的值，表示该版本的记录是在创建Read View后才启动的事务所生成的，因此该版本的记录不可见</li><li>如果记录的 trx_id 在 Read View的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在m_ids 列表中：<ul><li>如果在<code>m_ids</code>列表中，说明生成该版本的事务还未提交，因此该版本的记录<strong>不可见</strong></li><li>如果不在<code>m_ids</code>列表中，说明生成该版本的事务已被提交，因此该版本的记录<strong>可见</strong></li></ul></li></ol><p>如果当前记录的版本对当前事务不可见，那么事务会沿着undo log的链条，利用roll_pointer寻找旧版本的记录，找到符合Read View版本的记录</p><h3 id="MySQL完全解决幻读了么？"><a href="#MySQL完全解决幻读了么？" class="headerlink" title="MySQL完全解决幻读了么？"></a>MySQL完全解决幻读了么？</h3><p>没有</p><ol><li>当事务A查询记录不存在，但是它更新这条记录，就会看到另一个事务所插入的数据</li><li>A事务快照读，B事务插入一个数据并且提交，A事务在进行当前读，发现读取到了B事务提交的数据，发生了幻读</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h3><ol><li><p>全局锁：整个数据库只有只读状态</p></li><li><p>表级锁：</p><ul><li><p>表锁：读锁和写锁</p></li><li><p>元数据锁：MDL读锁和MDL写锁，对表执行CRUD操作时，防止其他线程对这个表结构做变更</p></li><li><p>意向锁：意向共享锁和意向独占锁时表级锁，会与表锁发生冲突，不会与行级锁发生冲突</p><p>表锁和行锁满足：读读共享，读写互斥，写写互斥</p></li><li><p>AUTO-INC锁：不指定主键值时，自增给主键赋值</p></li></ul></li><li><p>行级锁：</p><ul><li>Record Lock，记录锁，锁住一条记录，记录锁有S锁（共享锁）和X锁（读写锁）之分</li><li>Gap Lock，间隙锁，锁定一个范围，不包含记录本身，两个事务之间的间隙锁互相兼容</li><li>Next-Key Lock，临键锁，记录锁+间隙锁</li></ul></li></ol><h3 id="MySQL加锁过程"><a href="#MySQL加锁过程" class="headerlink" title="MySQL加锁过程"></a>MySQL加锁过程</h3><p>MySQL加锁过程</p><ol><li>原则：<ul><li>前开后闭区间，基本单位，next-key lock</li><li>查找过程中访问到的对象才能加锁</li></ul></li><li>优化1：索引上的等值查询，给唯一索引加锁时，临键锁退化成记录锁</li><li>优化2：索引上的等值查询，没访问到时，向右遍历时且最后一个值不满足等值条件时，退化为间隙锁</li><li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul><li>当查询的记录<strong>存在</strong>，临键锁会退化成记录锁</li><li>当查询的记录<strong>不存在</strong>，临键锁退化成间隙锁，查找id=2的例子如下：</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%B4%E9%9A%99%E9%94%81.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><ul><li>查询范围{大于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&gt;15的例子如下，如果是id&gt;=15，那么id=15的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E15.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>查询范围{小于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&lt;5的例子如下，如果是id&lt;=15，那么id=5的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E5.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h4><p>当进行等值查询时，不仅为唯一索引加锁，还要对主键索引加锁，但是只对符合查询条件的主键索引加记录锁</p><ul><li>当查询记录{存在}，间隙锁加临键锁，并且给主键索引加记录锁，例如查找age=22的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>当查询记录{不存在}，只加间隙锁，例如查找age=25的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h4><p>所使用的索引所加的锁都是next-key lock，不会退化成间隙锁或记录锁，符合查询条件的主键索引都加入记录锁</p><p>例如查询 age&gt;=22的例子如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h4><p>如果没有走索引，就会走全表扫描，对全表的记录都加锁</p><p>可以开启安全更新模式，将<code>sql_safe_updates</code>设置为1</p><h3 id="记录锁-间隙锁可以防止删除操作而导致的幻读么"><a href="#记录锁-间隙锁可以防止删除操作而导致的幻读么" class="headerlink" title="记录锁+间隙锁可以防止删除操作而导致的幻读么"></a>记录锁+间隙锁可以防止删除操作而导致的幻读么</h3><p>可以</p><h3 id="MySQL-死锁了怎么办"><a href="#MySQL-死锁了怎么办" class="headerlink" title="MySQL 死锁了怎么办"></a>MySQL 死锁了怎么办</h3><p>死锁需要四种必要条件：互斥，持有并等待，不能抢占，循环等待</p><p>MySQL有两种策略来{打破循环等待}：</p><ul><li>设置事务等待锁的超时时间：默认50秒，超时后事务主动回滚，锁释放</li><li>开启主动死锁检测：发现死锁后，主动回滚死锁链条中的某一个事务</li></ul><h3 id="导致死锁的原因"><a href="#导致死锁的原因" class="headerlink" title="导致死锁的原因"></a>导致死锁的原因</h3><p>一般为A和B事务都加入了间隙锁，因为间隙锁相互兼容，下一步的插入需要获取插入意向锁就互相等待了</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h3><ul><li>插入时，记录主键值，回滚时则删除主键对应记录</li><li>删除时，记录这条记录的所有内容，回滚时，将内容组成的记录插入回表中</li><li>更新时，记录被更新列的旧值，回滚时，更新回旧值</li></ul><h4 id="undo-log-什么时候刷盘的（持久化到磁盘）"><a href="#undo-log-什么时候刷盘的（持久化到磁盘）" class="headerlink" title="undo log 什么时候刷盘的（持久化到磁盘）"></a>undo log 什么时候刷盘的（持久化到磁盘）</h4><p>undo log和数据页的刷盘策略一样，都是通过redo log来保证持久化</p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>InnoDB存储引擎设计了缓冲池（Buffer Pool）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><ul><li>当读取数据时，如果数据存在缓冲池中，客户端回直接读取缓冲池中的数据</li><li>当修改数据时，如果数据存在缓冲池中，将数据所在页标记为脏页，脏页不会立即写入磁盘，而是寻找合适机会再写入</li></ul><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h3><p>因为Buffer Pool是基于内存的，万一断电重启，脏页数据就会丢失</p><p>为了防止上述问题，当一条记录需要更新的时候，存储引擎会先更新内存（同时标记为脏页），然后将本次修改以redo log的形式记录下来</p><p>WAL技术：写操作不是立即写到磁盘上，而是先写日志，然后寻找合适的时间再写入到磁盘中</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><h4 id="redo-log的具体操作"><a href="#redo-log的具体操作" class="headerlink" title="redo log的具体操作"></a>redo log的具体操作</h4><p>redo log是物理页，记录某个数据页做了什么修改，在事务提交时，先将redo log 持久化到磁盘中</p><p>redo log使用的好处：</p><ol><li>实现事务的持久性，让MySQL有了崩溃恢复的能力</li><li>将写操作从{随机写}变成{顺序写}，提高了MySQL写入磁盘的性能</li></ol><p>但是redo log 不是直接写入磁盘，而是通过自己的缓存 redo log buffer 持久化到磁盘</p><h4 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h4><ul><li>MySQL正常关闭时</li><li>redo log buffer 中的写入量大于redo log buffer内存空间的一半时</li><li>后台线程每隔1s，就将redo log buffer 持久化到磁盘（崩溃可能会丢失1秒事务的数据）</li><li>每次事务提交时，都将缓存在redo log buffer 的redo log 持久化到磁盘</li></ul><h4 id="redo-log日志满了怎么办"><a href="#redo-log日志满了怎么办" class="headerlink" title="redo log日志满了怎么办"></a>redo log日志满了怎么办</h4><p>redo log日志满了，MySQL不会执行新的更新操作，会被阻塞（并发量大的系统，需要设置适当的redo log的大小），引擎会标记干净页，对旧的redo log记录进行擦除</p><h3 id="bin-log日志"><a href="#bin-log日志" class="headerlink" title="bin log日志"></a>bin log日志</h3><p>是MySQL在Server层实现的日志，所有的存储引擎都可以使用</p><h4 id="redo-log-和-bin-log的区别"><a href="#redo-log-和-bin-log的区别" class="headerlink" title="redo log 和 bin log的区别"></a>redo log 和 bin log的区别</h4><div class="table-container"><table><thead><tr><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>InnoDB存储引擎实现的日志</td><td>MySQL的Server层实现的日志，所有引擎都可以使用</td></tr><tr><td>物理日志</td><td>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中</td></tr><tr><td>循环写</td><td>追加写，写满一个文件，会创建一个新的文件</td></tr><tr><td>用于故障恢复</td><td>备份恢复和主从复制</td></tr></tbody></table></div><h4 id="bin-log的刷盘时机"><a href="#bin-log的刷盘时机" class="headerlink" title="bin log的刷盘时机"></a>bin log的刷盘时机</h4><p>事务执行过程中，先把日志写到 bin log cache（Server 层的 cache），事务提交的时候，再把 bin log cache 写到 bin log 文件中。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的过程："><a href="#主从复制的过程：" class="headerlink" title="主从复制的过程："></a>主从复制的过程：</h4><ol><li><p>写入bin log：</p><p>主库收到客户端提交的事务请求后，写入bin log，提交事务，更新本地存储数据</p></li><li><p>同步bin log：</p><p>从库创建专门的I/O线程，连接主控的log dump线程，接受主库的bin log日志，再把日志写入到relay log暂存日志中，返回复制成功的响应</p></li><li><p>回放bin log：</p><p>从库创建一个回访bin log的线程，读取relay log暂存日志，回放bin log中的更新存储引擎中的数据，实现主从一致性</p></li></ol><p>一般写操作在主库中，读操作在从库中，一般从库2个，备份库一个</p><h4 id="主从复制的模型"><a href="#主从复制的模型" class="headerlink" title="主从复制的模型"></a>主从复制的模型</h4><ul><li>同步复制：所有从库都复制成功返回响应才完成线程</li><li>异步复制：不会等待bin log 同步到各从库，就返回客户端的结果，当主库宕机，数据就会丢失</li><li>半同步复制：不需要等待所有从库都返回响应，只需要一个从库响应就可以</li></ul><h3 id="两阶段提交的意义"><a href="#两阶段提交的意义" class="headerlink" title="两阶段提交的意义"></a>两阶段提交的意义</h3><h2 id="MySQL的优化"><a href="#MySQL的优化" class="headerlink" title="MySQL的优化"></a>MySQL的优化</h2><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>数据库对象名称必须使用小写字母并用下划线分割</li><li>数据库名称禁止使用MySQL的保留关键字</li><li>临时库表必须以<code>tem_</code>为前缀，日期为后缀，备份表必须以<code>bak_</code>为前缀，日期为后缀</li><li>所有存储相同数据的列名和列类型必须一致，防止出现隐式类型转换</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><ul><li>所有表使用InnoDB存储引擎</li><li>库和表的字符集统一使用UTF8，如果存储emoji表情，采用utf8mb4字符集</li><li>表和字段需要添加注释</li><li>尽量控制单表的数据量的大小，一般是500万以内，多了就需要分库分表</li><li>经常使用的列放到一个表中</li><li>禁止建立预留字段</li><li>禁止在数据库中存储文件（图片或者视频音频）这类的大的二进制数据，一般这类数据存储于文件服务器中，数据库只存储文件地址信息</li></ul><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><ul><li>优先选择符合存储需要的最小的数据类型</li><li>对于非负型的数据，使用无符号的整型来存储</li><li>小数值类型使用TINYINT类型</li><li>尽可能把所有的列都定义为NOT NULL</li><li>使用TIMESTAMP或者DATETIME类型来存储时间</li><li>使用DECIMAL类型来存储金额类数据</li></ul><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><ul><li>限制单表索引数量，建议单表索引数量不超过5个</li><li>禁止给表中的每一类都建立索引，因为可以使用联合索引</li><li>每个表中都需要主键</li><li>将WHERE，ORDER BY，GROUP BY，DISTINCT中的字段建立索引，或者将多表join的关联列建立索引</li><li><p>避免建立冗余索引和重复索引，例如index（a,b,c）、index(a,b)</p></li><li><p>对频繁的查询优先考虑覆盖索引</p></li><li><p><strong>避免使用外键约束，数据的关联性在业务端实现，需要在表与表之间的关联键上建立索引</strong></p></li></ul><h3 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h3><ul><li>优化对性能影响较大的SQL语句，利用慢查询日志，EXPLAIN</li><li>避免使用select *，无法走覆盖索引</li><li>禁止使用不包含字段列表的INSERT语句</li><li><strong>使用预编译语句进行数据库的操作</strong></li><li>避免数据类型的隐式转换</li><li><strong>避免使用子查询，把子查询优化为join操作</strong></li><li>避免使用JOIN关联太多的表，建议不超过五个</li><li>将批量操作代替单次操作</li><li>将in代替or，or有时候不会走索引</li><li>禁止使用order by rand()进行随机排序</li><li>在明显不会有重复值时使用UNION ALL 而不是 UNION，因为UNION会去重，影响效率</li><li>禁止跨库查询</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><ul><li><p>避免大批量的写操作，要分批多次进行操作</p></li><li><p>对于打包使用pt-online-schema-change来修改表结构</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a><br><a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
