<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java多线程</title>
      <link href="/mingyry/a2c3ad19.html"/>
      <url>/mingyry/a2c3ad19.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p> <code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值</strong></p><blockquote><p>ThreadLocal原理</p></blockquote><p><strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/threadlocal-data-structure.png" alt="ThreadLocal 数据结构"></p><blockquote><p>ThreadLocal 内存泄露问题是怎么导致的？</p></blockquote><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。</p><p>使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p>阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">    <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">        <span class="comment">//执行Runnable</span></span><br><span class="line">        executor.execute(worker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ul><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ul><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="为什么不推荐使用内置线程池？"><a href="#为什么不推荐使用内置线程池？" class="headerlink" title="为什么不推荐使用内置线程池？"></a>为什么不推荐使用内置线程池？</h3><p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h3 id="线程池常见参数有哪些？"><a href="#线程池常见参数有哪些？" class="headerlink" title="线程池常见参数有哪些？"></a>线程池常见参数有哪些？</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421150646803.png" alt="image-20230421150646803"></p><h3 id="线程池的饱和策略有哪些？"><a href="#线程池的饱和策略有哪些？" class="headerlink" title="线程池的饱和策略有哪些？"></a>线程池的饱和策略有哪些？</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li><p>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（有界阻塞队列）：此队列按照先进先出的原则对元素进行排序。<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p><p>在使用时需要定义队列的容量<code>new LinkedBlockingQueue(capacity)</code></p></li><li><p><code>SynchronousQueue</code>（同步队列） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</p><p>队列本身并不存储任何元素，非常适合于传递性场景, 比如在一个线程中使用的数据，传递给另外一个线程使用，<code>`SynchronousQueue</code> 的吞吐量高于 <code>LinkedBlockingQueue</code> 和 <code>ArrayBlockingQueue</code>。</p></li></ul><ul><li><p><code>DelayedWorkQueue</code>（延迟无界阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</p></li><li><p><code>ArrayBlockingQueue</code> 一个由<strong>数组</strong>实现的<strong>有界</strong>阻塞队列。该队列采用先进先出（FIFO）的原则对元素进行排序添加的。</p><p><code>ArrayBlockingQueue</code> 为<strong>有界且固定</strong>，其大小在构造时由构造函数来决定，确认之后就不能再改变了</p></li><li><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排列。也可以自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。</p></li></ul><h4 id="阻塞队列的对比"><a href="#阻塞队列的对比" class="headerlink" title="阻塞队列的对比"></a>阻塞队列的对比</h4><h5 id="LinkedBlockingQueue-与-ArrayBlockingQueue-对比"><a href="#LinkedBlockingQueue-与-ArrayBlockingQueue-对比" class="headerlink" title="LinkedBlockingQueue 与 ArrayBlockingQueue 对比"></a>LinkedBlockingQueue 与 ArrayBlockingQueue 对比</h5><ul><li>ArrayBlockingQueue 入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</li><li>LinkedBlockingQueue 入队出队采用两把锁，入队出队互不干扰，效率较高；</li><li>二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；</li><li>LinkedBlockingQueue 如果初始化不传入初始容量，则使用最大 int 值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</li></ul><h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421150928160.png" alt="image-20230421150928160"></p><ol><li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p></li><li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p></li><li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p></li></ol><h3 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h3><ul><li><p>如果我们设置的线程池数量太小的话，如果<strong>同一时间有大量任务/请求需要处理</strong>，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至<strong>会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM</strong>。这样很明显是有问题的，CPU 根本没有得到充分利用。</p></li><li><p>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致<strong>大量的上下文切换，从而增加线程的执行时间</strong>，影响了整体执行效率。</p></li></ul><h4 id="CPU-密集任务还是-IO-密集任务"><a href="#CPU-密集任务还是-IO-密集任务" class="headerlink" title="CPU 密集任务还是 IO 密集任务"></a>CPU 密集任务还是 IO 密集任务</h4><ul><li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li><p><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p></li></ul><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。</p><p> IO 密集型就是进行网络读取，文件读取等任务</p><h3 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h3><p> <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/threadpoolexecutor-methods.png" alt="img"></p><p>上面并没有动态指定队列长度的方法，我们需要自定义长度的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p><h3 id="几个常见的对比"><a href="#几个常见的对比" class="headerlink" title="几个常见的对比"></a>几个常见的对比</h3><h4 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a><code>Runnable</code> vs <code>Callable</code></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a><code>execute()</code> vs <code>submit()</code></h4><ul><li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</li></ul><h4 id="shutdown-VSshutdownNow"><a href="#shutdown-VSshutdownNow" class="headerlink" title="shutdown()VSshutdownNow()"></a><code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a><code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="内置线程池介绍"><a href="#内置线程池介绍" class="headerlink" title="内置线程池介绍"></a>内置线程池介绍</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                              <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 <code>nThreads</code>，这个 <code>nThreads</code> 参数是我们使用的时候自己传递的。</p><p><code>FixedThreadPool</code> 使用的是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列），队列永远不会被放满。</p><blockquote><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/FixedThreadPool.f8172448.png" alt="FixedThreadPool的execute()方法运行示意图" style="zoom:80%;" /></p><blockquote><p>为什么不推荐使用<code>FixedThreadPool</code>？</p></blockquote><p><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 <code>corePoolSize</code>；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">         (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1，其他参数和 <code>FixedThreadPool</code> 相同。</p><blockquote><p><code>SingleThreadExecutor</code> 的运行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/SingleThreadExecutor.7ffd92c2.png" alt="SingleThreadExecutor的运行示意图"></p><blockquote><p>为什么不推荐使用<code>SingleThreadExecutor</code>？</p></blockquote><p><code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 一样，使用的都是容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）作为线程池的工作队列。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点，就是可能会导致 OOM。</p><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><blockquote><p><code>CachedThreadPool</code> 的 <code>execute()</code> 方法的执行示意图</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/CachedThreadPool-execute.97103fbe.png" alt="CachedThreadPool的execute()方法的执行示意图" style="zoom:80%;" /></p><h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><p><code>ScheduledThreadPool</code> 用来在给定的延迟后运行任务或者定期执行任务。这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下即可。</p><p><code>ScheduledThreadPool</code> 是通过 <code>ScheduledThreadPoolExecutor</code> 创建的，使用的<code>DelayedWorkQueue</code>（延迟阻塞队列）作为线程池的任务队列。</p><p><code>ScheduledThreadPoolExecutor</code> 继承了 <code>ThreadPoolExecutor</code>，所以创建 <code>ScheduledThreadExecutor</code> 本质也是创建一个 <code>ThreadPoolExecutor</code> 线程池，只是传入的参数不相同。</p><h3 id="线程池的实战"><a href="#线程池的实战" class="headerlink" title="线程池的实战"></a>线程池的实战</h3><h4 id="1、正确声明线程池"><a href="#1、正确声明线程池" class="headerlink" title="1、正确声明线程池"></a>1、正确声明线程池</h4><p><strong>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code> 类创建线程池，会有 OOM 风险。</strong></p><p><strong>使用有界队列，控制线程创建数量。</strong></p><p>避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p><ul><li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li><li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li></ul><h4 id="2、监测线程池运行状态"><a href="#2、监测线程池运行状态" class="headerlink" title="2、监测线程池运行状态"></a>2、监测线程池运行状态</h4><p>可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。</p><h4 id="3、建议不同类别的业务用不同的线程池"><a href="#3、建议不同类别的业务用不同的线程池" class="headerlink" title="3、建议不同类别的业务用不同的线程池"></a>3、建议不同类别的业务用不同的线程池</h4><p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p><p>真实案例，本案例来源自：<a href="https://club.perfma.com/article/646639">《线程池运用不当的一次线上事故》</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/production-accident-threadpool-sharing-example.png" alt="案例代码概览" style="zoom:80%;" /></p><p>上面的代码可能会存在死锁的情况</p><p>假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 <strong>“死锁”</strong>。</p><h4 id="4、别忘记给线程池命名"><a href="#4、别忘记给线程池命名" class="headerlink" title="4、别忘记给线程池命名"></a>4、别忘记给线程池命名</h4><p>线程池里的线程命名通常有下面两种方式：</p><ul><li><strong>利用 guava 的 <code>ThreadFactoryBuilder</code></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure><ul><li><strong>自己实现 <code>ThreadFactor</code></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">          <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">       t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、正确配置线程池参数"><a href="#5、正确配置线程池参数" class="headerlink" title="5、正确配置线程池参数"></a>5、正确配置线程池参数</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p>主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><h4 id="6、线程池使用的一些小坑"><a href="#6、线程池使用的一些小坑" class="headerlink" title="6、线程池使用的一些小坑"></a>6、线程池使用的一些小坑</h4><ul><li>线程池是可以复用的，一定不要频繁创建线程池比如一个用户请求到了就单独创建一个线程池。</li><li>使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。</li><li>线程池和 <code>ThreadLocal</code>共用，可能会导致线程从<code>ThreadLocal</code>获取到的是旧值/脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a><br><a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519</a></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+butterfly博客搭建过程中的问题</title>
      <link href="/mingyry/8ff17a6a.html"/>
      <url>/mingyry/8ff17a6a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简单且功能强大的博客框架。支持Markdown（或其他标记语言）写帖子，Hexo 会在几秒钟内生成带有漂亮主题的静态文件。</p><h2 id="每个目录下的网页设置"><a href="#每个目录下的网页设置" class="headerlink" title="每个目录下的网页设置"></a>每个目录下的网页设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm new page [对应目录的名字]</span><br></pre></td></tr></table></figure><p>会在对应的目录下生成一个index.md文件，但是要<strong>注意不要在archives目录下生成文件</strong>(看到其他博文中说的)</p><p>然后针对每个目录下的index.md，可以设置图片等等操作</p><p>这是index页面可以设置的属性</p><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title:   【必需】页面标题</span><br><span class="line">date:    【必需】页面创建日期</span><br><span class="line">updated:  【可选】页面更新日期</span><br><span class="line">type:【必需】标签、分类和友情链接三个页面需要配置(就是你设置的标签，分类，友链目录的名字)</span><br><span class="line">comments:【可选】显示页面评论模块(默认 true)</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords:【可选】页面关键字</span><br><span class="line">top_img:【可选】页面顶部图片</span><br><span class="line">mathjax:【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span><br><span class="line">katex:【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</span><br><span class="line">aside:【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer:【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink:【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</span><br></pre></td></tr></table></figure><p>留言板页面只需要写上内容，然后开启评论即可</p><p>音乐界面只需要关闭评论，并且将aplayer设置为true</p><h2 id="音乐盒的设置"><a href="#音乐盒的设置" class="headerlink" title="音乐盒的设置"></a>音乐盒的设置</h2><p>使用方法请参考插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">hexo-tag-aplayer</a> </p><p>本博客使用的是MeingJS，主要比较简单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;!--</span> <span class="string">简单示例</span> <span class="string">(id,</span> <span class="string">server,</span> <span class="string">type)</span>  <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">%</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">进阶示例</span> <span class="string">--&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">meting</span> <span class="string">&quot;60198&quot;</span> <span class="string">&quot;netease&quot;</span> <span class="string">&quot;playlist&quot;</span> <span class="string">&quot;autoplay&quot;</span> <span class="string">&quot;mutex:false&quot;</span> <span class="string">&quot;listmaxheight:340px&quot;</span> <span class="string">&quot;preload:none&quot;</span> <span class="string">&quot;theme:#ad7a86&quot;</span><span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure><p>有关 <code>&#123;% meting %&#125;</code> 的选项列表如下:</p><div class="table-container"><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table></div><p>如何获取网易云的id呢，需要上网页版的网易云音乐</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417110339346.png" alt="image-20230417110339346"></p><p>可以看到地址栏中出现了id和playlist，把这两个替换到对应的选项中即可</p><p>然后音乐平台选择netease</p><p>如果要是放单曲，则只需要song和对应的id即可</p><h3 id="全局aplayer的设置"><a href="#全局aplayer的设置" class="headerlink" title="全局aplayer的设置"></a>全局aplayer的设置</h3><p>如何添加全局 Aplayer 播放，请参考 <a href="https://butterfly.js.org/posts/507c070f/">这篇文章</a></p><h2 id="valine-评论设置"><a href="#valine-评论设置" class="headerlink" title="valine 评论设置"></a>valine 评论设置</h2><h3 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h3><p>如何快速开始Valiee 请参考 <a href="https://valine.js.org/quickstart.html">这篇文章</a></p><p>我们可以针对Valine进行魔改，增加他的一些功能</p><h3 id="魔改版"><a href="#魔改版" class="headerlink" title="魔改版"></a>魔改版</h3><p>首先要下载Valine.min.js文件  <a href="https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js">https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js</a></p><p>替换掉<code>themes/butterfly/source/js/Valine.min.js</code>原生 <code>js</code> 文件(如果当前目录没有就创建一个)，然后在<code>_config.butterfly.yml</code>中找到valine，将其设置为我们新生成的文件位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line"><span class="attr">option:</span></span><br><span class="line">        <span class="comment"># main_css:</span></span><br><span class="line">        <span class="comment"># main:</span></span><br><span class="line">        <span class="comment"># utils:</span></span><br><span class="line">        <span class="comment"># translate:</span></span><br><span class="line">        <span class="comment"># local_search:</span></span><br><span class="line">        <span class="comment"># algolia_js:</span></span><br><span class="line">        <span class="comment"># algolia_search:</span></span><br><span class="line">        <span class="comment"># instantsearch:</span></span><br><span class="line">        <span class="comment"># docsearch_js:</span></span><br><span class="line">        <span class="comment"># docsearch_css:</span></span><br><span class="line">        <span class="comment"># pjax:</span></span><br><span class="line">        <span class="comment"># gitalk:</span></span><br><span class="line">        <span class="comment"># gitalk_css:</span></span><br><span class="line">        <span class="comment"># blueimp_md5:</span></span><br><span class="line">    <span class="attr">valine:</span> <span class="string">/js/Valine.min.js</span></span><br></pre></td></tr></table></figure><p>然后我们寻找到<code>themes/butterfly/layout/includes/third-party/comments/</code>目录下的<code>valine.pug</code>文件  打开文件，寻找到下面的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadValine</span> () &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">initValine</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> valine = <span class="keyword">new</span> <span class="title class_">Valine</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">      <span class="attr">el</span>: <span class="string">&#x27;#vcomment&#x27;</span>,</span><br><span class="line">      <span class="attr">appId</span>: <span class="string">&#x27;#&#123;theme.valine.appId&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">appKey</span>: <span class="string">&#x27;#&#123;theme.valine.appKey&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">placeholder</span>: <span class="string">&#x27;#&#123;theme.valine.placeholder&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">avatar</span>: <span class="string">&#x27;#&#123;theme.valine.avatar&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">serverURLs</span>: <span class="string">&#x27;#&#123;theme.valine.serverURLs&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">emojiMaps</span>: !&#123;emojiMaps&#125;,</span><br><span class="line">      <span class="attr">pageSize</span>: <span class="string">&#x27;#&#123;theme.valine.pageSize&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">master</span>: <span class="string">&#x27;3451cd11a28a25de7691d4d856b929d3&#x27;</span>,   <span class="comment">//博主邮箱md5加密32位小写</span></span><br><span class="line">      <span class="attr">tagMeta</span>: [<span class="string">&quot;博主&quot;</span>, <span class="string">&quot;小伙伴&quot;</span>, <span class="string">&quot;访客&quot;</span>],     <span class="comment">//标识字段名</span></span><br><span class="line">      <span class="attr">friends</span>: [<span class="string">&#x27;b412f37e42d89e15c8aaf065934eb62e&#x27;</span>],  <span class="comment">//小伙伴邮箱Md5</span></span><br><span class="line">      <span class="attr">enableQQ</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">enableQQ</span>&#125;,</span><br><span class="line">      <span class="attr">lang</span>: <span class="string">&#x27;#&#123;theme.valine.lang&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>,</span><br><span class="line">      <span class="attr">visitor</span>: #&#123;theme.<span class="property">valine</span>.<span class="property">visitor</span>&#125;</span><br><span class="line">    &#125;, !&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(theme.<span class="property">valine</span>.<span class="property">option</span>)&#125;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外打开<code>_config.butterfly.yml</code>, 寻找到对应的valine的目录位置，针对性的进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">JnVNUuheue1XlmfbyvgSY1Oe-gzGzoHsz</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">bVRKDRonMGGQ5U4Me0xmipvT</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="string">欢迎在博客中留言！</span></span><br><span class="line">                <span class="number">1</span><span class="string">.昵称输入QQ号可以自动识别头像和QQ邮箱</span></span><br><span class="line">                <span class="number">2</span><span class="string">.博客留言中昵称和email必须填写</span></span><br><span class="line">                <span class="number">3</span><span class="string">.欢迎留下网址方便互相回访</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">https://jnvnuuhe.lc-cn-n1-shared.com</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">nick</span>, <span class="string">mail</span>]</span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>在<code>valine.pug</code>中设置之后，你再去配置<code>_config.butterfly.yml</code> valine才会生效</p><p><strong>需要注意的是</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">placeholder:</span> <span class="string">字符串中如果包含\n则valine会启动失败，页面无评论栏</span></span><br></pre></td></tr></table></figure><p>网上推荐的解决办法是加入$&10; 这个转移符合，但是我加入也失败，希望有新的解决办法</p><h2 id="博客加载优化"><a href="#博客加载优化" class="headerlink" title="博客加载优化"></a>博客加载优化</h2><p>博客优化流程，参考<a href="https://akilar.top/posts/7c16c4bb/">https://akilar.top/posts/7c16c4bb/</a></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154926819.png" alt="image-20230417154926819"></p><h3 id="第一步-利用Picgo-腾讯云来作为图床"><a href="#第一步-利用Picgo-腾讯云来作为图床" class="headerlink" title="第一步 利用Picgo+腾讯云来作为图床"></a>第一步 利用Picgo+腾讯云来作为图床</h3><p>我选择利用<a href="https://cloud.tencent.com/">腾讯云</a>来存储图片</p><p>腾讯云的COS存储会给予用户免费6个月 60个G的存储空间，但是每次读写COS Bucket都会产生额外的花费，可以购买流量包，很便宜。</p><blockquote><p>注意，如果是通过外网服务器来访问腾讯云的Bucket (例如博客部署在Github pages上)，需要额外购买外网下行流量包</p></blockquote><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153109286.png" alt="image-20230417153109286" style="zoom:80%;" /></p><p>最后就是这样都利用资源包抵扣了</p><h3 id="第二步-替换Butterfly主题中的-jsDelivr-CDN链接"><a href="#第二步-替换Butterfly主题中的-jsDelivr-CDN链接" class="headerlink" title="第二步 替换Butterfly主题中的 jsDelivr CDN链接"></a>第二步 替换Butterfly主题中的 jsDelivr CDN链接</h3><p>现在 JsDeliver已经不支持国内的访问了，很慢很慢，所以我们要替换他的链接</p><p>所以我们需要替换JsDeliver的地址，寻找到<code>themes/butterfly/_config.yml</code>中的CDN选项</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417153943597.png" alt="image-20230417153943597"></p><p>首先可以将第三方js配置成unpkg，这个访问能快一些，此外，option能够自定义主题所用到的所有的cdn</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230417154040489.png" alt="image-20230417154040489"></p><p>cdn的选择可以参考以下博客</p><p> <a href="https://blog.zhheo.com/p/790087d9.html">Butterfly CDN链接更改指南，替换jsdelivr提升访问速度</a></p><p><a href="https://anzhiy.cn/posts/fe76.html">目前可用cdn整理</a></p><blockquote><p>注意，如果存在hexo-butterfly-tag-plugins 包，里面使用了mindmap这个挂件，他是使用 JsDeliver进行访问的，需要把这个包进行卸载，npm uninstall hexo-butterfly-tag-plugins</p><p>如果出现其他的不在主题下的js文件利用 JsDeliver 进行加速，都需要卸载其对应的包，能够加快访问速度</p></blockquote><h2 id="博客访问优化"><a href="#博客访问优化" class="headerlink" title="博客访问优化"></a>博客访问优化</h2><h3 id="第一步就是项目托管到自动部署平台上"><a href="#第一步就是项目托管到自动部署平台上" class="headerlink" title="第一步就是项目托管到自动部署平台上"></a>第一步就是项目托管到自动部署平台上</h3><p><a href="https://www.netlify.com/">Netlify</a>或者<a href="https://dash.zeabur.com/">Zeabur</a>（这个是国内开发的，但是服务器还是国外的）能够部分提高访问速度</p><h3 id="第二步：国内快速访问"><a href="#第二步：国内快速访问" class="headerlink" title="第二步：国内快速访问"></a>第二步：国内快速访问</h3><h4 id="第一种-利用Cloudflare进行反向代理"><a href="#第一种-利用Cloudflare进行反向代理" class="headerlink" title="第一种 利用Cloudflare进行反向代理"></a>第一种 利用Cloudflare进行反向代理</h4><p>CloudFlare 是通过反向代理（reverse proxy）提供网站加速服务，为站长解决了 JPG / JS / CSS 这些静态文件到 CDN 上的问题，并且通过它部署在全球各大洲的缓存结点服务器</p><h4 id="第二种-直接部署在云服务器上"><a href="#第二种-直接部署在云服务器上" class="headerlink" title="第二种 直接部署在云服务器上"></a>第二种 直接部署在云服务器上</h4><p>每个云服务器都可以部署hexo，但是都需要域名进行过备案，网上教程很多</p><h4 id="第三种-利用全站CDN进行访问加速"><a href="#第三种-利用全站CDN进行访问加速" class="headerlink" title="第三种 利用全站CDN进行访问加速"></a>第三种 利用全站CDN进行访问加速</h4><p>也需要域名进行备案，此外CDN服务一般都是付费使用的</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/mingyry/c24675b4.html"/>
      <url>/mingyry/c24675b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Select语句的执行流程"><a href="#Select语句的执行流程" class="headerlink" title="Select语句的执行流程"></a>Select语句的执行流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程" style="zoom:80%;" /></p><ul><li>Server 层负责建立连接、分析和执行SQL语句</li><li>存储引擎层负责数据的存储和提取</li></ul><h4 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h4><p>进行身份认证和权限认证：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h4 id="第二步：查询缓存（8-0版本后移除）"><a href="#第二步：查询缓存（8-0版本后移除）" class="headerlink" title="第二步：查询缓存（8.0版本后移除）"></a>第二步：查询缓存（8.0版本后移除）</h4><p>执行查询语句时会先去查询缓存（Query Cache）里查找缓存，缓存是以key-value的形式存在的，如果查询到缓存，直接返回value给客户端</p><h4 id="第三步：解析器"><a href="#第三步：解析器" class="headerlink" title="第三步：解析器"></a>第三步：解析器</h4><ul><li>词法分析。根据输入的字符串构建SQL语法树</li><li>语法分析。根据语法规则，判断输入的SQL语句是否满足语法条件</li></ul><blockquote><p>这步不会去检查表是否存在或者表中的字段是否存在</p></blockquote><h4 id="第四步：执行SQL语句"><a href="#第四步：执行SQL语句" class="headerlink" title="第四步：执行SQL语句"></a>第四步：执行SQL语句</h4><h5 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h5><ul><li>检查SQL查询语句中的表或者字段是否存在</li><li>将<code>select*</code>中的<code>*</code>替换成表上的所有的列</li></ul><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>负责将SQL语句按照最优方案去执行（选择索引的方式）</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</p><h3 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h3><ol><li>使用连接器进行身份认证和权限认证</li><li>使用解析器进行词法分析（构建SQL语法树）与语法分析（判断SQL语句是否满足语法条件）</li><li>开启事务，用于失败后回滚，记录相应的undo log</li><li>执行SQL更新语句（预处理器，优化器，执行器）</li><li>准备提交事务，同时将更新的记录写入到redo log中</li><li>更新语句执行完成后，开始记录该语句对应的bin log，将bin log保存到bin cache中，在事务提交时，才会刷新到磁盘中</li><li>事务提交，采用两阶段<ul><li>prepare阶段：将redo log对应的事务状态设置为prepare，将redo log写入到磁盘中</li><li>commit阶段：将bin cache中的bin log刷新到磁盘中，事务状态设置为commit</li></ul></li><li>一条更新语句执行完成</li></ol><p>流程参考图：来源于<a href="https://www.cnblogs.com/ZhuChangwu/p/14255838.html">https://www.cnblogs.com/ZhuChangwu/p/14255838.html</a> </p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/v2-fd517a8d56ef67dad9f8d384d1a23fd4_720w.webp" alt="img"></p><h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><p>5.5版本之前使用MyISAM，5.5版本之后使用InnoDB</p><h4 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h4><div class="table-container"><table><thead><tr><th style="text-align:left">InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td style="text-align:left">支持行级锁</td><td>仅支持表级锁</td></tr><tr><td style="text-align:left">支持外键</td><td>不支持外键</td></tr><tr><td style="text-align:left">支持事务</td><td>不提供事务支持</td></tr><tr><td style="text-align:left">支持数据库崩溃后的安全恢复</td><td>不支持安全恢复</td></tr><tr><td style="text-align:left">数据文件就是索引文件</td><td>索引文件和数据文件分离</td></tr></tbody></table></div><h3 id="MySql的数据存储"><a href="#MySql的数据存储" class="headerlink" title="MySql的数据存储"></a>MySql的数据存储</h3><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><ul><li>db.opt，存储当前数据库的默认字符集和字符效验规则</li><li>*.frm，表结构的存储文件</li><li>*.ibd，表数据的存储文件，也称为表空间文件</li></ul><h4 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom: 80%;" /></p><ol><li><strong>行（row）：</strong></li></ol><p>​        数据库的记录都是按照行来存放的，每一行有不同的行格式和存储结构</p><ol><li><p><strong>页（page）：</strong></p><p>InnoDB的数据是按照页的单位进行读写，默认每个页的大小为16KB</p></li><li><p><strong>区（extent）：</strong></p><p>当表中的数据量较大时，按照区为单位进行空间分配，每个区的大小为1MB</p></li><li><p><strong>段（segment）：</strong></p><ul><li>索引段：存放B+树的非叶子节点的集合</li><li>数据段：存放B+树叶子节点的集合</li><li>回滚段：存放回滚数据区的集合，MVCC就是利用了回滚段实现查询数据</li></ul></li></ol><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>Compact（5.1版本后使用）Dynamic和Compressed（5.5版本后使用）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"  /></p><h5 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h5><ol><li>变长字段长度列表：存储varchar的真实数据占用的字节数</li><li>NULL值列表：需要用整数个字节的位表示，也是逆序存放，列数不足整数个字节，高位补0<ul><li>二进制位的值为1，该列的值不为NULL</li><li>二进制位的值为0，该列的值为NULL</li></ul></li><li>记录头信息，5字节</li></ol><h5 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h5><ol><li>row_id：如果指定了主键或者唯一约束列，就无row_id，如果没有指定，会添加row_id，大小为6字节</li><li>trx_id：事务的id，表明该数据是由哪个事务生成的，必需存在，6字节</li><li>roll_pointer：记录上一个版本的指针。roll_pointer是必需的，7字节</li></ol><h5 id="varchar（n）的最大取值是多少"><a href="#varchar（n）的最大取值是多少" class="headerlink" title="varchar（n）的最大取值是多少"></a>varchar（n）的最大取值是多少</h5><p>MySQL规定所有列的字节长度不能超过65535个字节</p><p>1字节NULL值列表，2字节的变长字段长度列表</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>B+树索引，Hash索引，Full-Text索引</p><div class="table-container"><table><thead><tr><th>索引类型</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>B+树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Hash索引</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Full-Text索引</td><td>Yes</td><td>Yes</td><td>No</td></tr></tbody></table></div><h5 id="B-树索引的优势"><a href="#B-树索引的优势" class="headerlink" title="B+树索引的优势"></a>B+树索引的优势</h5><ol><li>B+树和B树：<ul><li>B+树只有在叶子节点存储数据，B树的非叶子节点也存储数据</li><li>B+树采用双链表结构，可以使用基于范围的顺序查找</li><li>B+树的搜索更加稳定，必须要搜索到叶子节点</li></ul></li><li>B+树和二叉树<ul><li>B+树的高度一般在3~4层，二叉树的高度太高，因此B+树所进行的磁盘I/O操作比较少</li></ul></li><li>B+树和Hash索引<ul><li>Hash索引在等值查询时比较快，但是不适合进行范围查询</li></ul></li></ol><h4 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h4><p>聚簇索引（主键索引）和二级索引（辅助索引）</p><ul><li>聚簇索引：B+树的叶子节点存放的是实际数据</li><li>二级索引：B+树的叶子节点存放的是主键值而不是实际数据</li></ul><h4 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h4><p>主键索引、唯一索引、普通索引、前缀索引</p><ul><li>主键索引：创建表时，将主键字段作为主键索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>唯一索引：建立在唯一字段上的索引，一个表可以有多个唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> <span class="keyword">unique</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> INDEX [索引名] <span class="keyword">ON</span> [表名] (表的列名)</span><br></pre></td></tr></table></figure><ul><li>普通索引：建立在普通字段上的索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [表名] <span class="keyword">add</span> index [索引名] (表的列名)</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure><ul><li>前缀索引：建立在字段类型为char、varchar、binary、varbinary列上，使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure><h4 id="按照字段个数分类"><a href="#按照字段个数分类" class="headerlink" title="按照字段个数分类"></a>按照字段个数分类</h4><p>单列索引、联合索引（复合索引）</p><p>联合索引：将多个字段组合成一个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p>在联合索引的遍历过程中，对联合索引所包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><h5 id="索引区分度（区分度-column字段的不同值的个数-表的总行数）"><a href="#索引区分度（区分度-column字段的不同值的个数-表的总行数）" class="headerlink" title="索引区分度（区分度=column字段的不同值的个数/表的总行数）"></a>索引区分度（区分度=column字段的不同值的个数/表的总行数）</h5><p>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的SQL使用到</p><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="需要创建索引的情况"><a href="#需要创建索引的情况" class="headerlink" title="需要创建索引的情况"></a>需要创建索引的情况</h4><ul><li>字段有唯一性限制</li><li>经常在<code>WHERE</code>查询条件的字段，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段，这样在查询时不需要再去排序</li></ul><h4 id="不需要创建索引的情况"><a href="#不需要创建索引的情况" class="headerlink" title="不需要创建索引的情况"></a>不需要创建索引的情况</h4><ul><li><code>WHERE</code>,<code>GROUP BY</code>,<code>ORDER BY</code>里面用不到的字段</li><li>字段中存在大量的重复数据，如果某个值出现在表中的数据行的百分比很高时，一般会忽略索引，进行全表扫描（一般查询的结果集超过了总行数的25%，就没必要走索引了）</li><li>表数据太少</li><li>经常更新的字段不需要创建索引，电商项目的用户余额</li></ul><h3 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h3><ul><li>前缀索引优化：目的是减少索引字段的大小</li><li>覆盖索引优化：所查询的列在索引表中直接找到，避免回表</li><li>主键索引最好是自增的：插入新记录的时候不需要重新移动数据</li><li>索引最好是NOT NULL：null导致优化器做索引选择时比较复杂，此外null会导致产生NULL值列表</li></ul><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul><li>使用左或者左右模糊匹配，<code>like %XX</code>或者<code>like %xx%</code></li><li>在查询条件中对索引列进行了函数，计算，隐式类型转换</li><li>联合索引不遵循最左匹配原则</li><li>WHERE子句中OR前面使用索引，后面不使用索引，前面索引失效</li></ul><h3 id="面试额外问题"><a href="#面试额外问题" class="headerlink" title="面试额外问题"></a>面试额外问题</h3><h4 id="MySQL单表不要超过2000W行么？"><a href="#MySQL单表不要超过2000W行么？" class="headerlink" title="MySQL单表不要超过2000W行么？"></a>MySQL单表不要超过2000W行么？</h4><p>索引结构不会影响单表最大行数，2000W也只是推荐值，超过这个值会导致B+树的层级过高，影响查询的性能</p><h4 id="MySQL使用like-“-x”，索引一定失效么"><a href="#MySQL使用like-“-x”，索引一定失效么" class="headerlink" title="MySQL使用like “%x”，索引一定失效么"></a>MySQL使用like “%x”，索引一定失效么</h4><p>不一定，如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，会走全扫描二级索引树（type=index）</p><h4 id="count的性能"><a href="#count的性能" class="headerlink" title="count的性能"></a>count的性能</h4><p>count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</p><p>count(1)：表示1这个表达式不为NULL的记录有多少个，其实就是统计表中有多少个记录，此外读取记录时不会读取任何的字段值</p><p>count(*) = count(1) &gt; count(主键字段) 在执行时，如果表中存在二级索引，优化器会选择使用二级索引进行扫描</p><h5 id="大表count-的优化"><a href="#大表count-的优化" class="headerlink" title="大表count(*)的优化"></a>大表count(*)的优化</h5><ol><li>近似值：使用show table status 或者 explain命令来估算</li><li>使用额外表来保存计数值</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>A-原子性：事务是最小的执行单位，不允许分割，要么全部完成，要么全部不完成（利用undo log 来保证）</li><li>I-隔离性：并发访问数据库，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的（锁机制和MVCC来保证）</li><li>D-持久性：事务处理结束后，对数据的修改是永久的，系统故障也不会丢失（利用redo log 来保证）</li><li>C-一致性：事务操作前和操作后，数据保持一致</li></ul><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读取另一个事务未提交的数据，并且另一个事务进行了回滚操作</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片" style="zoom:80%;" /></p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>A读取数据，B也读取数据，A先修改，B后修改，A的修改被丢失</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务多次读取同一个数据，另一个事务将数据进行了修改，该事务两次读取的数据不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:80%;" /></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务读取某个范围的数据，另一个事务插入数据，该事务所读取的范围不一致</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>读未提交，指一个事务没有提交时，它做的变更就能够让其他事务所读取</li><li>读已提交，允许读取并发事务已经提交的数据</li><li>可重复读，一个事务在执行过程中看到的数据跟这个事务启动时看到的数据时一致的</li><li>串行化，会对记录加上读写锁，最高的隔离级别</li></ul><p>各个隔离级别所克服的问题</p><ul><li><p>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</p></li><li><p>在「读已提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</p></li><li><p>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</p></li><li><p>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</p></li></ul><p>MySQL的默认隔离级别是<code>可重复读</code>，但是很大程度上解决了幻读现象，解决方案为：</p><ul><li>针对快照读(select 语句)，通过MVCC方式解决幻读</li><li>针对当前读(select … for update 等语句)，通过锁（next-key lock）的方式解决幻读</li></ul><h3 id="MVCC（多版本并发控制的实现）"><a href="#MVCC（多版本并发控制的实现）" class="headerlink" title="MVCC（多版本并发控制的实现）"></a>MVCC（多版本并发控制的实现）</h3><p>MVCC通过Read View、undo log、隐藏字段中的 trx_id（最后一次更新该记录的事务id）和 roll_pointer（指向旧版本的记录）来实现的</p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:80%;" /></p><p>整个记录的示意图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:80%;" /></p><p>在创建Read View 后，记录中的trx_id被划分为三种情况：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="img" style="zoom:80%;" /></p><ol><li>记录的 trx_id 小于 Read View中的<code>min_trx_id</code>的值，表示该版本的记录是在创建Read View前已经提交的事务生成的，所以该版本的记录对当前事务可见</li><li>记录的 trx_id 大于 Read View中的<code>max_trx_id</code>的值，表示该版本的记录是在创建Read View后才启动的事务所生成的，因此该版本的记录不可见</li><li>如果记录的 trx_id 在 Read View的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在m_ids 列表中：<ul><li>如果在<code>m_ids</code>列表中，说明生成该版本的事务还未提交，因此该版本的记录<strong>不可见</strong></li><li>如果不在<code>m_ids</code>列表中，说明生成该版本的事务已被提交，因此该版本的记录<strong>可见</strong></li></ul></li></ol><p>如果当前记录的版本对当前事务不可见，那么事务会沿着undo log的链条，利用roll_pointer寻找旧版本的记录，找到符合Read View版本的记录</p><h3 id="MySQL完全解决幻读了么？"><a href="#MySQL完全解决幻读了么？" class="headerlink" title="MySQL完全解决幻读了么？"></a>MySQL完全解决幻读了么？</h3><p>没有</p><ol><li>当事务A查询记录不存在，但是它更新这条记录，就会看到另一个事务所插入的数据</li><li>A事务快照读，B事务插入一个数据并且提交，A事务在进行当前读，发现读取到了B事务提交的数据，发生了幻读</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h3><ol><li><p>全局锁：整个数据库只有只读状态</p></li><li><p>表级锁：</p><ul><li><p>表锁：读锁和写锁</p></li><li><p>元数据锁：MDL读锁和MDL写锁，对表执行CRUD操作时，防止其他线程对这个表结构做变更</p></li><li><p>意向锁：意向共享锁和意向独占锁时表级锁，会与表锁发生冲突，不会与行级锁发生冲突</p><p>表锁和行锁满足：读读共享，读写互斥，写写互斥</p></li><li><p>AUTO-INC锁：不指定主键值时，自增给主键赋值</p></li></ul></li><li><p>行级锁：</p><ul><li>Record Lock，记录锁，锁住一条记录，记录锁有S锁（共享锁）和X锁（读写锁）之分</li><li>Gap Lock，间隙锁，锁定一个范围，不包含记录本身，两个事务之间的间隙锁互相兼容</li><li>Next-Key Lock，临键锁，记录锁+间隙锁</li></ul></li></ol><h3 id="MySQL加锁过程"><a href="#MySQL加锁过程" class="headerlink" title="MySQL加锁过程"></a>MySQL加锁过程</h3><p>MySQL加锁过程</p><ol><li>原则：<ul><li>前开后闭区间，基本单位，next-key lock</li><li>查找过程中访问到的对象才能加锁</li></ul></li><li>优化1：索引上的等值查询，给唯一索引加锁时，临键锁退化成记录锁</li><li>优化2：索引上的等值查询，没访问到时，向右遍历时且最后一个值不满足等值条件时，退化为间隙锁</li><li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul><li>当查询的记录<strong>存在</strong>，临键锁会退化成记录锁</li><li>当查询的记录<strong>不存在</strong>，临键锁退化成间隙锁，查找id=2的例子如下：</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E9%97%B4%E9%9A%99%E9%94%81.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><ul><li>查询范围{大于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&gt;15的例子如下，如果是id&gt;=15，那么id=15的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E15.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>查询范围{小于等于}，临键锁加上临键锁，其中满足条件的记录加上记录锁，查找id&lt;5的例子如下，如果是id&lt;=5，那么id=5的记录也要加锁</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E5.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h4><p>当进行等值查询时，不仅为唯一索引加锁，还要对主键索引加锁，但是只对符合查询条件的主键索引加记录锁</p><ul><li>当查询记录{存在}，间隙锁加临键锁，并且给主键索引加记录锁，例如查找age=22的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img" style="zoom:80%;" /></p><ul><li>当查询记录{不存在}，只加间隙锁，例如查找age=25的例子如下</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h4><p>所使用的索引所加的锁都是next-key lock，不会退化成间隙锁或记录锁，符合查询条件的主键索引都加入记录锁</p><p>例如查询 age&gt;=22的例子如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E8%A1%8C%E7%BA%A7%E9%94%81/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img" style="zoom:80%;" /></p><h4 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h4><p>如果没有走索引，就会走全表扫描，对全表的记录都加锁</p><p>可以开启安全更新模式，将<code>sql_safe_updates</code>设置为1</p><h3 id="记录锁-间隙锁可以防止删除操作而导致的幻读么"><a href="#记录锁-间隙锁可以防止删除操作而导致的幻读么" class="headerlink" title="记录锁+间隙锁可以防止删除操作而导致的幻读么"></a>记录锁+间隙锁可以防止删除操作而导致的幻读么</h3><p>可以</p><h3 id="MySQL-死锁了怎么办"><a href="#MySQL-死锁了怎么办" class="headerlink" title="MySQL 死锁了怎么办"></a>MySQL 死锁了怎么办</h3><p>死锁需要四种必要条件：互斥，持有并等待，不能抢占，循环等待</p><p>MySQL有两种策略来{打破循环等待}：</p><ul><li>设置事务等待锁的超时时间：默认50秒，超时后事务主动回滚，锁释放</li><li>开启主动死锁检测：发现死锁后，主动回滚死锁链条中的某一个事务</li></ul><h3 id="导致死锁的原因"><a href="#导致死锁的原因" class="headerlink" title="导致死锁的原因"></a>导致死锁的原因</h3><p>一般为A和B事务都加入了间隙锁，因为间隙锁相互兼容，下一步的插入需要获取插入意向锁就互相等待了</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h3><ul><li>插入时，记录主键值，回滚时则删除主键对应记录</li><li>删除时，记录这条记录的所有内容，回滚时，将内容组成的记录插入回表中</li><li>更新时，记录被更新列的旧值，回滚时，更新回旧值</li></ul><h4 id="undo-log-什么时候刷盘的（持久化到磁盘）"><a href="#undo-log-什么时候刷盘的（持久化到磁盘）" class="headerlink" title="undo log 什么时候刷盘的（持久化到磁盘）"></a>undo log 什么时候刷盘的（持久化到磁盘）</h4><p>undo log和数据页的刷盘策略一样，都是通过redo log来保证持久化</p><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>InnoDB存储引擎设计了缓冲池（Buffer Pool）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><ul><li>当读取数据时，如果数据存在缓冲池中，客户端回直接读取缓冲池中的数据</li><li>当修改数据时，如果数据存在缓冲池中，将数据所在页标记为脏页，脏页不会立即写入磁盘，而是寻找合适机会再写入</li></ul><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h3><p>因为Buffer Pool是基于内存的，万一断电重启，脏页数据就会丢失</p><p>为了防止上述问题，当一条记录需要更新的时候，存储引擎会先更新内存（同时标记为脏页），然后将本次修改以redo log的形式记录下来</p><p>WAL技术：写操作不是立即写到磁盘上，而是先写日志，然后寻找合适的时间再写入到磁盘中</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img" style="zoom:80%;" /></p><h4 id="redo-log的具体操作"><a href="#redo-log的具体操作" class="headerlink" title="redo log的具体操作"></a>redo log的具体操作</h4><p>redo log是物理页，记录某个数据页做了什么修改，在事务提交时，先将redo log持久化到磁盘中</p><p>redo log使用的好处：</p><ol><li>实现事务的持久性，让MySQL有了崩溃恢复的能力</li><li>将写操作从{随机写}变成{顺序写}，提高了MySQL写入磁盘的性能</li></ol><p>但是redo log 不是直接写入磁盘，而是通过自己的缓存 redo log buffer 持久化到磁盘</p><h4 id="redo-log的刷盘时机"><a href="#redo-log的刷盘时机" class="headerlink" title="redo log的刷盘时机"></a>redo log的刷盘时机</h4><ul><li>MySQL正常关闭时</li><li>redo log buffer 中的写入量大于redo log buffer内存空间的一半时</li><li>后台线程每隔1s，就将redo log buffer 持久化到磁盘（崩溃可能会丢失1秒事务的数据）</li><li>每次事务提交时，都将缓存在redo log buffer 的redo log 持久化到磁盘</li></ul><h4 id="redo-log日志满了怎么办"><a href="#redo-log日志满了怎么办" class="headerlink" title="redo log日志满了怎么办"></a>redo log日志满了怎么办</h4><p>redo log日志满了，MySQL不会执行新的更新操作，会被阻塞（并发量大的系统，需要设置适当的redo log的大小），引擎会标记干净页，对旧的redo log记录进行擦除</p><h3 id="bin-log日志"><a href="#bin-log日志" class="headerlink" title="bin log日志"></a>bin log日志</h3><p>是MySQL在Server层实现的日志，所有的存储引擎都可以使用</p><h4 id="redo-log-和-bin-log的区别"><a href="#redo-log-和-bin-log的区别" class="headerlink" title="redo log 和 bin log的区别"></a>redo log 和 bin log的区别</h4><div class="table-container"><table><thead><tr><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>InnoDB存储引擎实现的日志</td><td>MySQL的Server层实现的日志，所有引擎都可以使用</td></tr><tr><td>物理日志</td><td>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中</td></tr><tr><td>循环写</td><td>追加写，写满一个文件，会创建一个新的文件</td></tr><tr><td>用于故障恢复</td><td>备份恢复和主从复制</td></tr></tbody></table></div><h4 id="bin-log的刷盘时机"><a href="#bin-log的刷盘时机" class="headerlink" title="bin log的刷盘时机"></a>bin log的刷盘时机</h4><p>事务执行过程中，先把日志写到 bin log cache（Server 层的 cache），事务提交的时候，再把 bin log cache 写到 bin log 文件中。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的过程："><a href="#主从复制的过程：" class="headerlink" title="主从复制的过程："></a>主从复制的过程：</h4><ol><li><p>写入bin log：</p><p>主库收到客户端提交的事务请求后，写入bin log，提交事务，更新本地存储数据</p></li><li><p>同步bin log：</p><p>从库创建专门的I/O线程，连接主控的log dump线程，接受主库的bin log日志，再把日志写入到relay log暂存日志中，返回复制成功的响应</p></li><li><p>回放bin log：</p><p>从库创建一个回放bin log的线程，读取relay log暂存日志，回放bin log中的更新存储引擎中的数据，实现主从一致性</p></li></ol><p>一般写操作在主库中，读操作在从库中，一般从库2个，备份库一个</p><h4 id="主从复制的模型"><a href="#主从复制的模型" class="headerlink" title="主从复制的模型"></a>主从复制的模型</h4><ul><li>同步复制：所有从库都复制成功返回响应才完成线程</li><li>异步复制：不会等待bin log 同步到各从库，就返回客户端的结果，当主库宕机，数据就会丢失</li><li>半同步复制：不需要等待所有从库都返回响应，只需要一个从库响应就可以</li></ul><h3 id="两阶段提交的意义"><a href="#两阶段提交的意义" class="headerlink" title="两阶段提交的意义"></a>两阶段提交的意义</h3><p>为了保证redo log和bin log数据的安全一致性。</p><p>只有在这两个日志文件逻辑上高度一致了。你才能放心地使用redo log帮你将数据库中的状态恢复成crash之前的状态，使用bin log实现数据备份、恢复、以及主从复制。而两阶段提交的机制可以保证这两个日志文件的逻辑是高度一致的。没有错误、没有冲突。</p><p><strong>两份日志文件逻辑对齐的标记是有一份相同的XID。</strong></p><p>不论mysql什么时刻crash，最终是commit还是rollback完全取决于MySQL能不能判断出binlog和redolog在逻辑上是否达成了一致。只要逻辑上达成了一致就可以commit，否则只能rollback。</p><h2 id="MySQL的优化"><a href="#MySQL的优化" class="headerlink" title="MySQL的优化"></a>MySQL的优化</h2><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>数据库对象名称必须使用小写字母并用下划线分割</li><li>数据库名称禁止使用MySQL的保留关键字</li><li>临时库表必须以<code>tem_</code>为前缀，日期为后缀，备份表必须以<code>bak_</code>为前缀，日期为后缀</li><li>所有存储相同数据的列名和列类型必须一致，防止出现隐式类型转换</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><ul><li>所有表使用InnoDB存储引擎</li><li>库和表的字符集统一使用UTF8，如果存储emoji表情，采用utf8mb4字符集</li><li>表和字段需要添加注释</li><li>尽量控制单表的数据量的大小，一般是500万以内，多了就需要分库分表</li><li>经常使用的列放到一个表中</li><li>禁止建立预留字段</li><li>禁止在数据库中存储文件（图片或者视频音频）这类的大的二进制数据，一般这类数据存储于文件服务器中，数据库只存储文件地址信息</li></ul><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><ul><li>优先选择符合存储需要的最小的数据类型</li><li>对于非负型的数据，使用无符号的整型来存储</li><li>小数值类型使用TINYINT类型</li><li>尽可能把所有的列都定义为NOT NULL</li><li>使用TIMESTAMP或者DATETIME类型来存储时间</li><li>使用DECIMAL类型来存储金额类数据</li></ul><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><ul><li>限制单表索引数量，建议单表索引数量不超过5个</li><li>禁止给表中的每一类都建立索引，因为可以使用联合索引</li><li>每个表中都需要主键</li><li>将WHERE，ORDER BY，GROUP BY，DISTINCT中的字段建立索引，或者将多表join的关联列建立索引</li><li><p>避免建立冗余索引和重复索引，例如index（a,b,c）、index(a,b)</p></li><li><p>对频繁的查询优先考虑覆盖索引</p></li><li><p><strong>避免使用外键约束，数据的关联性在业务端实现，需要在表与表之间的关联键上建立索引</strong></p></li></ul><h3 id="数据库SQL开发规范"><a href="#数据库SQL开发规范" class="headerlink" title="数据库SQL开发规范"></a>数据库SQL开发规范</h3><ul><li>优化对性能影响较大的SQL语句，利用慢查询日志，EXPLAIN</li><li>避免使用select *，无法走覆盖索引</li><li>禁止使用不包含字段列表的INSERT语句</li><li><strong>使用预编译语句进行数据库的操作</strong></li><li>避免数据类型的隐式转换</li><li><strong>避免使用子查询，把子查询优化为join操作</strong></li><li>避免使用JOIN关联太多的表，建议不超过五个</li><li>将批量操作代替单次操作</li><li>将in代替or，or有时候不会走索引</li><li>禁止使用order by rand()进行随机排序</li><li>在明显不会有重复值时使用UNION ALL 而不是 UNION，因为UNION会去重，影响效率</li><li>禁止跨库查询</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><ul><li><p>避免大批量的写操作，要分批多次进行操作</p></li><li><p>对于打包使用pt-online-schema-change来修改表结构</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a><br><a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven3.1</title>
      <link href="/mingyry/d1df8b0a.html"/>
      <url>/mingyry/d1df8b0a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Maven的两大功能"><a href="#Maven的两大功能" class="headerlink" title="Maven的两大功能"></a>Maven的两大功能</h3><ol><li><p>构建</p><ul><li>清理：删除上一次构建的结果，为下一次构建做好准备</li><li>编译：Java源程序编译成*.class字节码文件</li><li>测试：运行提前准备好的测试程序</li><li>报告：针对刚才测试的结果生成一个全面的信息</li><li>打包：<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li>安装：把一个Maven工程经过打包操作生成的jar包或者war包存入Maven的本地仓库</li><li>部署：<ul><li>部署jar包：把一个jar包部署到Nexus私服服务器上</li><li>部署war包：借助相关Maven插件（例如cargo），将war包部署到Tomcat服务器上</li></ul></li></ul></li><li><p>依赖</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar包的下载：使用Maven之后，jar包会从规范的远程仓库下载到本地</li><li>jar包之间的依赖：通过依赖的传递性自动完成</li><li>jar包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul></li><li><p>Maven的工作机制</p></li></ol><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208095706353.png" alt="image-20230208095706353"></p><h3 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h3><ol><li>关注Maven的核心配置文件：conf/settings.xml，修改本地仓库，防止体积太大拖慢c盘运行速度。</li></ol><p>​    <localRepository>D:\maven-repository</localRepository></p><ol><li>配置镜像仓库，使Maven下载jar包更快</li><li>配置Maven工程的基础JDK版本，一般使用JDK1.8</li><li>配置Maven的环境变量 MAVEN_HOME</li></ol><h3 id="使用Maven的步骤"><a href="#使用Maven的步骤" class="headerlink" title="使用Maven的步骤"></a>使用Maven的步骤</h3><h4 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h4><ol><li>根据Maven的坐标找到本地仓库中对应的jar包</li></ol><p>​    使用三个『向量』在『Maven的仓库』中<strong>唯一的定位</strong>到一个『jar』包。</p><ul><li>groupId：公司或组织的 id</li><li>artifactId：一个项目或者是项目中的一个模块的 id</li><li>version：版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的jar包在Maven本地仓库中的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><ol><li>Maven自动生成的pom.xml解读</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>Maven的核心概念：POM</p><ul><li>含义：Project Object Model。项目对象模型。和POM类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</li><li>模型化思想：POM表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事务抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</li><li>对应的配置文件：POM理念体现在Maven工程根目录下pom.xml这个配置文件中。所以这个pom.xml配置文件就是Maven工程的核心配置文件。其实学习Maven就是学习这个文件怎么配置，各个配置有什么用</li></ul></li><li><p>Maven核心概念：约定的目录结构</p><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230208102035142.png" alt="image-20230208102035142"></p></li></ol><ul><li>约定目录结构的意义：为了让构建过程尽可能自动化完成，所以必须约定目录结构的作用</li><li>约定大于配置：Maven对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建Maven工程后，还需要针对各个目录的位置进行详细的配置，肯定非常麻烦。</li></ul><p>​       目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码</p><h4 id="执行Maven的构建命令"><a href="#执行Maven的构建命令" class="headerlink" title="执行Maven的构建命令"></a>执行Maven的构建命令</h4><ol><li><p>要求</p><p>运行Maven中的构建操作相关的命令时，必须进入到pom.xml所在的目录。</p></li><li><p>清理操作</p><p>mvn clean      删除target目录</p></li><li><p>编译操作</p><p>主程序编译：mvn compile</p><p>测试程序编译： mvn test-compile</p><p>主程序编译结果存放目录：target/classes</p><p>测试程序编译结果存放目录：target/test-classes</p></li><li><p>测试操作</p><p>mvn test </p><p>测试报告存放目录：target/surefire-reports</p></li><li><p>打包操作</p><p>mvn package</p><p>打包的结果——jar包，存放的目录：target</p></li><li><p>安装操作</p><p>mvn install</p><p>安装是将本地构建过程中生成的jar包存入Maven本地仓库。这个jar包在Maven仓库中的路径是根据他的坐标生成的。</p><p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ol><h4 id="Maven中的依赖问题"><a href="#Maven中的依赖问题" class="headerlink" title="Maven中的依赖问题"></a>Maven中的依赖问题</h4><ol><li><p>依赖范围：</p><p>标签的位置：dependencies/dependency/scope</p><p>标签的可选值：compile/test/provided/system/runtime/import</p><p>结论：</p><p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p><p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p><p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“服务器上已经有了，你就别带啦！”</p></li><li><p>依赖的传递性：</p><ul><li>概念：A依赖B，B依赖C，那么在A没有配置对C的依赖的情况下，A里面能不能直接使用C？</li><li>传递的原则：在A依赖B，B依赖C的前提下，C是否能够传递到A，取决于B依赖C时使用的依赖范围。<ul><li>B依赖C时使用<strong>compile</strong>范围：可以传递</li><li>B依赖C时使用<strong>test</strong>或<strong>provided</strong>范围：不能传递，所以需要这样的jar包时，就必须在需要的地方明确配置依赖才可以。</li></ul></li></ul></li><li><p>依赖的排除</p><ul><li><p>概念：当A依赖B，B依赖C而且C可以传递到A的时候，A不想要C，需要在A里面把C排除掉。而往往这种情况都是为了避免jar包之间的冲突。</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img027.2faff879.png" alt="img">所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><ul><li><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用excludes标签配置依赖的排除  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="Maven继承"><a href="#Maven继承" class="headerlink" title="Maven继承"></a>Maven继承</h4><ul><li><p>概念：</p><p>Maven工程之间，A工程继承B工程</p><ul><li>B工程：父工程</li><li>A工程：子工程</li></ul><p>本质上是A工程的pom.xml中的配置继承了B工程中pom.xml的配置</p></li><li><p>作用：</p><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个project下面，创建了很多个module。</li><li>每一个module都需要配置自己的依赖信息。</li></ul><p>它的需求是：</p><ul><li>在每一个module中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同jar包，他们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的jar包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的jar包；又能够将以往的经验沉淀下来，节约时间和精力。</p></li><li><p>操作：</p><ul><li><p>创建父工程：只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p></li><li><p>创建模块工程：需要进入 pro03-maven-parent 工程的根目录，然后运行 mvn archetype:generate 命令来创建模块工程。</p></li><li><p>下面 modules 和 module 标签是聚合功能的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;  </span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro04-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro05-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;pro06-maven-<span class="keyword">module</span>&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure></li><li><p>解读子工程的pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置依赖的统一管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子工程中引用那些被父工程管理的依赖：关键点：省略版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在父工程中升级依赖信息的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>在父工程中声明自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用${}的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h4><p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><blockquote><p>概念的对应关系：</p><p>从继承角度看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合角度看：</p><ul><li>总工程</li><li>模块工程</li></ul></blockquote><ol><li><p>好处</p><ul><li>一键执行Maven命令：很多构建命令都可以在“总工程”中一键执行</li><li>配置聚合之后，各个模块工程会在总工程中展示以一个列表，让项目中的各个模块一目了然。</li></ul></li><li><p>聚合的配置：在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Maven其他核心概念"><a href="#Maven其他核心概念" class="headerlink" title="Maven其他核心概念"></a>Maven其他核心概念</h3><ol><li>生命周期：在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li><li>插件和目标：<ul><li>插件：Maven的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。</li><li>目标：一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</li></ul></li><li>仓库：<ul><li>本地仓库：在当前电脑上，为电脑上所有的Maven工程服务</li><li>远程仓库：官方或者其他组织维护的 Maven 仓库</li></ul></li></ol><p>​    Maven 远程仓库可以分为：</p><p>​        <strong>中央仓库</strong> ：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a href="https://search.maven.org/">查询地址open in new window</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</p><p>​        <strong>私服</strong> ：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</p><p>​        <strong>其他的公共仓库</strong> ：有一些公共仓库是未来加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</p><p><strong>Maven 依赖包寻找顺序：</strong></p><ol><li><p>先去本地仓库找寻，有的话，直接使用。</p></li><li><p>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</p></li><li><p>远程仓库没有找到的话，会报错。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/mingyry/53d0684b.html"/>
      <url>/mingyry/53d0684b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><p><img src="C:\Users\op\AppData\Roaming\Typora\typora-user-images\image-20230423090919990.png" alt="image-20230423090919990"></p><ul><li>/bin<ul><li>是Binary的缩写，目录存放着最经常使用的命令</li></ul></li><li>/home<ul><li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</li></ul></li><li>/root<ul><li>该目录为系统管理员，也称作超级权限者的用户主目录</li></ul></li><li>/lib<ul><li>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</li></ul></li><li>/etc<ul><li>所有的系统管理所需要的配置文件和子目录</li></ul></li><li>/usr<ul><li>用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</li></ul></li><li>/boot<ul><li>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，<strong>自己安装的别放在这里</strong></li></ul></li><li>/tmp<ul><li>存放一些临时文件</li></ul></li><li>/mnt<ul><li>系统提供该目录是为了让用户临时挂载别的文件系统，可以将外部的存储挂载在/mnt/上</li></ul></li><li>/opt<ul><li>额外安装软件所摆放的目录。比如安装一个mysql数据库，就可以放到这个目录下。默认是空的</li></ul></li><li>/var<ul><li>存放着不断扩充的东西，将经常被修改的目录放在这个目录下。包括各种日志文件</li></ul></li></ul><h2 id="VI-VIM编辑器"><a href="#VI-VIM编辑器" class="headerlink" title="VI/VIM编辑器"></a>VI/VIM编辑器</h2><h3 id="Vim-的模式"><a href="#Vim-的模式" class="headerlink" title="Vim 的模式"></a>Vim 的模式</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>插入模式（Insert mode）\</strong>和*<em>底线命令模式（Last line mode）*</em>。</p><h4 id="1-2-1-命令模式"><a href="#1-2-1-命令模式" class="headerlink" title="1.2.1. 命令模式"></a>1.2.1. 命令模式</h4><p><strong>用户刚刚启动 vi/vim，便进入了命令模式。</strong></p><p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。</p><h4 id="1-2-2-插入模式"><a href="#1-2-2-插入模式" class="headerlink" title="1.2.2. 插入模式"></a>1.2.2. 插入模式</h4><p><strong>在命令模式下按下 <code>i</code> 就进入了输入模式。</strong></p><p>在输入模式下，你可以输入文本内容。</p><h4 id="1-2-3-底线命令模式"><a href="#1-2-3-底线命令模式" class="headerlink" title="1.2.3. 底线命令模式"></a>1.2.3. 底线命令模式</h4><p><strong>在命令模式下按下 <code>:</code>（英文冒号）就进入了底线命令模式。</strong></p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><h3 id="VIM-学习"><a href="#VIM-学习" class="headerlink" title="VIM 学习"></a>VIM 学习</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><ul><li>启 动 Vim 后，vim 在 <em>Normal</em> 模式下。</li><li>让我们进入 <em>Insert</em> 模式，请按下键 i 。(注：你会看到 vim 左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li><li>此时，你可以输入文本了，就像你用“记事本”一样。</li><li>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</li></ul><blockquote><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出) （注：:w 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong></p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) → 你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（注：退出帮助需要输入:q）</li></ul></blockquote><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><ol><li><p>各种插入模式</p><blockquote><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul></blockquote></li><li><p>简单的移动光标</p><blockquote><ul><li><code>0</code> → 数字零，到行头</li><li><code>^</code> → 到本行第一个不是 blank 字符的位置（所谓 blank 字符就是空格，tab，换行，回车等）</li><li><code>$</code> → 到本行行尾</li><li><code>g_</code> → 到本行最后一个不是 blank 字符的位置。</li><li><code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（注：如果搜索出多个匹配，可按 n 键到下一个）</li></ul></blockquote></li><li><p>拷贝/粘贴</p><p>（注：p/P 都可以，p 是表示在当前位置之后，P 表示在当前位置之前）</p><blockquote><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul></blockquote></li><li><p>Undo/Redo</p><blockquote><ul><li><code>u</code> → undo</li><li><code>&lt;C-r&gt;</code> → redo</li></ul></blockquote></li><li><p>打开/保存/退出/改变文件</p><p>(Buffer)</p><blockquote><ul><li><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li><li><code>:w</code> → 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ 不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（注：我喜欢使用:n 到下一个文件）</li></ul></blockquote></li></ol><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li><code>N&lt;command&gt;</code> → 重复某个命令 N 次</li></ol><h5 id="2-3-1-更好"><a href="#2-3-1-更好" class="headerlink" title="2.3.1. 更好"></a>2.3.1. 更好</h5><p>下面，让我们看一下 vim 是怎么重复自己的：1515G</p><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li><code>N&lt;command&gt;</code> → 重复某个命令 N 次</li></ol><p>下面是一个示例，找开一个文件你可以试试下面的命令：</p><blockquote><ul><li><code>2dd</code> → 删除 2 行</li><li><code>3p</code> → 粘贴文本 3 次</li><li><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</li><li><code>.</code> → 重复上一个命令—— 100 “desu “.</li><li><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM 多聪明啊).</li></ul></blockquote><h5 id="2-3-2-更强"><a href="#2-3-2-更强" class="headerlink" title="2.3.2. 更强"></a>2.3.2. 更强</h5><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p><ol><li><p>N<code>G</code> → 到第 N 行 （注：注意命令中的 G 是大写的，另我一般使用 : N 到第 N 行，如 :137 到第 137 行）</p></li><li><p><code>gg</code> → 到第一行。（注：相当于 1G，或 :1）</p></li><li><p><code>G</code> → 到最后一行。</p></li><li><p>按单词移动：</p><blockquote><ol><li><code>w</code> → 到下一个单词的开头。</li><li><code>e</code> → 到下一个单词的结尾。</li></ol><p>> 如果你认为单词是由默认方式，那么就用小写的 e 和 w。默认上来说，一个单词由字母，数字和下划线组成（注：程序变量）</p><p>> 如果你认为单词是由 blank 字符分隔符，那么你需要使用大写的 E 和 W。（注：程序语句）</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3101171-46f752c581d79057.jpg" alt="img"></p></blockquote></li></ol><p>下面，让我来说说最强的光标移动：</p><blockquote><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul></blockquote><p>相信我，上面这三个命令对程序员来说是相当强大的。</p><h5 id="2-3-3-更快"><a href="#2-3-3-更快" class="headerlink" title="2.3.3. 更快"></a>2.3.3. 更快</h5><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</span><br></pre></td></tr></table></figure><p>例如 <code>0y$</code> 命令意味着：</p><ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul><p>你也可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p><p>你也可以输入 <code>y2/foo</code> 来拷贝 2 个 “foo” 之间的字符串。</p><p>还有很多时间并不一定你就一定要按 y 才会拷贝，下面的命令也会被拷贝：</p><ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li><li>等等</li></ul><p>（注：可视化选择是一个很有意思的命令，你可以先按 v，然后移动光标，你就会看到文本被选择，然后，你可能 d，也可 y，也可以变大写等）</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><h5 id="4-1-在当前行上移动光标-0-fFtT"><a href="#4-1-在当前行上移动光标-0-fFtT" class="headerlink" title="4.1. 在当前行上移动光标: 0 ^ ####fFtT,`;"></a>4.1. 在当前行上移动光标: <code>0</code> <code>^</code> <code>####</code>f<code>F</code>t<code>T</code>,<code>`;</code></h5><blockquote><ul><li><code>0</code> → 到行头</li><li><code>^</code> → 到本行的第一个非 blank 字符</li><li><code>$</code> → 到行尾</li><li><code>g_</code> → 到本行最后一个不是 blank 字符的位置。</li><li><code>fa</code> → 到下一个为 a 的字符处，你也可以 fs 到下一个为 s 的字符。</li><li><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</li><li><code>3fa</code> → 在当前行查找第三个出现的 a。</li><li><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。 <img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3101171-00835b8316330c58.jpg" alt="img"></li></ul></blockquote><p>还有一个很有用的命令是 <code>dt&quot;</code> → 删除所有的内容，直到遇到双引号—— <code>&quot;。</code></p><h5 id="4-2-区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt"><a href="#4-2-区域选择-lt-action-gt-a-lt-object-gt-或-lt-action-gt-i-lt-object-gt" class="headerlink" title="4.2. 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;"></a>4.2. 区域选择 <code>&lt;action&gt;a&lt;object&gt;</code> 或 <code>&lt;action&gt;i&lt;object&gt;</code></h5><p>在 visual 模式下，这些命令很强大，其命令格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action&gt;a&lt;object&gt;` 和 `&lt;action&gt;i&lt;object&gt;</span><br></pre></td></tr></table></figure><ul><li>action 可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</li><li>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>&#39;、</code> <code>)、</code> <code>&#125;、</code> <code>]。</code></li></ul><p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o</code>的位置。</p><blockquote><ul><li><code>vi&quot;</code> → 会选择 <code>foo</code>.</li><li><code>va&quot;</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>vi)</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>va)</code> → 会选择<code>(&quot;foo&quot;)</code>.</li><li><code>v2i)</code> → 会选择 <code>map (+) (&quot;foo&quot;)</code></li><li><code>v2a)</code> → 会选择 <code>(map (+) (&quot;foo&quot;))</code></li></ul></blockquote><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="查看IP和网关"><a href="#查看IP和网关" class="headerlink" title="查看IP和网关"></a>查看IP和网关</h3><p><strong>修改虚拟网卡Ip</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230423100128521.png" alt="image-20230423100128521" style="zoom: 80%;" /></p><p><strong>查看网关</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230423100226244.png" alt="image-20230423100226244"></p><h2 id="查看-Linux-命令帮助信息"><a href="#查看-Linux-命令帮助信息" class="headerlink" title="查看 Linux 命令帮助信息"></a>查看 Linux 命令帮助信息</h2><ul><li><strong>查看 Shell 内部命令的帮助信息 - 使用 help</strong></li><li>查看命令的简要说明 - 使用 whatis</li><li>查看命令的详细说明 - 使用 info</li><li>查看命令的位置 - 使用 which</li><li>定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径 - 使用 whereis</li><li><strong>查看命令的帮助手册（包含说明、用法等信息） - 使用 man</strong></li><li>只记得部分命令关键字 - 使用 man -k</li></ul><h3 id="命令常见用法"><a href="#命令常见用法" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1. help"></a>2.1. help</h4><blockquote><p>help 命令用于查看 Shell 内部命令的帮助信息。而对于外部命令的帮助信息只能使用 man 或者 info 命令查看。</p><p>参考：<a href="http://man.linuxde.net/help">http://man.linuxde.net/help</a></p></blockquote><h4 id="2-2-whatis"><a href="#2-2-whatis" class="headerlink" title="2.2. whatis"></a>2.2. whatis</h4><blockquote><p>whatis 用于查询一个命令执行什么功能。</p><p>参考：<a href="http://man.linuxde.net/whatis">http://man.linuxde.net/whatis</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 man 命令的简要说明</span></span><br><span class="line">$ whatis man</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看以 loca 开拓的命令的简要说明</span></span><br><span class="line">$ whatis -w <span class="string">&quot;loca*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-info"><a href="#2-3-info" class="headerlink" title="2.3. info"></a>2.3. info</h4><blockquote><p>info 是 Linux 下 info 格式的帮助指令。</p><p>参考：<a href="http://man.linuxde.net/info">http://man.linuxde.net/info</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 man 命令的详细说明</span></span><br><span class="line">$ info man</span><br></pre></td></tr></table></figure><h4 id="2-4-which"><a href="#2-4-which" class="headerlink" title="2.4. which"></a>2.4. which</h4><blockquote><p>which 命令用于查找并显示给定命令的绝对路径，环境变量 PATH 中保存了查找命令时需要遍历的目录。which 指令会在环境变量$PATH 设置的目录里查找符合条件的文件。也就是说，使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p>参考：<a href="http://man.linuxde.net/which">http://man.linuxde.net/which</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">pwd</span> <span class="comment"># 查找命令的路径</span></span><br></pre></td></tr></table></figure><p>说明：which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># which cd</span></span><br><span class="line"><span class="built_in">cd</span>: shell built-in <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是 bash 内建的命令！但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！</p><h4 id="2-5-whereis"><a href="#2-5-whereis" class="headerlink" title="2.5. whereis"></a>2.5. whereis</h4><blockquote><p>whereis 命令用来定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径。</p><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>参考：<a href="http://man.linuxde.net/whereis">http://man.linuxde.net/whereis</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis git <span class="comment"># 将相关的文件都查找出来</span></span><br></pre></td></tr></table></figure><h4 id="2-6-man"><a href="#2-6-man" class="headerlink" title="2.6. man"></a>2.6. man</h4><blockquote><p>man 命令是 Linux 下的帮助指令，通过 man 指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。</p><p>参考：<a href="http://man.linuxde.net/man">http://man.linuxde.net/man</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ man <span class="built_in">date</span> <span class="comment"># 查看 date 命令的帮助手册</span></span><br><span class="line">$ man 3 <span class="built_in">printf</span> <span class="comment"># 查看 printf 命令的帮助手册中的第 3 类</span></span><br><span class="line">$ man -k keyword <span class="comment"># 根据命令中部分关键字来查询命令</span></span><br></pre></td></tr></table></figure><h4 id="2-7-man-要点"><a href="#2-7-man-要点" class="headerlink" title="2.7. man 要点"></a>2.7. man 要点</h4><p>在 man 的帮助手册中，可以使用 page up 和 page down 来上下翻页。</p><p>man 的帮助手册中，将帮助文档分为了 9 个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询 bash 命令，归类在 1 类中）。</p><p>man 页面的分类(常用的是分类 1 和分类 3)：</p><ol><li>可执行程序或 shell 命令</li><li>系统调用(内核提供的函数)</li><li>库调用(程序库中的函数)</li><li>特殊文件(通常位于 /dev)</li><li>文件格式和规范，如 /etc/passwd</li><li>游戏</li><li>杂项(包括宏包和规范，如 man(7)，groff(7))</li><li>系统管理命令(通常只针对 root 用户)</li><li>内核例程 [非标准]</li></ol><p>前面说到使用 whatis 会显示命令所在的具体的文档类别，我们学习如何使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ whatis <span class="built_in">printf</span></span><br><span class="line"><span class="built_in">printf</span> (1) - format and <span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">printf</span> (1p) - write formatted output</span><br><span class="line"><span class="built_in">printf</span> (3) - formatted output conversion</span><br><span class="line"><span class="built_in">printf</span> (3p) - <span class="built_in">print</span> formatted output</span><br><span class="line"><span class="built_in">printf</span> [builtins](1) - bash built-in commands, see bash(1)</span><br></pre></td></tr></table></figure><p>我们看到 printf 在分类 1 和分类 3 中都有；分类 1 中的页面是命令操作及可执行文件的帮助；而 3 是常用函数库说明；如果我们想看的是 C 语言中 printf 的用法，可以指定查看分类 3 的帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man 3 <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><h2 id="Linux-文件目录命令"><a href="#Linux-文件目录命令" class="headerlink" title="Linux 文件目录命令"></a>Linux 文件目录命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ul><li><strong>切换目录 - 使用 cd</strong></li><li><strong>查看目录信息 - 使用 ls</strong></li><li><strong>显示当前目录的绝对路径 - 使用 pwd</strong></li><li><strong>树状显示目录的内容 - 使用 tree</strong></li><li><strong>创建目录 - 使用 mkdir</strong></li><li><strong>删除目录 - 使用 rmdir</strong></li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li><strong>创建空文件 - 使用 touch</strong></li><li>为文件创建连接 - 使用 ln</li><li>批量重命名 - 使用 rename</li><li>显示文件的详细信息 - 使用 stat</li><li>探测文件类型 - 使用 file</li><li><strong>设置文件或目录的权限 - 使用 chmod</strong></li><li>设置文件或目录的拥有者或所属群组 - 使用 chown</li><li>查找文件或目录 - 使用 locate</li><li><strong>在指定目录下查找文件 - 使用 find</strong></li><li>查找命令的绝对路径 - 使用 which</li><li>查找命令的程序、源代码等相关文件 - 使用 whereis</li></ul><h3 id="文件和目录通用管理"><a href="#文件和目录通用管理" class="headerlink" title="文件和目录通用管理"></a>文件和目录通用管理</h3><ul><li><strong>复制文件或目录 - 使用 cp</strong></li><li><strong>复制文件或目录到远程服务器 - 使用 scp</strong></li><li><strong>移动文件或目录 - 使用 mv</strong></li><li><strong>删除文件或目录 - 使用 rm</strong></li></ul><h3 id="命令常见用法-1"><a href="#命令常见用法-1" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><blockquote><p>cd 命令用来切换工作目录。</p><p>参考：<a href="http://man.linuxde.net/cd">http://man.linuxde.net/cd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>          <span class="comment"># 切换到用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> ~        <span class="comment"># 切换到用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> -        <span class="comment"># 切换到上一个工作目录</span></span><br><span class="line"><span class="built_in">cd</span> ..       <span class="comment"># 切换到上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../..    <span class="comment"># 切换到上两级目录</span></span><br></pre></td></tr></table></figure><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><blockquote><p>ls 命令用来显示目录信息。</p><p>参考：<a href="http://man.linuxde.net/ls">http://man.linuxde.net/ls</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>        <span class="comment"># 列出当前目录可见文件</span></span><br><span class="line"><span class="built_in">ls</span> -l     <span class="comment"># 列出当前目录可见文件详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -la    <span class="comment"># 列出所有文件（包括隐藏）的详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -lh    <span class="comment"># 列出详细信息并以可读大小显示文件大小</span></span><br><span class="line"><span class="built_in">ls</span> -lt    <span class="comment"># 按时间列出文件和文件夹详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -ltr   <span class="comment"># 按修改时间列出文件和文件夹详细信息</span></span><br><span class="line"><span class="built_in">ls</span> --color=auto     <span class="comment"># 列出文件并标记颜色分类</span></span><br></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><blockquote><p>pwd 命令用来显示当前目录的绝对路径。</p><p>参考：<a href="http://man.linuxde.net/pwd">http://man.linuxde.net/pwd</a></p></blockquote><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><blockquote><p>mkdir 命令用来创建目录。</p><p>参考：<a href="http://man.linuxde.net/mkdir">http://man.linuxde.net/mkdir</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录中创建 zp 和 zp 的子目录 test</span></span><br><span class="line"><span class="built_in">mkdir</span> -p zp/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前目录中创建 zp 和 zp 的子目录 test；权限设置为文件主可读、写、执行，同组用户可读和执行，其他用户无权访问</span></span><br><span class="line"><span class="built_in">mkdir</span> -p -m 750 zp/test</span><br></pre></td></tr></table></figure><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><blockquote><p>rmdir 命令用来删除空目录。</p><p>参考：<a href="http://man.linuxde.net/rmdir">http://man.linuxde.net/rmdir</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除子目录 test 和其父目录 zp</span></span><br><span class="line"><span class="built_in">rmdir</span> -p zp/test</span><br></pre></td></tr></table></figure><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><blockquote><p>tree 命令以树状显示目录的内。</p><p>参考：<a href="http://man.linuxde.net/tree">http://man.linuxde.net/tree</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录 /private 第一级文件名</span></span><br><span class="line">tree /private -L 1</span><br><span class="line">/private/</span><br><span class="line">├── etc</span><br><span class="line">├── tftpboot</span><br><span class="line">├── tmp</span><br><span class="line">└── var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略文件夹</span></span><br><span class="line">tree -I node_modules            <span class="comment"># 忽略当前目录文件夹 node_modules</span></span><br><span class="line">tree -P node_modules            <span class="comment"># 列出当前目录文件夹 node_modules 的目录结构</span></span><br><span class="line">tree -P node_modules -L 2       <span class="comment"># 显示目录 node_modules 两层的目录树结构</span></span><br><span class="line">tree -L 2 &gt; /home/www/tree.txt  <span class="comment"># 当前目录结果存到 tree.txt 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略多个文件夹</span></span><br><span class="line">tree -I <span class="string">&#x27;node_modules|icon|font&#x27;</span> -L 2</span><br></pre></td></tr></table></figure><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><blockquote><p>touch 命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建空文件。</p><p>参考：<a href="http://man.linuxde.net/touch">http://man.linuxde.net/touch</a></p></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ex2</span><br></pre></td></tr></table></figure><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><blockquote><p>ln 命令用来为文件创建连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。</p><p>🔔 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。</p><p>参考：<a href="http://man.linuxde.net/ln">http://man.linuxde.net/ln</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目录 /usr/mengqc/mub1 下的文件 m2.c 链接到目录 /usr/liu 下的文件 a2.c</span></span><br><span class="line"><span class="built_in">cd</span> /usr/mengqc</span><br><span class="line"><span class="built_in">ln</span> /mub1/m2.c /usr/liu/a2.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目录 /usr/liu 下建立一个符号链接文件 abc，使它指向目录 /usr/mengqc/mub1</span></span><br><span class="line"><span class="comment"># 执行该命令后，/usr/mengqc/mub1 代表的路径将存放在名为 /usr/liu/abc 的文件中</span></span><br><span class="line"><span class="built_in">ln</span> -s /usr/mengqc/mub1 /usr/liu/abc</span><br></pre></td></tr></table></figure><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><blockquote><p>rename 命令用字符串替换的方式批量重命名。</p><p>参考：<a href="http://man.linuxde.net/rename">http://man.linuxde.net/rename</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 main1.c 重命名为 main.c</span></span><br><span class="line">rename main1.c main.c main1.c</span><br><span class="line"></span><br><span class="line">rename <span class="string">&quot;s/AA/aa/&quot;</span> *             <span class="comment"># 把文件名中的 AA 替换成 aa</span></span><br><span class="line">rename <span class="string">&quot;s//.html//.php/&quot;</span> *      <span class="comment"># 把 .html 后缀的改成 .php 后缀</span></span><br><span class="line">rename <span class="string">&quot;s/$//.txt/&quot;</span> *           <span class="comment"># 把所有的文件名都以 txt 结尾</span></span><br><span class="line">rename <span class="string">&quot;s//.txt//&quot;</span> *            <span class="comment"># 把所有以 .txt 结尾的文件名的.txt 删掉</span></span><br></pre></td></tr></table></figure><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><blockquote><p>stat 命令用于显示文件的状态信息。stat 命令的输出信息比 ls 命令的输出信息要更详细。</p><p>参考：<a href="http://man.linuxde.net/stat">http://man.linuxde.net/stat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> myfile</span><br></pre></td></tr></table></figure><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><blockquote><p>file 命令用来探测给定文件的类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。</p><p>参考：<a href="http://man.linuxde.net/file">http://man.linuxde.net/file</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file install.log          <span class="comment"># 显示文件类型</span></span><br><span class="line">file -b install.log       <span class="comment"># 不显示文件名称</span></span><br><span class="line">file -i install.log       <span class="comment"># 显示 MIME 类型</span></span><br><span class="line">file -L /var/spool/mail   <span class="comment"># 显示符号链接的文件类型</span></span><br></pre></td></tr></table></figure><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><blockquote><p>chmod 命令用来变更文件或目录的权限。在 UNIX 系统家族里，文件或目录权限的控制分别以读取、写入、执行 3 种一般权限来区分，另有 3 种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p><p>参考：<a href="http://man.linuxde.net/chmod">http://man.linuxde.net/chmod</a></p></blockquote><p>知识扩展：</p><p>Linux 用 户分为：拥有者、组群(Group)、其他（other），Linux 系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及 root 的相关信 息， 都是记录在<code>/etc/passwd</code>文件中。每个人的密码则是记录在<code>/etc/shadow</code>文件下。 此外，所有的组群名称记录在<code>/etc/group</code>內！</p><p>linux 文件的用户权限的分析图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules</span><br><span class="line"><span class="comment"># ↑╰┬╯╰┬╯╰┬╯</span></span><br><span class="line"><span class="comment"># ┆ ┆  ┆  ╰┈ 0 其他人</span></span><br><span class="line"><span class="comment"># ┆ ┆  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ g 属组</span></span><br><span class="line"><span class="comment"># ┆ ╰┈┈┈┈ u 属组</span></span><br><span class="line"><span class="comment"># ╰┈┈ 第一个字母 `d` 代表目录，`-` 代表普通文件</span></span><br></pre></td></tr></table></figure><p>例：rwx 　 rw-　 r—</p><p>r=读取属性　　//值＝ 4<br>w=写入属性　　//值＝ 2<br>x=执行属性　　//值＝ 1</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x,g+w f01　　<span class="comment"># 为文件f01设置自己可以执行，组员可以写入的权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rwx,g=rw,o=r f01</span><br><span class="line"><span class="built_in">chmod</span> 764 f01</span><br><span class="line"><span class="built_in">chmod</span> a+x f01　　    <span class="comment"># 对文件f01的u,g,o都设置可执行属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将/home/wwwroot/里的所有文件和文件夹设置为755权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R  755 /home/wwwroot/*</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><blockquote><p>chown 命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户 D，用户组可以是组名或组 id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。</p><p>只有文件拥有者和超级用户才可以便用该命令。</p><p>参考：<a href="http://man.linuxde.net/chown">http://man.linuxde.net/chown</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu</span></span><br><span class="line"><span class="built_in">chown</span> -R liu /usr/meng</span><br></pre></td></tr></table></figure><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><blockquote><p>locate 命令和 slocate 命令都用来查找文件或目录。</p><p>locate 命令其实是 find -name 的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，所以使用 locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令，手动更新数据库。</p><p>参考：<a href="http://man.linuxde.net/locate_slocate">http://man.linuxde.net/locate_slocate</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate <span class="built_in">pwd</span>      <span class="comment"># 查找和 pwd 相关的所有文件</span></span><br><span class="line">locate /etc/sh  <span class="comment"># 搜索 etc 目录下所有以 sh 开头的文件</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><blockquote><p>find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>参考：<a href="http://man.linuxde.net/find">http://man.linuxde.net/find</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录搜索所有文件，文件内容 包含 “140.206.111.111” 的内容</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*&quot;</span> | xargs grep <span class="string">&quot;140.206.111.111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line">find .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /home 目录下查找以 .txt 结尾的文件名</span></span><br><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="comment"># 同上，但忽略大小写</span></span><br><span class="line">find /home -iname <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录及子目录下查找所有以 .txt 和 .pdf 结尾的文件</span></span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配文件路径或者文件</span></span><br><span class="line">find /usr/ -path <span class="string">&quot;*local*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于正则表达式匹配文件路径</span></span><br><span class="line">find . -regex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br><span class="line"><span class="comment"># 同上，但忽略大小写</span></span><br><span class="line">find . -iregex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出 /home 下不是以 .txt 结尾的文件</span></span><br><span class="line">find /home ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><blockquote><p>cp 命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp 命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。</p><p>参考：<a href="http://man.linuxde.net/cp">http://man.linuxde.net/cp</a></p></blockquote><p>示例：</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li>源文件：制定源文件列表。默认情况下，cp 命令不能复制目录，如果要复制目录，则必须使用<code>-R</code>选项；</li><li>目标文件：指定目标文件。当“源文件”为多个文件时，要求“目标文件”为指定的目录。</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件 file 复制到目录 /usr/men/tmp 下，并改名为 file1</span></span><br><span class="line"><span class="built_in">cp</span> file /usr/men/tmp/file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录 /usr/men下的所有文件及其子目录复制到目录 /usr/zh 中</span></span><br><span class="line"><span class="built_in">cp</span> -r /usr/men /usr/zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行将 /usr/men下的所有文件复制到目录 /usr/zh 中，无论是否有文件重复</span></span><br><span class="line"><span class="built_in">cp</span> -rf /usr/men/* /usr/zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录 /usr/men 中的以 m 打头的所有 .c 文件复制到目录 /usr/zh 中</span></span><br><span class="line"><span class="built_in">cp</span> -i /usr/men m*.c /usr/zh</span><br></pre></td></tr></table></figure><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><blockquote><p>scp 命令用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system 时，用 scp 可以帮你把文件移出来。另外，scp 还非常不占资源，不会提高多少系统负荷，在这一点上，rsync 就远远不及它了。虽然 rsync 比 scp 会快一点，但当小文件众多的情况下，rsync 会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。</p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝文件到远程服务器的指定目录</span></span><br><span class="line">scp &lt;file&gt; &lt;user&gt;@&lt;ip&gt;:&lt;url&gt;</span><br><span class="line">scp test.txt root@192.168.0.1:/opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝目录到远程服务器的指定目录</span></span><br><span class="line">scp -r &lt;folder&gt; &lt;user&gt;@&lt;ip&gt;:&lt;url&gt;</span><br><span class="line">scp -r <span class="built_in">test</span> root@192.168.0.1:/opt</span><br></pre></td></tr></table></figure><h5 id="免密码传输"><a href="#免密码传输" class="headerlink" title="免密码传输"></a>免密码传输</h5><p>（1）生成 ssh 公私钥对</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>（2）将服务器 A 的 <code>\~/.ssh/id_rsa.pub</code> 文件内容复制到服务器 B 的 <code>\~/.ssh/authorized_keys</code> 文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器 A 上执行以下命令</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub root@192.168.0.2:~/.ssh/id_rsa.pub.tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器 B 上执行以下命令</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub.tmp &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">rm</span> ~/.ssh/id_rsa.pub.tmp</span><br></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><blockquote><p>mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source 表示源文件或目录，target 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。</p><p>参考：<a href="http://man.linuxde.net/mv">http://man.linuxde.net/mv</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file1.txt /home/office/                      <span class="comment"># 移动单个文件</span></span><br><span class="line"><span class="built_in">mv</span> file2.txt file3.txt file4.txt /home/office/  <span class="comment"># 移动多个文件</span></span><br><span class="line"><span class="built_in">mv</span> *.txt /home/office/                          <span class="comment"># 移动所有 txt 文件</span></span><br><span class="line"><span class="built_in">mv</span> dir1/ /home/office/                          <span class="comment"># 移动目录</span></span><br><span class="line"><span class="built_in">mv</span> /usr/men/* .                                 <span class="comment"># 将指定目录中的所有文件移到当前目录中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> file1.txt file2.txt          <span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> dir1/ dir2/                  <span class="comment"># 重命名目录</span></span><br><span class="line"><span class="built_in">mv</span> -v *.txt /home/office        <span class="comment"># 打印移动信息</span></span><br><span class="line"><span class="built_in">mv</span> -i file1.txt /home/office    <span class="comment"># 提示是否覆盖文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> -uv *.txt /home/office       <span class="comment"># 源文件比目标文件新时才执行更新</span></span><br><span class="line"><span class="built_in">mv</span> -vn *.txt /home/office       <span class="comment"># 不要覆盖任何已存在的文件</span></span><br><span class="line"><span class="built_in">mv</span> -f *.txt /home/office        <span class="comment"># 无条件覆盖已经存在的文件</span></span><br><span class="line"><span class="built_in">mv</span> -bv *.txt /home/office       <span class="comment"># 复制时创建备份</span></span><br></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><blockquote><p>rm 命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。</p><p>参考：<a href="http://man.linuxde.net/rm">http://man.linuxde.net/rm</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt               <span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -i test.txt test2.txt  <span class="comment"># 交互式删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -r *                   <span class="comment"># 删除当前目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -r testdir             <span class="comment"># 删除目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf testdir            <span class="comment"># 强制删除目录下的所有文件和目录</span></span><br><span class="line"><span class="built_in">rm</span> -v testdir             <span class="comment"># 显示当前删除操作的详情</span></span><br></pre></td></tr></table></figure><h2 id="Linux-文件内容查看编辑命令"><a href="#Linux-文件内容查看编辑命令" class="headerlink" title="Linux 文件内容查看编辑命令"></a>Linux 文件内容查看编辑命令</h2><h3 id="Linux-文件内容查看编辑要点"><a href="#Linux-文件内容查看编辑要点" class="headerlink" title="Linux 文件内容查看编辑要点"></a>Linux 文件内容查看编辑要点</h3><ul><li><strong>连接文件并打印到标准输出设备 - 使用 cat</strong></li><li><strong>显示指定文件的开头若干行 - 使用 head</strong></li><li><strong>显示指定文件的末尾若干行，常用于实时打印日志文件内容 - 使用 tail</strong></li><li><strong>显示文件内容，每次显示一屏 - 使用 more</strong></li><li><strong>显示文件内容，每次显示一屏 - 使用 less</strong></li><li><strong>自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等 - 使用 sed</strong></li><li><strong>文本编辑器 - 使用 vi</strong></li><li><strong>使用正则表达式搜索文本，并把匹配的行打印出来 - 使用 grep</strong></li></ul><h3 id="命令常见用法-2"><a href="#命令常见用法-2" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><blockquote><p>cat 命令用于连接文件并打印到标准输出设备上。</p><p>参考：<a href="http://man.linuxde.net/cat">http://man.linuxde.net/cat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> m1              <span class="comment"># 在屏幕上显示文件 ml 的内容</span></span><br><span class="line"><span class="built_in">cat</span> m1 m2           <span class="comment"># 同时显示文件 ml 和 m2 的内容</span></span><br><span class="line"><span class="built_in">cat</span> m1 m2 &gt; file    <span class="comment"># 将文件 ml 和 m2 合并后放入文件 file 中</span></span><br></pre></td></tr></table></figure><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><blockquote><p>head 命令用于显示文件的开头内容。在默认情况下，head 命令显示文件的头部 10 行内容。</p><p>参考：<a href="http://man.linuxde.net/head">http://man.linuxde.net/head</a></p></blockquote><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><blockquote><p>tail 命令用于显示文件的尾部内容。在默认情况下，tail 命令显示文件的尾部 10 行内容。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。</p><p>参考：<a href="http://man.linuxde.net/tail">http://man.linuxde.net/tail</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> file           <span class="comment"># 显示文件file的最后10行</span></span><br><span class="line"><span class="built_in">tail</span> -n +20 file    <span class="comment"># 显示文件file的内容，从第20行至文件末尾</span></span><br><span class="line"><span class="built_in">tail</span> -c 10 file     <span class="comment"># 显示文件file的最后10个字符</span></span><br></pre></td></tr></table></figure><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><blockquote><p>more 命令是一个基于 vi 编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持 vi 中的关键字定位操作。more 名单中内置了若干快捷键，常用的有 H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。</p><p>该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：—More—（XX%）可以用下列不同的方法对提示做出回答：</p><ul><li>按 Space 键：显示文本的下一屏内容。</li><li>按 Enier 键：只显示文本的下一行内容。</li><li>按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</li><li>按 H 键：显示帮助屏，该屏上有相关的帮助信息。</li><li>按 B 键：显示上一屏内容。</li><li>按 Q 键：退出 rnore 命令。</li></ul><p>参考：<a href="http://man.linuxde.net/more">http://man.linuxde.net/more</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件 file 的内容，但在显示之前先清屏，并且在屏幕的最下方显示完核的百分比。</span></span><br><span class="line">more -dc file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件 file 的内容，每 10 行显示一次，而且在显示之前先清屏。</span></span><br><span class="line">more -c -10 file</span><br></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 命令的作用与 more 十分相似，都可以用来浏览文字档案的内容，不同的是 less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览。用 less 命令显示文件时，用 PageUp 键向上翻页，用 PageDown 键向下翻页。要退出 less 程序，应按 Q 键。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /var/log/shadowsocks.log</span><br></pre></td></tr></table></figure><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><blockquote><p>sed 是一种流编辑器，它是文本处理工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。Sed 主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p>参考：<a href="http://man.linuxde.net/sed">http://man.linuxde.net/sed</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换文本中的字符串</span></span><br><span class="line">sed <span class="string">&#x27;s/book/books/&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 选项 和 p 命令 一起使用表示只打印那些发生替换的行</span></span><br><span class="line">sed -n <span class="string">&#x27;s/test/TEST/p&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接编辑文件选项 -i ，会匹配 file 文件中每一行的第一个 book 替换为 books</span></span><br><span class="line">sed -i <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用后缀 /g 标记会替换每一行中的所有匹配</span></span><br><span class="line">sed <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件的第2行</span></span><br><span class="line">sed <span class="string">&#x27;2d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件的第2行到末尾所有行</span></span><br><span class="line">sed <span class="string">&#x27;2,$d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件最后一行</span></span><br><span class="line">sed <span class="string">&#x27;$d&#x27;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件中所有开头是test的行</span></span><br><span class="line">sed <span class="string">&#x27;/^test/&#x27;</span>d file</span><br></pre></td></tr></table></figure><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><blockquote><p>vi 命令是 UNIX 操作系统和类 UNIX 操作系统中最通用的全屏幕纯文本编辑器。Linux 中的 vi 编辑器叫 vim，它是 vi 的增强版（vi Improved），与 vi 编辑器完全兼容，而且实现了很多增强功能。</p><p>参考：<a href="http://man.linuxde.net/vi">http://man.linuxde.net/vi</a></p><p>引申阅读：<a href="https://github.com/dunwu/OS/blob/master/docs/vim.md">Vim 入门指南(opens new window)</a></p></blockquote><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><blockquote><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>参考：<a href="http://man.linuxde.net/grep">http://man.linuxde.net/grep</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在多级目录中对文本递归搜索(程序员搜代码的最爱）:</span></span><br><span class="line">$ grep <span class="string">&quot;class&quot;</span> . -R -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略匹配样式中的字符大小写</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | grep -i <span class="string">&quot;HELLO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配多个模式:</span></span><br><span class="line">$ grep -e <span class="string">&quot;class&quot;</span> -e <span class="string">&quot;vitural&quot;</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --include *.&#123;php,html&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在搜索结果中排除所有README文件</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --exclude <span class="string">&quot;README&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在搜索结果中排除filelist文件列表里的文件</span></span><br><span class="line">$ grep <span class="string">&quot;main()&quot;</span> . -r --exclude-from filelist</span><br></pre></td></tr></table></figure><h2 id="Linux-文件压缩和解压命令"><a href="#Linux-文件压缩和解压命令" class="headerlink" title="Linux 文件压缩和解压命令"></a>Linux 文件压缩和解压命令</h2><h3 id="Linux-文件压缩和解压要点"><a href="#Linux-文件压缩和解压要点" class="headerlink" title="Linux 文件压缩和解压要点"></a>Linux 文件压缩和解压要点</h3><ul><li><strong>压缩和解压 tar 文件 - 使用 tar</strong></li><li><strong>压缩和解压 gz 文件 - 使用 gzip</strong></li><li><strong>压缩和解压 zip 文件 - 分别使用 zip、unzip</strong></li></ul><h3 id="命令常见用法-3"><a href="#命令常见用法-3" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><blockquote><p>tar 命令可以为 linux 的文件和目录创建档案。利用 tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar 最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用 tar 命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p><p>参考：<a href="http://man.linuxde.net/tar">http://man.linuxde.net/tar</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf log.tar log2012.log            <span class="comment"># 仅打包，不压缩</span></span><br><span class="line">tar -zcvf log.tar.gz log2012.log        <span class="comment"># 打包后，以 gzip 压缩</span></span><br><span class="line">tar -jcvf log.tar.bz2 log2012.log       <span class="comment"># 打包后，以 bzip2 压缩</span></span><br><span class="line"></span><br><span class="line">tar -ztvf log.tar.gz                    <span class="comment"># 查阅上述 tar 包内有哪些文件</span></span><br><span class="line">tar -zxvf log.tar.gz                    <span class="comment"># 将 tar 包解压缩</span></span><br><span class="line">tar -zxvf log30.tar.gz log2013.log      <span class="comment"># 只将 tar 内的部分文件解压出来</span></span><br></pre></td></tr></table></figure><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><blockquote><p>gzip 命令用来压缩文件。gzip 是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出“.gz”扩展名。</p><p>gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～ 70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p>参考：<a href="http://man.linuxde.net/gzip">http://man.linuxde.net/gzip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip * <span class="comment"># 将所有文件压缩成 .gz 文件</span></span><br><span class="line">gzip -l * <span class="comment"># 详细显示压缩文件的信息，并不解压</span></span><br><span class="line">gzip -dv * <span class="comment"># 解压上例中的所有压缩文件，并列出详细的信息</span></span><br><span class="line">gzip -r log.tar     <span class="comment"># 压缩一个 tar 备份文件，此时压缩文件的扩展名为.tar.gz</span></span><br><span class="line">gzip -rv <span class="built_in">test</span>/      <span class="comment"># 递归的压缩目录</span></span><br><span class="line">gzip -dr <span class="built_in">test</span>/      <span class="comment"># 递归地解压目录</span></span><br></pre></td></tr></table></figure><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><blockquote><p>zip 命令可以用来解压缩文件，或者对文件进行打包操作。zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。</p><p>参考：<a href="http://man.linuxde.net/zip">http://man.linuxde.net/zip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /home/Blinux/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip</span></span><br><span class="line">zip -q -r html.zip /home/Blinux/html</span><br></pre></td></tr></table></figure><h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h4><blockquote><p>unzip 命令用于解压缩由 zip 命令压缩的“.zip”压缩包。</p><p>参考：<a href="http://man.linuxde.net/unzip">http://man.linuxde.net/unzip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip test.zip              <span class="comment"># 解压 zip 文件</span></span><br><span class="line">unzip -n test.zip -d /tmp/  <span class="comment"># 在指定目录下解压缩</span></span><br><span class="line">unzip -o test.zip -d /tmp/  <span class="comment"># 在指定目录下解压缩，如果有相同文件存在则覆盖</span></span><br><span class="line">unzip -v test.zip           <span class="comment"># 查看压缩文件目录，但不解压</span></span><br></pre></td></tr></table></figure><h2 id="Linux-用户管理命令"><a href="#Linux-用户管理命令" class="headerlink" title="Linux 用户管理命令"></a>Linux 用户管理命令</h2><h3 id="用户管理要点"><a href="#用户管理要点" class="headerlink" title="用户管理要点"></a>用户管理要点</h3><ul><li><strong>创建用户组 - 使用 groupadd</strong></li><li>删除用户组 - 使用 groupdel</li><li>修改用户组信息 - 使用 groupmod</li><li><strong>创建用户 - 使用 useradd</strong></li><li><strong>删除用户 - 使用 userdel</strong></li><li><strong>修改用户信息 - 使用 usermod</strong></li><li>设置用户认证信息 - 使用 passwd</li><li><strong>切换用户 - 使用 su</strong></li><li><strong>当前用户想执行没有权限执行的命令时，使用其他用户身份去执行 - 使用 sudo</strong></li></ul><h3 id="命令常见用法-4"><a href="#命令常见用法-4" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><blockquote><p>groupadd 命令用于创建一个新的用户组，新用户组的信息将被添加到系统文件中。</p><p>参考：<a href="http://man.linuxde.net/groupadd">http://man.linuxde.net/groupadd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一个新组，并设置组 ID 加入系统</span></span><br><span class="line">$ groupadd -g 344 jsdigname</span><br></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><blockquote><p>groupdel 命令用于删除指定的用户组，本命令要修改的系统文件包括 <code>/ect/group</code> 和 <code>/ect/gshadow</code>。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><p>参考：<a href="http://man.linuxde.net/groupdel">http://man.linuxde.net/groupdel</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd damon  <span class="comment"># 创建damon用户组</span></span><br><span class="line">$ groupdel damon  <span class="comment"># 删除这个用户组</span></span><br></pre></td></tr></table></figure><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><blockquote><p>groupmod 命令更改群组识别码或名称。需要更改群组的识别码或名称时，可用 groupmod 指令来完成这项工作。</p><p>参考：<a href="http://man.linuxde.net/groupmod">http://man.linuxde.net/groupmod</a></p></blockquote><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><blockquote><p>useradd 命令用于 Linux 中创建的新的系统用户。useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码．而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code> 文本文件中。</p><p>参考：<a href="http://man.linuxde.net/useradd">http://man.linuxde.net/useradd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建用户加入组</span></span><br><span class="line">$ useradd –g sales jack –G company,employees    <span class="comment"># -g：加入主要组、-G：加入次要组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个新用户账户，并设置 ID</span></span><br><span class="line">$ useradd caojh -u 544</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><blockquote><p>userdel 命令用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。</p><p>参考：<a href="http://man.linuxde.net/userdel">http://man.linuxde.net/userdel</a></p></blockquote><p>示例：</p><p>userdel 命令很简单，比如我们现在有个用户 linuxde，其 home 目录位于<code>/var</code>目录中，现在我们来删除这个用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ userdel linuxde       <span class="comment"># 删除用户linuxde，但不删除其家目录及文件；</span></span><br><span class="line">$ userdel -r linuxde    <span class="comment"># 删除用户linuxde，其 home 目录及文件一并删除；</span></span><br></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><blockquote><p>usermod 命令用于修改用户的基本信息。usermod 命令不允许你改变正在线上的使用者帐号名称。当 usermod 命令用来改变 user id，必须确认这名 user 没在电脑上执行任何程序。你需手动更改使用者的 crontab 档。也需手动更改使用者的 at 工作档。采用 NIS server 须在 server 上更动相关的 NIS 设定。</p><p>参考：<a href="http://man.linuxde.net/usermod">http://man.linuxde.net/usermod</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 newuser2 添加到组 staff 中</span></span><br><span class="line">$ usermod -G staff newuser2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 newuser 的用户名为 newuser1</span></span><br><span class="line">$ usermod -l newuser1 newuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定账号 newuser1</span></span><br><span class="line">$ usermod -L newuser1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解除对 newuser1 的锁定</span></span><br><span class="line">$ usermod -U newuser1</span><br></pre></td></tr></table></figure><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><blockquote><p>passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><p>参考：<a href="http://man.linuxde.net/passwd">http://man.linuxde.net/passwd</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是普通用户执行 passwd 只能修改自己的密码。</span></span><br><span class="line"><span class="comment"># 如果新建用户后，要为新用户创建密码，则用 passwd 用户名，注意要以 root 用户的权限来创建。</span></span><br><span class="line">$ passwd linuxde    <span class="comment"># 更改或创建linuxde用户的密码；</span></span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">New UNIX password:          <span class="comment"># 请输入新密码；</span></span><br><span class="line">Retype new UNIX password:   <span class="comment"># 再输入一次；</span></span><br><span class="line">passwd: all authentication tokens updated successfully. <span class="comment"># 成功；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通用户如果想更改自己的密码，直接运行 passwd 即可，比如当前操作的用户是 linuxde。</span></span><br><span class="line">$ passwd</span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde. <span class="comment"># 更改linuxde用户的密码；</span></span><br><span class="line">(current) UNIX password:   <span class="comment"># 请输入当前密码；</span></span><br><span class="line">New UNIX password:         <span class="comment"># 请输入新密码；</span></span><br><span class="line">Retype new UNIX password:  <span class="comment"># 确认新密码；</span></span><br><span class="line">passwd: all authentication tokens updated successfully. <span class="comment"># 更改成功；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如我们让某个用户不能修改密码，可以用`-l`选项来锁定：</span></span><br><span class="line">$ passwd -l linuxde    <span class="comment"># 锁定用户linuxde不能更改密码；</span></span><br><span class="line">Locking password <span class="keyword">for</span> user linuxde.</span><br><span class="line">passwd: Success           <span class="comment"># 锁定成功；</span></span><br><span class="line"></span><br><span class="line">$ su linuxde   <span class="comment"># 通过su切换到linuxde用户；</span></span><br><span class="line">$ passwd      <span class="comment"># linuxde来更改密码；</span></span><br><span class="line">Changing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">Changing password <span class="keyword">for</span> linuxde</span><br><span class="line">(current) UNIX password:          <span class="comment"># 输入linuxde的当前密码；</span></span><br><span class="line">passwd: Authentication token manipulation error     <span class="comment"># 失败，不能更改密码；</span></span><br><span class="line"></span><br><span class="line">$ passwd -d linuxde  <span class="comment"># 清除linuxde用户密码；</span></span><br><span class="line">Removing password <span class="keyword">for</span> user linuxde.</span><br><span class="line">passwd: Success                         <span class="comment"># 清除成功；</span></span><br><span class="line"></span><br><span class="line">$ passwd -S linuxde    <span class="comment"># 查询linuxde用户密码状态；</span></span><br><span class="line">Empty password.                         <span class="comment"># 空密码，也就是没有密码；</span></span><br></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><blockquote><p>su 命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号与密码。</p><p>参考：<a href="http://man.linuxde.net/su">http://man.linuxde.net/su</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变更帐号为 root 并在执行 ls 指令后退出变回原使用者：</span></span><br><span class="line">$ su -c <span class="built_in">ls</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更帐号为 root 并传入`-f`选项给新执行的 shell：</span></span><br><span class="line">$ su root -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变更帐号为 test 并改变工作目录至 test 的家目录：</span></span><br><span class="line">$ su -<span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><blockquote><p>sudo 命令用来以其他身份来执行命令，预设的身份为 root。在 <code>/etc/sudoers</code> 中设置了可执行 sudo 指令的用户。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码。</p><p>参考：<a href="http://man.linuxde.net/sudo">http://man.linuxde.net/sudo</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定用户执行命令</span></span><br><span class="line">$ sudo -u userb <span class="built_in">ls</span> -l</span><br><span class="line"><span class="comment"># 列出目前的权限</span></span><br><span class="line">$ sudo -l</span><br><span class="line"><span class="comment"># 显示sudo设置</span></span><br><span class="line">$ sudo -L</span><br></pre></td></tr></table></figure><h5 id="给普通用户授权-sudo"><a href="#给普通用户授权-sudo" class="headerlink" title="给普通用户授权 sudo"></a>给普通用户授权 sudo</h5><p>假设要给普通用户 mary 配置 sudo 权限：</p><ol><li><code>/etc/sudoers</code> 文件存放了 sudo 的相关用户，但是默认是没有写权限的，所以需要设为可写：<code>chmod u+w /etc/sudoers</code></li><li>在该文件中添加 <code>mary ALL=(ALL) ALL</code> ，保存并退出，让 mary 具有 sudo 的所有权限</li><li>再将 <code>/etc/sudoers</code> 的权限恢复到默认状态：<code>chmod u-w /etc/sudoers</code></li></ol><h5 id="免密码授权-sudo"><a href="#免密码授权-sudo" class="headerlink" title="免密码授权 sudo"></a>免密码授权 sudo</h5><p>与给普通用户授权 sudo 类似，区别仅在于第 2 步：<code>mary ALL=(ALL) NOPASSWD: ALL</code>。</p><h2 id="Linux-系统管理命令"><a href="#Linux-系统管理命令" class="headerlink" title="Linux 系统管理命令"></a>Linux 系统管理命令</h2><blockquote><p>关键词：<code>lsb_release</code>, <code>reboot</code>, <code>exit</code>, <code>shutdown</code>, <code>date</code>, <code>mount</code>, <code>umount</code>, <code>ps</code>, <code>kill</code>, <code>systemctl</code>, <code>service</code>, <code>crontab</code></p></blockquote><h3 id="系统管理要点"><a href="#系统管理要点" class="headerlink" title="系统管理要点"></a>系统管理要点</h3><ul><li>查看 Linux 系统发行版本<ul><li>使用 lsb_release（此命令适用于所有的 Linux 发行版本）</li><li>使用 <code>cat /etc/redhat-release</code>（此方法只适合 Redhat 系的 Linux）</li></ul></li><li>查看 CPU 信息 - 使用 <code>cat /proc/cpuinfo</code></li><li>重新启动 Linux 操作系统 - 使用 reboot</li><li>退出 shell，并返回给定值 - 使用 exit</li><li>关闭系统 - 使用 shutdown</li><li>查看或设置系统时间与日期 - 使用 date</li><li><strong>挂载文件系统 - 使用 mount</strong></li><li>取消挂载文件系统 - 使用 umount</li><li><strong>查看系统当前进程状态 - 使用 ps</strong></li><li><strong>删除当前正在运行的进程 - 使用 kill</strong></li><li><strong>启动、停止、重启、关闭、显示系统服务（Centos7），使用 systemctl</strong></li><li>启动、停止、重启、关闭、显示系统服务（Centos7 以前），使用 service</li><li>管理需要周期性执行的任务，使用 crontab</li></ul><h3 id="命令常见用法-5"><a href="#命令常见用法-5" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="lsb-release"><a href="#lsb-release" class="headerlink" title="lsb_release"></a>lsb_release</h4><p>lsb_release 不是 bash 默认命令，如果要使用，需要先安装。</p><p>安装方法：</p><ol><li>执行 <code>yum provides lsb_release</code>，查看支持 lsb_release 命令的包。</li><li>选择合适版本，执行类似这样的安装命令：<code>yum install -y redhat-lsb-core-4.1-27.el7.centos.1.x86_64</code></li></ol><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><blockquote><p>reboot 命令用来重新启动正在运行的 Linux 操作系统。</p><p>参考：<a href="http://man.linuxde.net/reboot">http://man.linuxde.net/reboot</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot        <span class="comment"># 重开机。</span></span><br><span class="line">reboot -w     <span class="comment"># 做个重开机的模拟（只有纪录并不会真的重开机）。</span></span><br></pre></td></tr></table></figure><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><blockquote><p>exit 命令同于退出 shell，并返回给定值。在 shell 脚本中可以终止当前脚本执行。执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。</p><p>参考：<a href="http://man.linuxde.net/exit">http://man.linuxde.net/exit</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 退出当前 shell</span></span><br><span class="line">[root@localhost ~]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，进入脚本所在目录，否则退出</span></span><br><span class="line"><span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$0</span>) || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，判断参数数量，不匹配就打印使用方式，退出</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -ne <span class="string">&quot;2&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;usage: <span class="variable">$0</span> &lt;area&gt; &lt;hours&gt;&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在脚本中，退出时删除临时文件</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f tmpfile; echo Bye.&quot;</span> EXIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查上一命令的退出码</span></span><br><span class="line">./mycommand.sh</span><br><span class="line">EXCODE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$EXCODE</span>&quot;</span> == <span class="string">&quot;0&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;O.K&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><blockquote><p>shutdown 命令用来系统关机命令。shutdown 指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。</p><p>参考：<a href="http://man.linuxde.net/shutdown">http://man.linuxde.net/shutdown</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定现在立即关机</span></span><br><span class="line">shutdown -h now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 5 分钟后关机，同时送出警告信息给登入用户</span></span><br><span class="line">shutdown +5 <span class="string">&quot;System will shutdown after 5 minutes&quot;</span></span><br></pre></td></tr></table></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><blockquote><p>date 命令是显示或设置系统时间与日期。</p><p>参考：<a href="http://man.linuxde.net/date">http://man.linuxde.net/date</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d&quot;</span></span><br><span class="line">2009-12-07</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出昨天日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;1 day ago&quot;</span> +<span class="string">&quot;%Y-%m-%d&quot;</span></span><br><span class="line">2012-11-19</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 秒后输出</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;2 second&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2012-11-20 14:21.31</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传说中的 1234567890 秒</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;1970-01-01 1234567890 seconds&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%m:%S&quot;</span></span><br><span class="line">2009-02-13 23:02:30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通转格式</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;2009-12-12&quot;</span> +<span class="string">&quot;%Y/%m/%d %H:%M.%S&quot;</span></span><br><span class="line">2009/12/12 00:00.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># apache 格式转换</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;Dec 5, 2009 12:00:37 AM&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2009-12-05 00:00.37</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式转换后时间游走</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;Dec 5, 2009 12:00:37 AM 2 year ago&quot;</span> +<span class="string">&quot;%Y-%m-%d %H:%M.%S&quot;</span></span><br><span class="line">2007-12-05 00:00.37</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加减操作</span></span><br><span class="line"><span class="built_in">date</span> +%Y%m%d                   <span class="comment"># 显示前天年月日</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示前一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 day&quot;</span> +%Y%m%d       <span class="comment"># 显示后一天的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示上一月的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 month&quot;</span> +%Y%m%d     <span class="comment"># 显示下一月的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示前一年的日期</span></span><br><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;+1 year&quot;</span> +%Y%m%d      <span class="comment"># 显示下一年的日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定时间</span></span><br><span class="line"><span class="built_in">date</span> -s                        <span class="comment"># 设置当前时间，只有root权限才能设置，其他只能查看</span></span><br><span class="line"><span class="built_in">date</span> -s 20120523               <span class="comment"># 设置成20120523，这样会把具体时间设置成空00:00:00</span></span><br><span class="line"><span class="built_in">date</span> -s 01:01:01               <span class="comment"># 设置具体时间，不会对日期做更改</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01:01:01 2012-05-23&quot;</span>  <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;01:01:01 20120523&quot;</span>    <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2012-05-23 01:01:01&quot;</span>  <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;20120523 01:01:01&quot;</span>    <span class="comment"># 这样可以设置全部时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时需要检查一组命令花费的时间</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">start=$(<span class="built_in">date</span> +%s)</span><br><span class="line">nmap man.linuxde.net &amp;&gt; /dev/null</span><br><span class="line"></span><br><span class="line">end=$(<span class="built_in">date</span> +%s)</span><br><span class="line">difference=$(( end - start ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$difference</span> seconds.</span><br></pre></td></tr></table></figure><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><blockquote><p>mount 命令用于挂载文件系统到指定的挂载点。此命令的最常用于挂载 cdrom，使我们可以访问 cdrom 中的数据，因为你将光盘插入 cdrom 中，Linux 并不会自动挂载，必须使用 Linux mount 命令来手动完成挂载。</p><p>参考：<a href="http://man.linuxde.net/mount">http://man.linuxde.net/mount</a> &gt; <a href="https://blog.csdn.net/weishujie000/article/details/76531924">https://blog.csdn.net/weishujie000/article/details/76531924</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 /dev/hda1 挂在 /mnt 之下</span></span><br><span class="line">mount /dev/hda1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 /dev/hda1 用唯读模式挂在 /mnt 之下</span></span><br><span class="line">mount -o ro /dev/hda1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom 之下</span></span><br><span class="line"><span class="comment"># 用这种方法可以将一般网络上可以找到的 Linux ISO 在不烧录成光碟的情况下检视其内容</span></span><br><span class="line">mount -o loop /tmp/image.iso /mnt/cdrom</span><br></pre></td></tr></table></figure><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><blockquote><p>umount 命令用于卸载已经挂载的文件系统。利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。</p><p>参考：<a href="http://man.linuxde.net/umount">http://man.linuxde.net/umount</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设备名卸载</span></span><br><span class="line">umount -v /dev/sda1</span><br><span class="line">/dev/sda1 umounted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过挂载点卸载</span></span><br><span class="line">umount -v /mnt/mymount/</span><br><span class="line">/tmp/diskboot.img umounted</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><blockquote><p>ps 命令用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p><p>参考：<a href="http://man.linuxde.net/ps">http://man.linuxde.net/ps</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按内存资源的使用量对进程进行排序</span></span><br><span class="line">ps aux | <span class="built_in">sort</span> -rnk 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按 CPU 资源的使用量对进程进行排序</span></span><br><span class="line">ps aux | <span class="built_in">sort</span> -nk 3</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><blockquote><p>kill 命令用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。</p><p>参考：<a href="http://man.linuxde.net/kill">http://man.linuxde.net/kill</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有信号名称</span></span><br><span class="line"> <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</span><br><span class="line"> 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU</span><br><span class="line">25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH</span><br><span class="line">29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先用 ps 查找进程，然后用 kill 杀掉</span></span><br><span class="line">ps -ef | grep vim</span><br><span class="line">root      3268  2884  0 16:21 pts/1    00:00:00 vim install.log</span><br><span class="line">root      3370  2822  0 16:21 pts/0    00:00:00 grep vim</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> 3268</span><br><span class="line"><span class="built_in">kill</span> 3268</span><br><span class="line">-bash: <span class="built_in">kill</span>: (3268) - 没有那个进程</span><br></pre></td></tr></table></figure><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><blockquote><p>systemctl 命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。</p><p>参考：<a href="http://man.linuxde.net/systemctl">http://man.linuxde.net/systemctl</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.启动 nfs 服务</span></span><br><span class="line">systemctl start nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.停止开机自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看服务当前状态</span></span><br><span class="line">systemctl status nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.重新启动某服务</span></span><br><span class="line">systemctl restart nfs-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看所有已启动的服务</span></span><br><span class="line">systemctl list -units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 开启防火墙 22 端口</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 22 -j accept</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 彻底关闭防火墙</span></span><br><span class="line">sudo systemctl status firewalld.service</span><br><span class="line">sudo systemctl stop firewalld.service</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><blockquote><p>service 命令是 Redhat Linux 兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p><p>参考：<a href="http://man.linuxde.net/service">http://man.linuxde.net/service</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service network status</span><br><span class="line">配置设备：</span><br><span class="line">lo eth0</span><br><span class="line">当前的活跃设备：</span><br><span class="line">lo eth0</span><br><span class="line"></span><br><span class="line">service network restart</span><br><span class="line">正在关闭接口 eth0：                                        [  确定  ]</span><br><span class="line">关闭环回接口：                                             [  确定  ]</span><br><span class="line">设置网络参数：                                             [  确定  ]</span><br><span class="line">弹出环回接口：                                             [  确定  ]</span><br><span class="line">弹出界面 eth0：                                            [  确定  ]</span><br></pre></td></tr></table></figure><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><blockquote><p>crontab 命令被用来提交和管理用户的需要周期性执行的任务，与 windows 下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>参考：<a href="http://man.linuxde.net/crontab">http://man.linuxde.net/crontab</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每 1 分钟执行一次 command</span></span><br><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 * * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 */2 * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个星期一的上午 8 点到 11 点的第 3 和第 15 分钟执行</span></span><br><span class="line">3,15 8-11 * * 1 <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每晚的 21:30 重启 smb</span></span><br><span class="line">30 21 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月 1、10、22 日的 4 : 45 重启 smb</span></span><br><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每周六、周日的 1:10 重启 smb</span></span><br><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 smb</span></span><br><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每星期六的晚上 11:00 pm 重启 smb</span></span><br><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一小时重启 smb</span></span><br><span class="line">* */1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 晚上 11 点到早上 7 点之间，每隔一小时重启 smb</span></span><br><span class="line">* 23-7/1 * * * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每月的 4 号与每周一到周三的 11 点重启 smb</span></span><br><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一月一号的 4 点重启 smb</span></span><br><span class="line">0 4 1 jan * /etc/init.d/smb restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时执行`/etc/cron.hourly`目录内的脚本</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure><h2 id="Linux-网络管理命令"><a href="#Linux-网络管理命令" class="headerlink" title="Linux 网络管理命令"></a>Linux 网络管理命令</h2><h3 id="Linux-网络应用要点"><a href="#Linux-网络应用要点" class="headerlink" title="Linux 网络应用要点"></a>Linux 网络应用要点</h3><ul><li><strong>下载文件 - 使用 curl、wget</strong></li><li><strong>telnet 方式登录远程主机，对远程主机进行管理 - 使用 telnet</strong></li><li><strong>查看或操纵 Linux 主机的路由、网络设备、策略路由和隧道 - 使用 ip</strong></li><li>查看和设置系统的主机名 - 使用 hostname</li><li><strong>查看和配置 Linux 内核中网络接口的网络参数 - 使用 ifconfig</strong></li><li><strong>查看和设置 Linux 内核中的网络路由表 - 使用 route</strong></li><li><strong>ssh 方式连接远程主机 - 使用 ssh</strong></li><li><strong>为 ssh 生成、管理和转换认证密钥 - 使用 ssh-keygen</strong></li><li><strong>查看、设置防火墙（Centos7），使用 firewalld</strong></li><li>查看、设置防火墙（Centos7 以前），使用 iptables</li><li>查看域名信息 - 使用 host, nslookup</li><li>设置路由 - 使用 nc/netcat</li><li><strong>测试主机之间网络是否连通 - 使用 ping</strong></li><li>追踪数据在网络上的传输时的全部路径 - 使用 traceroute</li><li><strong>查看当前工作的端口信息 - 使用 netstat</strong></li></ul><h3 id="命令常见用法-6"><a href="#命令常见用法-6" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote><p>curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl 可以祝一臂之力。</p><p>参考：<a href="http://man.linuxde.net/curl">http://man.linuxde.net/curl</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">$ curl http://man.linuxde.net/text.iso --silent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件，指定下载路径，并查看进度</span></span><br><span class="line">$ curl http://man.linuxde.net/test.iso -o filename.iso --progress</span><br><span class="line"><span class="comment">########################################## 100.0%</span></span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><blockquote><p>wget 命令用来从指定的 URL 下载文件。</p><p>参考：<a href="http://man.linuxde.net/wget">http://man.linuxde.net/wget</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 wget 下载单个文件</span></span><br><span class="line">$ wget http://www.linuxde.net/testfile.zip</span><br></pre></td></tr></table></figure><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><blockquote><p>telnet 命令用于登录远程主机，对远程主机进行管理。</p><p>参考：<a href="http://man.linuxde.net/telnet">http://man.linuxde.net/telnet</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.2.10</span><br><span class="line">Trying 192.168.2.10...</span><br><span class="line">Connected to 192.168.2.10 (192.168.2.10).</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">    localhost (Linux release 2.6.18-274.18.1.el5 <span class="comment">#1 SMP Thu Feb 9 12:45:44 EST 2012) (1)</span></span><br><span class="line"></span><br><span class="line">login: root</span><br><span class="line">Password:</span><br><span class="line">Login incorrect</span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><blockquote><p>ip 命令用来查看或操纵 Linux 主机的路由、网络设备、策略路由和隧道，是 Linux 下较新的功能强大的网络配置工具。</p><p>参考：<a href="http://man.linuxde.net/ip">http://man.linuxde.net/ip</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ip <span class="built_in">link</span> show                     <span class="comment"># 查看网络接口信息</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 upi             <span class="comment"># 开启网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 down            <span class="comment"># 关闭网卡</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on      <span class="comment"># 开启网卡的混合模式</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc offi    <span class="comment"># 关闭网卡的混个模式</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 txqueuelen 1200 <span class="comment"># 设置网卡队列长度</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 mtu 1400        <span class="comment"># 设置网卡最大传输单元</span></span><br><span class="line">$ ip addr show     <span class="comment"># 查看网卡IP信息</span></span><br><span class="line">$ ip addr add 192.168.0.1/24 dev eth0 <span class="comment"># 设置eth0网卡IP地址192.168.0.1</span></span><br><span class="line">$ ip addr del 192.168.0.1/24 dev eth0 <span class="comment"># 删除eth0网卡IP地址</span></span><br><span class="line"></span><br><span class="line">$ ip route show <span class="comment"># 查看系统路由</span></span><br><span class="line">$ ip route add default via 192.168.1.254   <span class="comment"># 设置系统默认路由</span></span><br><span class="line">$ ip route list                 <span class="comment"># 查看路由信息</span></span><br><span class="line">$ ip route add 192.168.4.0/24  via  192.168.0.254 dev eth0 <span class="comment"># 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口</span></span><br><span class="line">$ ip route add default via  192.168.0.254  dev eth0        <span class="comment"># 设置默认网关为192.168.0.254</span></span><br><span class="line">$ ip route del 192.168.4.0/24   <span class="comment"># 删除192.168.4.0网段的网关</span></span><br><span class="line">$ ip route del default          <span class="comment"># 删除默认路由</span></span><br><span class="line">$ ip route delete 192.168.1.0/24 dev eth0 <span class="comment"># 删除路由</span></span><br></pre></td></tr></table></figure><h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><blockquote><p>hostname 命令用于查看和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改 <code>/etc/hosts</code> 和 <code>/etc/sysconfig/network</code> 的相关内容。</p><p>参考：<a href="http://man.linuxde.net/hostname">http://man.linuxde.net/hostname</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">AY1307311912260196fcZ</span><br></pre></td></tr></table></figure><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><blockquote><p>ifconfig 命令被用于查看和配置 Linux 内核中网络接口的网络参数。用 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p>参考：<a href="http://man.linuxde.net/ifconfig">http://man.linuxde.net/ifconfig</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络设备信息（激活状态的）</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51</span><br><span class="line">          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)</span><br></pre></td></tr></table></figure><h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><blockquote><p>route 命令用来查看和设置 Linux 内核中的网络路由表，route 命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。</p><p>参考：<a href="http://man.linuxde.net/route">http://man.linuxde.net/route</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前路由</span></span><br><span class="line">route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">112.124.12.0    *               255.255.252.0   U     0      0        0 eth1</span><br><span class="line">10.160.0.0      *               255.255.240.0   U     0      0        0 eth0</span><br><span class="line">192.168.0.0     10.160.15.247   255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      10.160.15.247   255.240.0.0     UG    0      0        0 eth0</span><br><span class="line">10.0.0.0        10.160.15.247   255.0.0.0       UG    0      0        0 eth0</span><br><span class="line">default         112.124.15.247  0.0.0.0         UG    0      0        0 eth1</span><br><span class="line"></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0    <span class="comment"># 添加网关/设置网关</span></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject      <span class="comment"># 屏蔽一条路由</span></span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0             <span class="comment"># 删除路由记录</span></span><br><span class="line">route add default gw 192.168.120.240                   <span class="comment"># 添加默认网关</span></span><br><span class="line">route del default gw 192.168.120.240                   <span class="comment"># 删除默认网关</span></span><br></pre></td></tr></table></figure><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><blockquote><p>ssh 命令是 openssh 套件中的客户端连接工具，可以给予 ssh 加密协议实现安全的远程登录服务器。</p><p>参考：<a href="http://man.linuxde.net/ssh">http://man.linuxde.net/ssh</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh 用户名@远程服务器地址</span></span><br><span class="line">ssh user1@172.24.210.101</span><br><span class="line"><span class="comment"># 指定端口</span></span><br><span class="line">ssh -p 2211 root@140.206.185.170</span><br></pre></td></tr></table></figure><p>引申阅读：<a href="https://linux.cn/article-8476-1.html">ssh 背后的故事(opens new window)</a></p><h4 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h4><blockquote><p>ssh-keygen 命令用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。</p><p>参考：<a href="http://man.linuxde.net/ssh-keygen">http://man.linuxde.net/ssh-keygen</a></p></blockquote><h4 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h4><blockquote><p>firewalld 命令是 Linux 上的防火墙软件（Centos7 默认防火墙）。</p><p>参考：<a href="https://www.cnblogs.com/moxiaoan/p/5683743.html">https://www.cnblogs.com/moxiaoan/p/5683743.html</a></p></blockquote><h5 id="1-firewalld-的基本使用"><a href="#1-firewalld-的基本使用" class="headerlink" title="1. firewalld 的基本使用"></a>1. firewalld 的基本使用</h5><ul><li>启动 - systemctl start firewalld</li><li>关闭 - systemctl stop firewalld</li><li>查看状态 - systemctl status firewalld</li><li>开机禁用 - systemctl disable firewalld</li><li>开机启用 - systemctl enable firewalld</li></ul><h5 id="2-使用-systemctl-管理-firewalld-服务"><a href="#2-使用-systemctl-管理-firewalld-服务" class="headerlink" title="2. 使用 systemctl 管理 firewalld 服务"></a>2. 使用 systemctl 管理 firewalld 服务</h5><p>systemctl 是 CentOS7 的服务管理工具中主要的工具，它融合之前 service 和 chkconfig 的功能于一体。</p><ul><li>启动一个服务 - systemctl start firewalld.service</li><li>关闭一个服务 - systemctl stop firewalld.service</li><li>重启一个服务 - systemctl restart firewalld.service</li><li>显示一个服务的状态 - systemctl status firewalld.service</li><li>在开机时启用一个服务 - systemctl enable firewalld.service</li><li>在开机时禁用一个服务 - systemctl disable firewalld.service</li><li>查看服务是否开机启动 - systemctl is-enabled firewalld.service</li><li>查看已启动的服务列表 - systemctl list-unit-files|grep enabled</li><li>查看启动失败的服务列表 - systemctl —failed</li></ul><h5 id="3-配置-firewalld-cmd"><a href="#3-配置-firewalld-cmd" class="headerlink" title="3. 配置 firewalld-cmd"></a>3. 配置 firewalld-cmd</h5><ul><li>查看版本 - firewall-cmd —version</li><li>查看帮助 - firewall-cmd —help</li><li>显示状态 - firewall-cmd —state</li><li>查看所有打开的端口 - firewall-cmd —zone=public —list-ports</li><li>更新防火墙规则 - firewall-cmd —reload</li><li>查看区域信息: firewall-cmd —get-active-zones</li><li>查看指定接口所属区域 - firewall-cmd —get-zone-of-interface=eth0</li><li>拒绝所有包：firewall-cmd —panic-on</li><li>取消拒绝状态 - firewall-cmd —panic-off</li><li>查看是否拒绝 - firewall-cmd —query-panic</li></ul><h5 id="4-在防火墙中开放一个端口"><a href="#4-在防火墙中开放一个端口" class="headerlink" title="4. 在防火墙中开放一个端口"></a>4. 在防火墙中开放一个端口</h5><ul><li>添加（—permanent 永久生效，没有此参数重启后失效） - firewall-cmd —zone=public —add-port=80/tcp —permanent</li><li>重新载入 - firewall-cmd —reload</li><li>查看 - firewall-cmd —zone= public —query-port=80/tcp</li><li>删除 - firewall-cmd —zone= public —remove-port=80/tcp —permanent</li></ul><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><blockquote><p>iptables 命令是 Linux 上常用的防火墙软件，是 netfilter 项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。</p><p>参考：<a href="http://man.linuxde.net/iptables">http://man.linuxde.net/iptables</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放指定的端口</span></span><br><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               <span class="comment">#允许本地回环接口(即运行本机访问本机)</span></span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    <span class="comment">#允许已建立的或相关连的通行</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT         <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    <span class="comment">#允许访问22端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    <span class="comment">#允许访问80端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT    <span class="comment">#允许ftp服务的21端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT    <span class="comment">#允许FTP服务的20端口</span></span><br><span class="line">iptables -A INPUT -j reject       <span class="comment">#禁止其他未允许的规则访问</span></span><br><span class="line">iptables -A FORWARD -j REJECT     <span class="comment">#禁止其他未允许的规则访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 屏蔽IP</span></span><br><span class="line">iptables -I INPUT -s 123.45.6.7 -j DROP       <span class="comment">#屏蔽单个IP的命令</span></span><br><span class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP      <span class="comment">#封整个段即从123.0.0.1到123.255.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP    <span class="comment">#封IP段即从123.45.0.1到123.45.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP    <span class="comment">#封IP段即从123.45.6.1到123.45.6.254的命令是</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已添加的iptables规则</span></span><br><span class="line">iptables -L -n -v</span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><blockquote><p>host 命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。</p><p>参考：<a href="http://man.linuxde.net/host">http://man.linuxde.net/host</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># host www.jsdig.com</span></span><br><span class="line">www.jsdig.com is an <span class="built_in">alias</span> <span class="keyword">for</span> host.1.jsdig.com.</span><br><span class="line">host.1.jsdig.com has address 100.42.212.8</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># host -a www.jsdig.com</span></span><br><span class="line">Trying <span class="string">&quot;www.jsdig.com&quot;</span></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 34671</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.jsdig.com.               IN      ANY</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.jsdig.com.        463     IN      CNAME   host.1.jsdig.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Received 54 bytes from 202.96.104.15#53 in 0 ms</span></span><br></pre></td></tr></table></figure><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><blockquote><p>nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。</p><p>参考：<a href="http://man.linuxde.net/nslookup">http://man.linuxde.net/nslookup</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nslookup www.jsdig.com</span></span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.jsdig.com canonical name = host.1.jsdig.com.</span><br><span class="line">Name:   host.1.jsdig.com</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure><h4 id="nc-netcat"><a href="#nc-netcat" class="headerlink" title="nc/netcat"></a>nc/netcat</h4><blockquote><p>nc 命令是 netcat 命令的简称，都是用来设置路由器。</p><p>参考：<a href="http://man.linuxde.net/nc_netcat">http://man.linuxde.net/nc_netcat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP 端口扫描</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -v -z -w2 192.168.0.3 1-100</span></span><br><span class="line">192.168.0.3: inverse host lookup failed: Unknown host</span><br><span class="line">(UNKNOWN) [192.168.0.3] 80 (http) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 23 (telnet) open</span><br><span class="line">(UNKNOWN) [192.168.0.3] 22 (ssh) open</span><br><span class="line"></span><br><span class="line"><span class="comment"># UDP 端口扫描</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nc -u -z -w2 192.168.0.1 1-1000  # 扫描192.168.0.3 的端口 范围是 1-1000</span></span><br></pre></td></tr></table></figure><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><blockquote><p>ping 命令用来测试主机之间网络的连通性。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>参考：<a href="http://man.linuxde.net/ping">http://man.linuxde.net/ping</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@AY1307311912260196fcZ ~]<span class="comment"># ping www.jsdig.com</span></span><br><span class="line">PING host.1.jsdig.com (100.42.212.8) 56(84) bytes of data.</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=1 ttl=50 time=177 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=2 ttl=50 time=178 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=3 ttl=50 time=174 ms</span><br><span class="line">64 bytes from 100-42-212-8.static.webnx.com (100.42.212.8): icmp_seq=4 ttl=50 time=177 ms</span><br><span class="line">...按Ctrl+C结束</span><br><span class="line"></span><br><span class="line">--- host.1.jsdig.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2998ms</span><br><span class="line">rtt min/avg/max/mdev = 174.068/176.916/178.182/1.683 ms</span><br></pre></td></tr></table></figure><h4 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h4><blockquote><p>traceroute 命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是 40 字节。</p><p>参考：<a href="http://man.linuxde.net/traceroute">http://man.linuxde.net/traceroute</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.58.com</span><br><span class="line">traceroute to www.58.com (211.151.111.30), 30 hops max, 40 byte packets</span><br><span class="line"> 1  unknown (192.168.2.1)  3.453 ms  3.801 ms  3.937 ms</span><br><span class="line"> 2  221.6.45.33 (221.6.45.33)  7.768 ms  7.816 ms  7.840 ms</span><br><span class="line"> 3  221.6.0.233 (221.6.0.233)  13.784 ms  13.827 ms 221.6.9.81 (221.6.9.81)  9.758 ms</span><br><span class="line"> 4  221.6.2.169 (221.6.2.169)  11.777 ms 122.96.66.13 (122.96.66.13)  34.952 ms 221.6.2.53 (221.6.2.53)  41.372 ms</span><br><span class="line"> 5  219.158.96.149 (219.158.96.149)  39.167 ms  39.210 ms  39.238 ms</span><br><span class="line"> 6  123.126.0.194 (123.126.0.194)  37.270 ms 123.126.0.66 (123.126.0.66)  37.163 ms  37.441 ms</span><br><span class="line"> 7  124.65.57.26 (124.65.57.26)  42.787 ms  42.799 ms  42.809 ms</span><br><span class="line"> 8  61.148.146.210 (61.148.146.210)  30.176 ms 61.148.154.98 (61.148.154.98)  32.613 ms  32.675 ms</span><br><span class="line"> 9  202.106.42.102 (202.106.42.102)  44.563 ms  44.600 ms  44.627 ms</span><br><span class="line">10  210.77.139.150 (210.77.139.150)  53.302 ms  53.233 ms  53.032 ms</span><br><span class="line">11  211.151.104.6 (211.151.104.6)  39.585 ms  39.502 ms  39.598 ms</span><br><span class="line">12  211.151.111.30 (211.151.111.30)  35.161 ms  35.938 ms  36.005 ms</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><blockquote><p>netstat 命令用来打印 Linux 中网络系统的状态信息，可让你得知整个 Linux 系统的网络情况。</p><p>参考：<a href="http://man.linuxde.net/netstat">http://man.linuxde.net/netstat</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有端口 (包括监听和未监听的)</span></span><br><span class="line">netstat -a     <span class="comment">#列出所有端口</span></span><br><span class="line">netstat -at    <span class="comment">#列出所有tcp端口</span></span><br><span class="line">netstat -au    <span class="comment">#列出所有udp端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有处于监听状态的 Sockets</span></span><br><span class="line">netstat -l        <span class="comment">#只显示监听端口</span></span><br><span class="line">netstat -lt       <span class="comment">#只列出所有监听 tcp 端口</span></span><br><span class="line">netstat -lu       <span class="comment">#只列出所有监听 udp 端口</span></span><br><span class="line">netstat -lx       <span class="comment">#只列出所有监听 UNIX 端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示每个协议的统计信息</span></span><br><span class="line">netstat -s   显示所有端口的统计信息</span><br><span class="line">netstat -st   显示TCP端口的统计信息</span><br><span class="line">netstat -su   显示UDP端口的统计信息</span><br></pre></td></tr></table></figure><h2 id="Linux-硬件管理命令"><a href="#Linux-硬件管理命令" class="headerlink" title="Linux 硬件管理命令"></a>Linux 硬件管理命令</h2><h3 id="Linux-硬件管理要点"><a href="#Linux-硬件管理要点" class="headerlink" title="Linux 硬件管理要点"></a>Linux 硬件管理要点</h3><ul><li><strong>查看磁盘空间 - 使用 df</strong></li><li>查看文件或目录的磁盘空间 - 使用 du</li><li><strong>实时查看系统整体运行状态（如：CPU、内存） - 使用 top</strong></li><li><strong>查看已使用和未使用的内存 - 使用 free</strong></li><li>查看磁盘 I/O 使用状况 - 使用 iotop</li></ul><h3 id="命令常见用法-7"><a href="#命令常见用法-7" class="headerlink" title="命令常见用法"></a>命令常见用法</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><blockquote><p>df 命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为 KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>参考：<a href="http://man.linuxde.net/df">http://man.linuxde.net/df</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统磁盘设备，默认是 KB 为单位</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df</span></span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -h 选项以 KB 以上的单位来显示，可读性高</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df -h</span></span><br><span class="line">文件系统              容量  已用 可用 已用% 挂载点</span><br><span class="line">/dev/sda2             140G   27G  106G  21% /</span><br><span class="line">/dev/sda1             996M   61M  884M   7% /boot</span><br><span class="line">tmpfs                1009M     0 1009M   0% /dev/shm</span><br><span class="line">/dev/sdb1             2.7T  209G  2.4T   8% /data1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全部文件系统</span></span><br><span class="line">[root@LinServ-1 ~]<span class="comment"># df -a</span></span><br><span class="line">文件系统               1K-块        已用     可用 已用% 挂载点</span><br><span class="line">/dev/sda2            146294492  28244432 110498708  21% /</span><br><span class="line">proc                         0         0         0   -  /proc</span><br><span class="line">sysfs                        0         0         0   -  /sys</span><br><span class="line">devpts                       0         0         0   -  /dev/pts</span><br><span class="line">/dev/sda1              1019208     62360    904240   7% /boot</span><br><span class="line">tmpfs                  1032204         0   1032204   0% /dev/shm</span><br><span class="line">/dev/sdb1            2884284108 218826068 2518944764   8% /data1</span><br><span class="line">none                         0         0         0   -  /proc/sys/fs/binfmt_misc</span><br></pre></td></tr></table></figure><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><blockquote><p>du 命令也是查看使用空间的，但是与 df 命令不同的是：du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的。</p><p>参考：<a href="http://man.linuxde.net/du">http://man.linuxde.net/du</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示目录或者文件所占空间</span></span><br><span class="line">root@localhost [<span class="built_in">test</span>]<span class="comment"># du</span></span><br><span class="line">608 ./test6</span><br><span class="line">308 ./test4</span><br><span class="line">4 ./scf/lib</span><br><span class="line">4 ./scf/service/deploy/product</span><br><span class="line">4 ./scf/service/deploy/info</span><br><span class="line">12 ./scf/service/deploy</span><br><span class="line">16 ./scf/service</span><br><span class="line">4 ./scf/doc</span><br><span class="line">4 ./scf/bin</span><br><span class="line">32 ./scf</span><br><span class="line">8 ./test3</span><br><span class="line">1288 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du log2012.log</span></span><br><span class="line">300 log2012.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定目录的所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du scf</span></span><br><span class="line">4 scf/lib</span><br><span class="line">4 scf/service/deploy/product</span><br><span class="line">4 scf/service/deploy/info</span><br><span class="line">12 scf/service/deploy</span><br><span class="line">16 scf/service</span><br><span class="line">4 scf/doc</span><br><span class="line">4 scf/bin</span><br><span class="line">32 scf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示多个文件所占空间</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du log30.tar.gz log31.tar.gz</span></span><br><span class="line">4 log30.tar.gz</span><br><span class="line">4 log31.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示总和的大小</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du -s</span></span><br><span class="line">1288 .</span><br><span class="line"></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># du -s scf</span></span><br><span class="line">32 scf</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><blockquote><p>top 命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。</p><p>参考：<a href="http://man.linuxde.net/top">http://man.linuxde.net/top</a></p></blockquote><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><blockquote><p>free 命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p><p>参考：<a href="http://man.linuxde.net/free">http://man.linuxde.net/free</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">free -t    <span class="comment"># 以总和的形式显示内存的使用信息</span></span><br><span class="line">free -s 10 <span class="comment"># 周期性的查询内存使用信息，每10s 执行一次命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示内存使用情况</span></span><br><span class="line"></span><br><span class="line">free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          2016       1973         42          0        163       1497</span><br><span class="line">-/+ buffers/cache:        312       1703</span><br><span class="line">Swap:         4094          0       4094</span><br></pre></td></tr></table></figure><h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><blockquote><p>iotop 命令是一个用来监视磁盘 I/O 使用状况的 top 类工具。iotop 具有与 top 相似的 UI，其中包括 PID、用户、I/O、进程等相关信息。Linux 下的 IO 统计工具如 iostat，nmon 等大多数是只能统计到 per 设备的读写情况，如果你想知道每个进程是如何使用 IO 的就比较麻烦，使用 iotop 命令可以很方便的查看。</p><p>参考：<a href="http://man.linuxde.net/iotop">http://man.linuxde.net/iotop</a></p></blockquote><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Total DISK <span class="built_in">read</span>:       0.00 B/s | Total DISK write:       0.00 B/s</span><br><span class="line">  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    <span class="built_in">command</span></span><br><span class="line">    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init [3]</span><br><span class="line">    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line">    3 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">    4 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">    5 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/0]</span><br><span class="line">    6 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/1]</span><br><span class="line">    7 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/1]</span><br><span class="line">    8 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [watchdog/1]</span><br><span class="line">    9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [events/0]</span><br><span class="line">   10 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [events/1]</span><br><span class="line">   11 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [khelper]</span><br><span class="line">2572 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [bluetooth]</span><br></pre></td></tr></table></figure><h2 id="Linux-软件管理命令"><a href="#Linux-软件管理命令" class="headerlink" title="Linux 软件管理命令"></a>Linux 软件管理命令</h2><h3 id="1-rpm"><a href="#1-rpm" class="headerlink" title="1. rpm"></a>1. rpm</h3><blockquote><p>rpm 命令是 RPM 软件包的管理工具。rpm 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p><p>参考：<a href="http://man.linuxde.net/rpm">http://man.linuxde.net/rpm</a></p></blockquote><p>示例：</p><p>（1）安装 rpm 包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh xxx.rpm</span><br></pre></td></tr></table></figure><p>（2）安装.src.rpm 软件包</p><p>这类软件包是包含了源代码的 rpm 包，在安装时需要进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -i xxx.src.rpm</span><br><span class="line"><span class="built_in">cd</span> /usr/src/redhat/SPECS</span><br><span class="line">rpmbuild -bp xxx.specs             <span class="comment">#一个和你的软件包同名的specs文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/src/redhat/BUILD/xxx/      <span class="comment">#一个和你的软件包同名的目录</span></span><br><span class="line">./configure                        <span class="comment">#这一步和编译普通的源码软件一样，可以加上参数</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>（3）卸载 rpm 软件包</p><p>使用命令 <code>rpm -e 包名</code>，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包 proftpd-1.2.8-1，可以使用下列格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1</span><br><span class="line">rpm -e proftpd-1.2.8</span><br><span class="line">rpm -e proftpd-</span><br><span class="line">rpm -e proftpd</span><br></pre></td></tr></table></figure><p>不可以是下列格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e proftpd-1.2.8-1.i386.rpm</span><br><span class="line">rpm -e proftpd-1.2.8-1.i386</span><br><span class="line">rpm -e proftpd-1.2</span><br><span class="line">rpm -e proftpd-1</span><br></pre></td></tr></table></figure><p>有时会出现一些错误或者警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... is needed by ...</span><br></pre></td></tr></table></figure><p>这说明这个软件被其他软件需要，不能随便卸载，可以用 rpm -e —nodeps 强制卸载</p><p>（4）查看与 rpm 包相关的文件和其他信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa <span class="comment"># 列出所有安装过的包</span></span><br></pre></td></tr></table></figure><h3 id="2-yum"><a href="#2-yum" class="headerlink" title="2. yum"></a>2. yum</h3><blockquote><p>yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理 RPM 软件包，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>参考：<a href="http://man.linuxde.net/yum">http://man.linuxde.net/yum</a></p></blockquote><p>示例：</p><p>部分常用的命令包括：</p><ul><li>自动搜索最快镜像插件：<code>yum install yum-fastestmirror</code></li><li>安装 yum 图形窗口插件：<code>yum install yumex</code></li><li>查看可能批量安装的列表：<code>yum grouplist</code></li></ul><p><strong>安装</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install              #全部安装</span><br><span class="line">yum install package1     #安装指定的安装包package1</span><br><span class="line">yum groupinsall group1   #安装程序组group1</span><br></pre></td></tr></table></figure><p><strong>更新和升级</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update               #全部更新</span><br><span class="line">yum update package1      #更新指定程序包package1</span><br><span class="line">yum check-update         #检查可更新的程序</span><br><span class="line">yum upgrade package1     #升级指定程序包package1</span><br><span class="line">yum groupupdate group1   #升级程序组group1</span><br></pre></td></tr></table></figure><p><strong>查找和显示</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum info package1      #显示安装包信息package1</span><br><span class="line">yum list               #显示所有已经安装和可以安装的程序包</span><br><span class="line">yum list package1      #显示指定程序包安装情况package1</span><br><span class="line">yum groupinfo group1   #显示程序组group1信息yum search string 根据关键字string查找安装包</span><br><span class="line">yum search &lt;keyword&gt;   #查找软件包</span><br></pre></td></tr></table></figure><p><strong>删除程序</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum remove &lt;package_name&gt;          #删除程序包package_name</span><br><span class="line">yum groupremove group1             #删除程序组group1</span><br><span class="line">yum deplist package1               #查看程序package1依赖情况</span><br></pre></td></tr></table></figure><p><strong>清除缓存</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean packages       #清除缓存目录下的软件包</span><br><span class="line">yum clean headers        #清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders     #清除缓存目录下旧的 headers</span><br></pre></td></tr></table></figure><h4 id="2-1-yum-源"><a href="#2-1-yum-源" class="headerlink" title="2.1. yum 源"></a>2.1. yum 源</h4><p>yum 的默认源是国外的，下载速度比较慢，所以最好替换为一个国内的 yum 源。</p><div class="table-container"><table><thead><tr><th>推荐 yum 国内源</th><th>源地址</th></tr></thead><tbody><tr><td><a href="http://mirrors.163.com/">http://mirrors.163.com/(opens new window)</a></td><td>Centos6：<a href="http://mirrors.aliyun.com/repo/Centos-6.repo">http://mirrors.aliyun.com/repo/Centos-6.repo</a> Centos7：<a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a></td></tr><tr><td><a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/(opens new window)</a></td><td>Centos6：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a> Centos7：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></td></tr></tbody></table></div><blockquote><p>🔔 注意：Cento5 已废弃，只能使用 <a href="http://vault.centos.org/">http://vault.centos.org/</a> 替换，但由于是国外镜像，速度较慢。</p></blockquote><p>替换方法，以 aliyun CentOS7 为例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h3 id="3-apt-get"><a href="#3-apt-get" class="headerlink" title="3. apt-get"></a>3. apt-get</h3><blockquote><p>apt-get 命令是 Debian Linux 发行版中的 APT 软件包管理工具。所有基于 Debian 的发行都使用这个包管理系统。deb 包可以把一个应用的文件包在一起，大体就如同 Windows 上的安装文件。</p><p>参考：<a href="http://man.linuxde.net/apt-get">http://man.linuxde.net/apt-get</a></p></blockquote><p>示例：</p><p>使用 apt-get 命令的第一步就是引入必需的软件库，Debian 的软件库也就是所有 Debian 软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get 就能搜索到我们想要的软件。/etc/apt/sources.list 是存放这些地址列表的配置文件，其格式如下：</p><p>deb [web 或 ftp 地址][发行版名字] [main/contrib/non-free] 我们常用的 Ubuntu 就是一个基于 Debian 的发行，我们使用 apt-get 命令获取这个列表，以下是我整理的常用命令：</p><p>在修改 /etc/apt/sources.list 或者 /etc/apt/preferences 之后运行该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 apt-get</span></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装一个软件包</span></span><br><span class="line">apt-get install packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载一个已安装的软件包（保留配置文件）</span></span><br><span class="line">apt-get remove packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载一个已安装的软件包（删除配置文件）</span></span><br><span class="line">apt-get –purge remove packagename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要空间的话，可以让这个命令来删除你已经删掉的软件</span></span><br><span class="line">apt-get autoclean apt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把安装的软件的备份也删除，不过这样不会影响软件的使用的</span></span><br><span class="line">apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新所有已安装的软件包</span></span><br><span class="line">apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将系统升级到新版本</span></span><br><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://dunwu.github.io/linux-tutorial/">https://dunwu.github.io/linux-tutorial/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/mingyry/4509351.html"/>
      <url>/mingyry/4509351.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="Java集合概况"><a href="#Java集合概况" class="headerlink" title="Java集合概况"></a>Java集合概况</h2><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-collection-hierarchy.png" alt="img"></p><h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h3><p><code>Collection</code> 接口下面的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><p><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</p></li><li><p><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></p></li><li><p><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</p></li><li><p><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</p></li></ul><h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h3><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><ul><li><p><code>RandomAccess</code> 是一个标志接口，表明实现这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p></li><li><p><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</p></li><li><p><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</p></li></ul><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别?"></a>ArrayList 和 Vector 的区别?</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的。</li></ul><h3 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h3><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了<code>`RandomAccess</code>接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="ArrayList扩容机制分析"><a href="#ArrayList扩容机制分析" class="headerlink" title="ArrayList扩容机制分析"></a>ArrayList扩容机制分析</h3><p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code></p><h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><h4 id="重写-compareTo-方法实现按年龄来排序"><a href="#重写-compareTo-方法实现按年龄来排序" class="headerlink" title="重写 compareTo 方法实现按年龄来排序"></a>重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><div class="table-container"><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table></div><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><div class="table-container"><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table></div><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h2 id="Map接口之HashMap"><a href="#Map接口之HashMap" class="headerlink" title="Map接口之HashMap"></a>Map接口之HashMap</h2><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h3 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h3><ul><li><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p></li><li><p>JDK1.8 以后在解决哈希冲突时有了较大的变化。</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p></li></ul><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul><li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p></li></ul><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。）</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>HashMap</code></th><th style="text-align:center"><code>HashSet</code></th></tr></thead><tbody><tr><td style="text-align:center">实现了 <code>Map</code> 接口</td><td style="text-align:center">实现 <code>Set</code> 接口</td></tr><tr><td style="text-align:center">存储键值对</td><td style="text-align:center">仅存储对象</td></tr><tr><td style="text-align:center">调用 <code>put()</code>向 map 中添加元素</td><td style="text-align:center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td style="text-align:center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td style="text-align:center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table></div><h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口</p><ul><li><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p></li><li><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p></li></ul><h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。</p><p>因为计算数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。</p><h3 id="HashMap-多线程的问题"><a href="#HashMap-多线程的问题" class="headerlink" title="HashMap 多线程的问题"></a>HashMap 多线程的问题</h3><h4 id="HashMap在多线程put后可能导致get无限循环"><a href="#HashMap在多线程put后可能导致get无限循环" class="headerlink" title="HashMap在多线程put后可能导致get无限循环"></a>HashMap在多线程put后可能导致get无限循环</h4><p><a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p><h4 id="多线程put的时候可能导致元素丢失"><a href="#多线程put的时候可能导致元素丢失" class="headerlink" title="多线程put的时候可能导致元素丢失"></a>多线程put的时候可能导致元素丢失</h4><p>考虑在多线程下put操作时，执行addEntry(hash, key, value, i)，如果有产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会出现覆盖丢失的情况。</p><h3 id="HashMap-有哪几种常见的遍历方式"><a href="#HashMap-有哪几种常见的遍历方式" class="headerlink" title="HashMap 有哪几种常见的遍历方式?"></a>HashMap <a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">有哪几种常见的遍历方式</a>?</h3><ol><li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each EntrySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 For Each KeySet 的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Lambda 表达式的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 单线程的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Streams API 多线程的方式进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><code>entrySet</code> 的性能比 <code>keySet</code> 的性能高出了一倍之多，因此我们应该尽量使用 <code>entrySet</code> 来实现 Map 集合的遍历</strong>。</p><p>我们不能在遍历中使用集合 <code>map.remove()</code> 来删除数据，这是非安全的操作方式，但我们可以使用迭代器的 <code>iterator.remove()</code> 的方法来删除数据，这是安全的删除集合的方式。同样的我们也可以使用 Lambda 中的 <code>removeIf</code> 来提前删除数据，或者是使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 <code>for</code> 循环前删除数据在遍历也是线程安全的。</p><p><strong>我们应该尽量使用迭代器（Iterator）来遍历 <code>EntrySet</code> 的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。</p><h2 id="Map接口之ConcurrentHashMap"><a href="#Map接口之ConcurrentHashMap" class="headerlink" title="Map接口之ConcurrentHashMap"></a>Map接口之ConcurrentHashMap</h2><p>参考文档 <a href="https://www.imooc.com/article/314726">https://www.imooc.com/article/314726</a></p><h3 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a>ConcurrentHashMap 的实现原理</h3><p><strong>JDK1.7</strong>：ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8bf6d4aa717a871c73d5d2699d822fed.png" alt="img" style="zoom: 80%;" /></p><p><strong>JDK1.8</strong>：选择了与 HashMap 相同的<strong>Node数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加细粒度的锁。</p><p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3e0ef497f95c88e6d409cd6f0737bfe3.png" alt="img" style="zoom:80%;" /></p><h3 id="JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？"><a href="#JDK1-8-中为什么使用内置锁-synchronized替换-可重入锁-ReentrantLock？" class="headerlink" title="JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？"></a>JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？</h3><ul><li><p>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</p></li><li><p>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p></li></ul><h3 id="ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><ol><li>尝试自旋获取锁。</li><li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li></ol><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><ol><li><p>根据 key 计算出 hash 值；</p></li><li><p>判断是否需要进行初始化；</p></li><li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p><ul><li>如果为 null ，则通过 CAS 的方式尝试添加；</li><li>如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；</li><li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</li></ul></li><li>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</li></ol><h3 id="ConcurrentHashMap-的-get-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-get-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 get 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 get 方法执行逻辑是什么？</h3><h4 id="JDK1-7-1"><a href="#JDK1-7-1" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><ol><li><p>根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p></li><li><p>HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p></li></ol><h4 id="JDK1-8-1"><a href="#JDK1-8-1" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><ol><li>根据 key 计算出 hash 值，判断数组是否为空；</li><li>如果是首节点，就直接返回；</li><li>如果是红黑树结构，就从红黑树里面查询；</li><li>如果是链表结构，循环遍历判断。</li></ol><h3 id="ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？"><a href="#ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？" class="headerlink" title="ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？"></a>ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h3><ul><li>我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</li></ul><p>而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p><p><strong>我们用反证法来推理：</strong></p><p>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p><p>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。</p><p>但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p><h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p></li><li><p>实现线程安全的方式（重要）：</p><ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>Hashtable</strong> :</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/jdk1.7_hashmap.png" alt="Hashtable 的内部结构"></p><p><strong>JDK1.8 的 ConcurrentHashMap</strong> ：</p></li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构" style="zoom:80%;" /></p><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对 putVal 方法添加元素的分析如下：</strong></p><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ol><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421170614212.png" alt="image-20230421170614212"></p><p>说明:上图有两个小问题：</p><ul><li>直接覆盖之后应该就会 return，不会有后续操作。。</li><li>当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JDK1.7 put 方法</strong>：头插法</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h3><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transfer函数</strong></p><p>transfer逻辑其实也简单，遍历旧数组，将旧数组元素通过头插法的方式，迁移到新数组的对应位置问题出就出在头插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    <span class="comment">//src旧数组</span></span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);<span class="comment">//由于是链表，所以是个循环过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发控制</title>
      <link href="/mingyry/a860421b.html"/>
      <url>/mingyry/a860421b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java并发控制"><a href="#Java并发控制" class="headerlink" title="Java并发控制"></a>Java并发控制</h2><h3 id="Volatile-关键词"><a href="#Volatile-关键词" class="headerlink" title="Volatile 关键词"></a>Volatile 关键词</h3><p>两个作用：</p><ol><li>保证变量的可见性：当我们将变量声明为<code>volatile</code>，这个变量是不稳定的，每次使用需要到主内存中进行读取</li><li>禁止指令重排序：当我们将变量声明为<code>volatile</code>，在对这个变量进行读写操作时，会通过插入特定的内存屏障来禁止指令重排序</li></ol><h4 id="利用双重校验锁来实现单例模式"><a href="#利用双重校验锁来实现单例模式" class="headerlink" title="利用双重校验锁来实现单例模式"></a>利用双重校验锁来实现单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 给类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); 一般分为三步执行：</span><br><span class="line">    <span class="number">1.</span> 为uniqueInstance 分配内存空间</span><br><span class="line">    <span class="number">2.</span> 初始化uniqueInstance</span><br><span class="line">    <span class="number">3.</span> 将uniqueInstance指向分配的内存地址</span><br><span class="line">如果没有禁止指令重排序，可能指令的执行顺序变为<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>，一个线程执行了<span class="number">1</span>，<span class="number">3</span>，另一个线程在判断对象是否为空时，得到uniqueInstance不为空，直接返回，但此时uniqueInstance还没有被初始化</span><br></pre></td></tr></table></figure><p><code>volatile</code>不能够保证原子性</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>共享资源每次只能有一个线程在使用，其他线程阻塞，用完后再将资源分配给其他线程，悲观锁通常用于写比较多的情况下（多写场景），避免频繁失败和重试影响性能</p><p><code>synchronized</code>和<code>ReentrantLock</code>等独占锁都是悲观锁的思想</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>在Java6之前属于<strong>重量级锁</strong>，Java6之后对其进行改进，引入了优化如自旋锁，偏向锁，轻量级锁等技术来减少锁的开销，提升了效率</p><h4 id="如何使用synchronized？"><a href="#如何使用synchronized？" class="headerlink" title="如何使用synchronized？"></a>如何使用synchronized？</h4><p>使用方式一般有三种：</p><h5 id="修饰实例方法（锁当前对象实例）"><a href="#修饰实例方法（锁当前对象实例）" class="headerlink" title="修饰实例方法（锁当前对象实例）"></a>修饰实例方法（锁当前对象实例）</h5><p>给当前对象实例加锁，进入同步代码块前要获得 <strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修饰静态方法（锁当前类）"><a href="#修饰静态方法（锁当前类）" class="headerlink" title="修饰静态方法（锁当前类）"></a>修饰静态方法（锁当前类）</h5><p>给当前类加锁，会作用于类的所有对象实例，进入同步代码块前要获取 <strong>当前class的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态<code>synchronized</code>和非静态<code>synchronized</code>的方法之间的调用是<strong>非互斥的</strong>，意思是，线程A调用一个实例对象的非静态<code>synchronized</code>方法，线程B调用这个实例对象所属类的静态<code>synchronized</code>方法，是允许的，不会发生互斥</p><h5 id="修饰代码块（锁指定对象或者类）"><a href="#修饰代码块（锁指定对象或者类）" class="headerlink" title="修饰代码块（锁指定对象或者类）"></a>修饰代码块（锁指定对象或者类）</h5><ul><li><code>synchronized(object)</code>表示进入同步代码块前要获取 <strong>给定对象的锁</strong></li><li><code>synchronized(类.class)</code>表示进入同步代码块前要获取 <strong>给定Class的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;  <span class="comment">// 给当前对象加锁</span></span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饿汉式单例模式的实现："><a href="#饿汉式单例模式的实现：" class="headerlink" title="饿汉式单例模式的实现："></a>饿汉式单例模式的实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    饿汉式：</span></span><br><span class="line"><span class="comment">    类加载时即创建对象，线程安全</span></span><br><span class="line"><span class="comment">    优点：执行效率高</span></span><br><span class="line"><span class="comment">    确定：类加载时就初始化，浪费内存资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newInstance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式单例模式的实现："><a href="#懒汉式单例模式的实现：" class="headerlink" title="懒汉式单例模式的实现："></a>懒汉式单例模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(newInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newInstance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    newInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 该方法不是原子性操作，会出现线程不安全</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">1.分配内存空间</span></span><br><span class="line"><span class="comment">2.执行方法构造，初始化内存</span></span><br><span class="line"><span class="comment">3.把对象指向内存空间</span></span><br><span class="line"><span class="comment">A-&gt; 1，3，2</span></span><br><span class="line"><span class="comment">B-&gt;此时进入，没执行到2，会直接返回，出现线程不安全</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法不能用synchronized进行修饰"><a href="#构造方法不能用synchronized进行修饰" class="headerlink" title="构造方法不能用synchronized进行修饰"></a>构造方法不能用synchronized进行修饰</h4><h4 id="synchronized-的JVM实现"><a href="#synchronized-的JVM实现" class="headerlink" title="synchronized 的JVM实现"></a>synchronized 的JVM实现</h4><ul><li>代码块同步：通过使用monitorenter和monitorexit指令来实现的</li><li>同步方法：ACC_SYNCHRONIZED实现的</li><li>二者本质都是对monitor对象监视器的获取</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/-----3.svg" alt="img" style="zoom: 67%;" /></p><p>四种情况：</p><ul><li><p>无锁状态：线程A访问同步代码块，当前没有锁，将利用CAS将偏向锁设置为线程A</p></li><li><p>偏向锁状态：</p><ul><li><p>线程A继续访问同步代码块，直接获取锁</p></li><li><p>线程B访问代码块，当前偏向锁为线程A，将偏向锁升级为轻量级的锁</p></li><li><p>偏向锁的撤销：</p><ul><li><p>对象是不可偏向状态</p><ol><li>不需要撤销</li></ol></li><li><p>对象是可偏向状态</p><ol><li><p>MarkWord 中指向的线程不存活</p><ol><li>允许重偏向：退回到可偏向但未偏向的状态</li><li>不允许重偏向：变为无锁状态</li></ol></li><li><p>MarkWord 中的线程存活</p><ol><li><p>线程ID指向的线程仍然拥有锁</p><ol><li>升级为轻量级锁，将 mark word 复制到线程栈中</li></ol></li><li><p>不再拥有锁</p><ol><li><p>允许重偏向：退回到可偏向但未偏向的状态</p></li><li><p>不允许重偏向：变为无锁状态</p></li></ol></li></ol></li></ol></li></ul></li></ul></li><li><p>轻量级锁：</p><ul><li>利用CAS来获取轻量级锁</li><li>如果当前线程获取轻量级锁失败，尝试自旋来获取锁，当自旋次数达到临界值(threshold)，轻量级锁会升级为重量级锁</li><li>解锁时，如果成功，替换对象头，如果失败，锁升级为重量级的锁</li></ul></li><li>重量级锁：利用操作系统的互斥量（mutex）来实现</li></ul><h4 id="synchronized是不公平的锁"><a href="#synchronized是不公平的锁" class="headerlink" title="synchronized是不公平的锁"></a>synchronized是不公平的锁</h4><ul><li>CAS乐观锁不公平</li><li>进入重量级锁的线程不会直接进入等待队列，而是会自旋获取锁</li></ul><h4 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h4><ul><li>volatile 线程同步的轻量级的实现，性能优于 synchronized</li><li>volatile 只能用于变量，synchronized可以修饰方法和代码块</li><li>voliatile 能保证数据的可见性，synchronized关键字两者都能保证</li><li>voliatile 解决变量在多个线程之间的可见性，synchronized解决的是多个线程之间访问资源的同步性</li></ul><h4 id="synchronized实现两个线程交替打印奇偶数"><a href="#synchronized实现两个线程交替打印奇偶数" class="headerlink" title="synchronized实现两个线程交替打印奇偶数"></a>synchronized实现两个线程交替打印奇偶数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OddEvenPrinter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OddEvenPrinter</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> initCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.count = initCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">printer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= limit) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;打印：&quot;</span> + ++count);</span><br><span class="line">                    monitor.notify();</span><br><span class="line">                    <span class="keyword">if</span>(count &lt;= limit)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OddEvenPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddEvenPrinter</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printer</span>(), <span class="string">&quot;thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printer</span>(), <span class="string">&quot;thread-2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.sleep(<span class="number">1</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>实现了Lock接口，是一个可重入且独占式的锁，比<code>synchronized</code>关键字更加灵活，更强大，主要增加的功能有，轮询、超时、中断、公平锁和非公平锁、选择性通知等高级功能</p><p>其底层是由AQS来实现的</p><h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><div class="table-container"><table><thead><tr><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>都是可重入锁</td><td>可重入锁指的是线程可以再次获取自己的内部锁</td></tr><tr><td>实现依赖于API（需要lock()，unlock()配合try/finally来实现的）</td><td>实现依赖于JVM（没有暴露给我们）</td></tr><tr><td>增加了高级功能</td></tr></tbody></table></div><ul><li>等待可中断：能够中断等待锁的机制</li><li>可实现公平锁：</li><li>可实现选择性通知：需要借助<code>Condition</code>接口和<code>newCondition</code>方法</li></ul><p>关于<code>Condition</code>接口的补充</p><blockquote><p>Condition 是 JDK1.5之后才有的，可以实现多路通知功能，在一个锁对象中可以创建对各Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而实现有选择性的进行线程通知，在调度线程上更加灵活，使用await()进行等待，使用singal()/singalAll()进行唤醒</p></blockquote><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。JDK 1.8 引入了性能更好的读写锁 <code>StampedLock</code></p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称<code>AbstractQueuedSynchronizer</code>，抽象队列同步器</p><p>AQS为构建锁和同步器提供了一些通用功能的实现，因此AQS能简单且高效地构造出应用广泛的大量的同步器，比如，<code>ReentrantLock</code>，<code>Semaphore</code>，<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code></p><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><ul><li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li><li>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是基于<strong>CLH锁</strong>实现</li></ul><h4 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h4><p>是对自旋锁的一种改进，一个虚拟的双向队列（即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。</p><p>AQS的核心原理图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/CLH.png" alt=""></p><p>AQS使用int成员变量<code>state</code>表示同步状态，通过内置的<strong>线程等待队列</strong>来完成获取资源线程的排队工作</p><p><a href="https://javaguide.cn/java/concurrent/reentrantlock.html">从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队</a></p><h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p>可以用来控制同时访问特定资源的线程数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为1时，信号量退化为排它锁</p><p>信号量有两种模式：</p><ul><li>公平模式：调用<code>acquire()</code>方法的顺序就是获取许可证的顺序，遵循FIFO</li><li>非公平模式：抢占式</li></ul><p>信号量适用于资源有明确访问数量限制的场景比如限流（仅限于单机模式，但是实际项目中推荐使用Redis+Lua来做限流）</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，认为共享资源每次访问的适合不会出现问题，等出现问题再回退</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值加一。当线程A要更新数据值时，在读取数据的同时会读取<code>version</code>值，在提交更新时，若读取的version的值与当前数据库中的<code>version</code>值相等时才更新，否则重试更新操作</p><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><p>全称为Compare And Swap（比较与交换），用于实现乐观锁。CAS是一个原子操作，底层依赖于一条CPU的原子指令</p><p>CAS涉及到三个操作数：</p><ul><li>V：要更新的变量值</li><li>E：预期值</li><li>N：拟写入的新值</li></ul><p>当且仅当V的值等于E时，CAS通过原子方式用新值N来更新V的值。如果不等，说明已经有其他线程更新V，则当前线程放弃更新</p><p>Java没有直接实现CAS，而是通过C++内联汇编的形式实现的（JNI调用）</p><h4 id="乐观锁的问题"><a href="#乐观锁的问题" class="headerlink" title="乐观锁的问题"></a>乐观锁的问题</h4><ul><li>ABA问题：<ul><li>如果V读取A但是被其他线程修改为B又修改回A，则不能保证当前值没有被更改过</li><li>解决办法：加上版本号或者时间戳</li></ul></li><li>循环时间长开销大：<ul><li>CAS经常需要自旋操作来进行重试，如果不成功就一致循环执行直到成功。如果长时间不成功，会给CPU带来非常大的执行开销</li></ul></li><li>只能保证一个共享变量的原子操作：<ul><li>引用<code>AtomicReference</code>类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作</li></ul></li></ul><h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><p>具有原子/原子操作特征的类</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>基本类型：</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code> ：布尔型原子类</li></ul></li><li><p>数组类型：</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code> ：引用类型数组原子类</li></ul></li><li><p>引用类型：</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code> ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul></li><li><p>对象属性修改类型：</p><ul><li><p><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</p><p><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</p><p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</p></li></ul></li></ul><h4 id="AtomicInteger-类常用方法"><a href="#AtomicInteger-类常用方法" class="headerlink" title="AtomicInteger 类常用方法"></a>AtomicInteger 类常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>  <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span>  <span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span>  <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect,<span class="type">int</span> update)</span>  <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span>  <span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/mingyry/91e798bc.html"/>
      <url>/mingyry/91e798bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>抽象了线程和主内存之间的关系</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/jmm.png" alt="JMM(Java 内存模型)" style="zoom:80%;" /></p><ul><li>主内存：所有线程创建的实例对象都存放在主内存中，不管该实例的本地方法还是方法中的本地变量（也称局部变量）</li><li>本地内存：每个线程都有一个私有内存来存放共享变量的副本，并且每个线程都只能访问自己的本地内存，无法访问其他线程的本地内存</li></ul><h3 id="并发编程的三个特性"><a href="#并发编程的三个特性" class="headerlink" title="并发编程的三个特性"></a>并发编程的三个特性</h3><ul><li>原子性：一次或者多次操作，要么全部执行，要么都不执行，利用Synchronized以及各种Lock实现原子性</li><li>可见性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值</li><li>有序性：由于指令重排序问题，在多线程中，指令可能不会保证语义一致，<code>volatile</code>关键词可以禁止指令进行重排序优化</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机</title>
      <link href="/mingyry/18701caa.html"/>
      <url>/mingyry/18701caa.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-虚拟机"><a href="#JVM-虚拟机" class="headerlink" title="JVM 虚拟机"></a>JVM 虚拟机</h1><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="JVM监控的工具（JVM的相关指令）"><a href="#JVM监控的工具（JVM的相关指令）" class="headerlink" title="JVM监控的工具（JVM的相关指令）"></a>JVM监控的工具（JVM的相关指令）</h3><div class="table-container"><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps【选项 】 [主机ip或域名]</td><td>输出JVM中运行的进程状态信息</td></tr><tr><td>jstack 【选项】 【进程ID】</td><td>查看某个Java进程内的线程堆栈信息</td></tr><tr><td>jmap【选项】【进程ID】</td><td>查看堆内存的使用状况并且生成堆转储快照</td></tr><tr><td>jhat</td><td>用于分析heapdump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td>jstat 【选项】 【进程ID】 [间隔时间 ] [查询次数]</td><td>用于查看各个功能和区域的统计信息（如：类加载、编译相关信息统计，各个内存区域GC概况和统计）主要内存信息统计</td></tr><tr><td>jinfo 【选项】【进程ID】</td><td>查看和调整JVM启动和运行参数。</td></tr><tr><td>jconsole</td><td>javaGUI监控工具，可以以图形化的形式显示各种数据，并可以通过远程连接监控远程的服务器的jvm进程</td></tr><tr><td>Linux下的top</td><td>查看当前所有进程的使用情况，CPU占有率，内存使用情况，服务器负载状态等参数</td></tr><tr><td>Visual VM:多合一故障处理工具</td><td>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></td></tr></tbody></table></div><ul><li><strong><code>jps</code></strong>：类似于ps命令，-l（输出主类的全名，如果是jar包，输出Jar路径），-v（输出虚拟机进程启动时JVM参数），-m（输出传递给Java进程main()函数的参数）</li><li><p><strong>jstat -gc PID</strong>：查看即时内存使用情况、垃圾回收统计信息，用于分析GC情况</p></li><li><p><strong>heapdump</strong>：</p><ul><li><p>概念：<br>heapdump，又被称为堆转存文件，是一个java进程在某个时间点上的内存快照。</p></li><li><p>解释：<br>具有很多种类型；<br>总体上heapdump在触发快照的时候都保存了java对象和类的信息。<br>通常在写heapdump文件前会触发一次FullGC，则该文件保存的都是FullGC后留下来的对象信息。</p><p>| 信息                      | 说明                                           |<br>| ————————————- | ——————————————————————— |<br>| 对象信息                  | 类、成员变量、直接量以及引用值                 |<br>| 类信息                    | 类加载器、名称、超类、静态成员                 |<br>| Garbage Collections Roots | JVM可达的对象                                  |<br>| 线程栈以及本地变量        | 获取快照时的线程栈信息，以及局部变量的详细信息 |</p></li></ul></li><li><p><strong><code>jhat</code></strong>: 访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p></li></ul><h3 id="利用监控工具调优"><a href="#利用监控工具调优" class="headerlink" title="利用监控工具调优"></a>利用监控工具调优</h3><p>监控工具作用：</p><ul><li><p>堆信息查看<br>查看堆空间大小分配（年轻代、老年代、持久态分配）；<br>提供即时的垃圾回收功能；<br>垃圾监控；<br>查看堆内类、对象信息查看（类型、数量等）；<br>对象引用情况查看；<br><strong>可解决：年轻代、老年代大小划分是否合理、内存泄露、垃圾回收算法设置是否合理。</strong></p></li><li><p>线程监控<br>线程信息监控：系统线程数量；<br>线程状态监控：各线程都处于什么状态下；<br>Dump线程详细情况：线程内部运行情况；<br>死锁检查；</p></li><li>热点分析<br>CPU热点：检查系统哪方面占用CPU时间较长；<br>内存热点：检查哪些对象在系统中数量最大；<br>明确热点问题，有针对性的进行系统的瓶颈查找和系统优化。</li><li>快照<br>快照是系统运行到某一时刻的一个定格。<br>依赖快照可以根据系统运行时刻、对象（或类、线程）的不同，快速找到问题。</li><li>内存泄漏<br>内存泄漏一般可以理解为系统资源（堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收，从而导致新的资源分配请求无法完成，引起系统错误。</li></ul><h3 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h3><h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><ol><li><p>显式指定对内存<code>–Xms</code>和<code>-Xmx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure></li></ol><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><ol><li><p>显式新生代内存大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br><span class="line">或者</span><br><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure></li></ol><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况</p></blockquote><ol><li><p>显式指定各比值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</span><br><span class="line">例如：4，表示新生代：老年代=1：4</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio（幸存代）--- 设置两个 Survivor 区和 eden 的比值</span><br><span class="line">例如：8，表示两个Survivor:Eden=2：8</span><br></pre></td></tr></table></figure></li><li><p>显式指定永久代/元空间的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）</p></li><li><p>Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p></li></ul><h4 id="垃圾回收器相关"><a href="#垃圾回收器相关" class="headerlink" title="垃圾回收器相关"></a>垃圾回收器相关</h4><h5 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h5><div class="table-container"><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>-XX：UseSerialGC</td><td>设置串行收集器</td></tr><tr><td>-XX：UseParallelGC</td><td>设置<strong>并行</strong>收集器</td></tr><tr><td>-XX：UseParallelOldGC</td><td>设置并行老年代收集器</td></tr><tr><td>-XX：UseConcMarkSweepGC</td><td>设置<strong>CMS并发</strong>收集器</td></tr></tbody></table></div><h5 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：PrintGC</td><td>开启打印gc信息</td></tr><tr><td>-XX：PrintGCDetails</td><td>打印gc详细信息</td></tr><tr><td>-XX：PrintGCTimeStamps</td><td>打印gc所经历时间的详细信息</td></tr><tr><td>-Xloggc：filename</td><td>将gc日志输出到文件</td></tr></tbody></table></div><h5 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：ParallelGCThreads = n</td><td>设置并行收集器收集时使用的CPU数</td></tr><tr><td>-XX：MaxGCPauseMillis = n</td><td>设置并行收集最大暂停时间</td></tr><tr><td>-XX：GCTimeRatio = n</td><td>设置垃圾回收时间占程序运行时间的百分比</td></tr></tbody></table></div><h5 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h5><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX：CMSIncrementalMode</td><td>设置为增量模式。适用于单CPU情况</td></tr><tr><td>-XX：ParallelGCThreads = n</td><td>设置并发收集器年轻代收集方式为并发收集时，使用的CPU数。并发收集线程数</td></tr></tbody></table></div><h5 id="IDEA中的JVM的配置："><a href="#IDEA中的JVM的配置：" class="headerlink" title="IDEA中的JVM的配置："></a>IDEA中的JVM的配置：</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8d350bc15c0e47059d858f27621d11ea.png" alt="在这里插入图片描述"></p><h3 id="编译器与运行期的优化"><a href="#编译器与运行期的优化" class="headerlink" title="编译器与运行期的优化"></a>编译器与运行期的优化</h3><h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4><ul><li>java语言的编译期就是一段不确定的操作过程：<br>它可能指前端编译器把java文件转变成class字节码文件的过程，也可以指虚拟机后端运行期间编译器（JIT，Just In Time Compiler）把字节码变成机器码的过程。</li><li>它可以分为三类编译过程：<br>前端编译：把.java文件转变为.class文件<br>后端编译：把字节码（.class文件）转变为机器码<br>静态提前编译：直接把.java文件编译成本地机器代码</li></ul><h5 id="编译器的编译过程——前端编译（java→class）"><a href="#编译器的编译过程——前端编译（java→class）" class="headerlink" title="编译器的编译过程——前端编译（java→class）"></a>编译器的编译过程——前端编译（java→class）</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/9d9bc90f84514762a2a8da30b11bb2a9.png" alt="在这里插入图片描述"></p><p><strong>字节码生成</strong><br>javac编译的最后一个阶段，字节码生成阶段将之前各个步骤所生成的信息转化成字节码写到磁盘中，另外进行少量的代码添加和转换工作。</p><h4 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h4><p>java最初是通过解释器（interpreter）进行解释执行的。当虚拟机发现某方法或代码块的运行很频繁时，会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，运行时，虚拟机会将这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）</p><p><strong>解释器与即时编译器</strong> 区别</p><div class="table-container"><table><thead><tr><th>区别</th><th>解释器</th><th>即时编译器</th></tr></thead><tbody><tr><td>作用</td><td>将字节码解释为机器码，下次遇到相同的字节码，还会进行重复解释</td><td>字节码解释为机器码，存入Code Cache，下次遇到相同的字节码，不再编译直接解释</td></tr><tr><td>特点</td><td>将字节码解释为所有平台通用的机器码</td><td>根据平台类型，生成平台特定的机器码</td></tr></tbody></table></div><h5 id="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"><a href="#为何HotSpot虚拟机要使用解释器与编译器并存的框架？" class="headerlink" title="为何HotSpot虚拟机要使用解释器与编译器并存的框架？"></a>为何HotSpot虚拟机要使用解释器与编译器并存的框架？</h5><p>HotSpot采用解释器与编译器并存的框架，是因为两者皆有优势。</p><ul><li>解释器：<br>逐条转换，保留源代码；<br>程序员可以快速启动和执行，消耗内存小；（成本低，后期效率低）</li><li>编译器：<br>一次性转换，不保留源代码；<br>随着代码频繁执行会将代码编译成本地机器码；（成本高、后期效率高）</li><li>解释器与编译器配合使用：<br>当程序需要迅速启动和执行的时候，解释器可以率先发挥作用，省去编译时间，立即执行；<br>程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以提高执行效率；<br>当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之可以使用编译执行提升效率。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a><br><a href="https://blog.csdn.net/LXMXHJ/article/details/124876571">https://blog.csdn.net/LXMXHJ/article/details/124876571</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/mingyry/6d27f500.html"/>
      <url>/mingyry/6d27f500.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-类加载"><a href="#Java-类加载" class="headerlink" title="Java 类加载"></a>Java 类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>整个生命周期可以概括为7个阶段：加载、验证、准备、解析、初始化、使用和卸载。</p><p>顺序如下图所示：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:50%;" /></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载Class类型的文件主要分为三步：加载-&gt;连接-&gt;初始化，连接过程又分为三步：验证-&gt;准备-&gt;解析。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口（通过<a href="# 类加载器">类加载器和双亲委派模型</a>）</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保Class文件的字节流中的信息符合《Java虚拟机规范》的全部约束要求</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class文件格式检查）：常量池中的常量是否有不被支持的类型</li><li>元数据验证（字节码语义检查）：该类是否有父类，该类是否继承了不允许继承的类</li><li>字节码验证（程序语义检查）：函数的参数类型是否正确，对象的类型转换是否合理</li><li>符号引用验证（类的正确性检查）：类使用的字段是否存在，是否有合适的访问权限</li></ol><p>该阶段抛出的异常有：</p><ul><li><code>java.lang.IllegalAccessError</code>：访问或修改无权限的字段或者调用无权限访问的方法</li><li><code>java.lang.NoSuchFieldError</code>：访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><p><code>java.lang.NoSuchMethodError</code>：访问一个指定的方法，而该方法不存在时，抛出该异常。</p></li><li><p>……</p></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>是正式为类变量分配内存并设置类变量初始值的阶段</p><ol><li>进行内存分配的只有类变量（被<code>static</code>修饰的变量）</li><li>静态变量放在堆中而不是在永久代中</li><li>初始值一般是该数据类型下默认的零值，如果加上<code>final</code>修饰的话，在准备阶段就会被赋值成想要的值</li></ol><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>是虚拟机将常量池内的符号引用替换为直接引用的过程，就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行初始化方法<code>&lt;clinit&gt;()</code>的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码</p><p>类的初始化方法是多线程安全的，只有以下六种情况会触发类的初始化：</p><ol><li>当遇到<code>new</code>，<code>getstatic</code>，<code>putstatic</code>或者<code>invokestatic</code>这4条字节码指令时。</li><li>使用<code>java.lang.reflect</code>包中的方法对垒进行反射调用时，如<code>`Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code>等</li><li>初始化一个类， 要先初始化其父类</li><li>虚拟机启动时，需要先初始化一个要执行的主类，具有main方法的那个类</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类</li><li>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在JVM的生命周期中，被jvm自带的类加载器加载的类是不会被卸载的，只有我们自己定义的类加载器加载的类是可能被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载步骤</li><li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code></li><li>数组类不是通过类加载器创建的，是由JVM直接生成的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">classClass&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    privatefinalClassLoader classLoader;</span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载器的主要作用就是加载Java类的字节码（.class文件）到JVM中（在内存中生成一个代表该类的Class对象）Class对象一般在元空间中</p><h4 id="类加载器的加载规则"><a href="#类加载器的加载规则" class="headerlink" title="类加载器的加载规则"></a>类加载器的加载规则</h4><p>JVM不会一次性加载所有的类，而是根据需要去动态加载。在具体用到的时候才会去加载</p><h4 id="类加载器的类型"><a href="#类加载器的类型" class="headerlink" title="类加载器的类型"></a>类加载器的类型</h4><ol><li><code>BootstraoClassLoader</code>（启动类加载器）：最顶层的加载器，由C++实现，没有父级，主要用来加载JDK内部和核心类库</li><li><code>ExensionClassLoader</code>（扩展类加载器）：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量所指定的路径下的所有类</li><li><code>AppClassLoader</code>（应用程序类加载器）：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li></ol><blockquote><p>:rainbow: 拓展一下：</p><ul><li><strong><code>rt.jar</code></strong> ： rt 代表“RunTime”，<code>rt.jar</code>是Java基础类库，包含Java doc里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.*</code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载</li></ul></blockquote><ol><li>用户自定义的类加载器：</li></ol><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><ul><li>加载器类使用委托模型来搜索类和资源</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器</li><li>加载器实例用在试图亲自查找类或者资源前，将搜索类或者资源的任务委派给其父类的加载器</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom: 80%;" /></p><p>面向对象编程中，有一条经典的设计原则：组合优于继承，多用组合少用继承</p><h5 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行连接/链接操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ul><li>在类加载时，先判断当前类是否被加载过，已经被加载的类会直接返回，否则尝试加载</li><li>类加载器在进行类加载的时候，先不尝试加载该类，而是把请求委派给父类加载器来完成（调用父类的<code>loadClass()</code>方法），最终所有的请求都会会回到顶层的启动类加载器中</li><li>只有当父加载器无法加载该类时（它的搜索范围中没有找到所需的类），子加载器使用<code>findClass()</code>方法来加载类</li></ul><h5 id="如何判断两个java类是否相同"><a href="#如何判断两个java类是否相同" class="headerlink" title="如何判断两个java类是否相同"></a>如何判断两个java类是否相同</h5><ul><li>要看类的全类名是否相同</li><li>要看加载此类的类加载器是否一样</li></ul><h5 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h5><p>保证了Java程序的稳定运行，可以避免类的重复加载，也保证了Java的核心API不会被篡改。不会出现我自定义的类加载器来加载<code>java.lang.Object</code>类</p><h5 id="打破双亲委派模型"><a href="#打破双亲委派模型" class="headerlink" title="打破双亲委派模型"></a>打破双亲委派模型</h5><p>自定义加载器需要继承<code>ClassLoader</code>。如果不想打破双亲委派模型，就重写<code>ClassLoader</code>中的<code>findClass()</code>方法，如果想要打破双亲委派模型，需要重写<code>loadClass()</code>方法</p><p>打破双亲委派模型的场景：Tomcat场景,(保证在一个tomcat上运行的多个web应用程序之间存在相同类（全限定类名一样）但具体操作不一样的类 不冲突；)，  JNDI服务（java Naming and Directory Interface，java命名和目录接口），Spring（Spring对用户程序进行组织和管理，应用程序一般存放在WEB-INF目录下，由WebAppClassLoader类加载器加载；<br>而Spring由Common类加载器或Shared类加载器加载；Spring如何加载WEB-INF下的应用程序呢？使用线程上下文类加载器。）</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收</title>
      <link href="/mingyry/55ad0fd.html"/>
      <url>/mingyry/55ad0fd.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-垃圾回收"><a href="#Java-垃圾回收" class="headerlink" title="Java 垃圾回收"></a>Java 垃圾回收</h2><h3 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h3><p>JDK7及以前，堆内存分为三部分：</p><ul><li>新生代内存：Eden区和两个Survivor区S0和S1</li><li>老生代</li><li>永久代</li></ul><p>JDK8之后永久代被元空间所取代，元空间使用直接内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/hotspot-heap-structure.41533631.png" alt="hotspot-heap-structure"></p><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><ul><li>对象优先在Eden区分配</li><li>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，如果对象放不进去S0或者S1，那么就利用<strong>分配担保机制</strong>将新生代对象提前转移到老年代中</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代：<ul><li>虚拟机给每一个对象一个对象年龄（Age）计数器</li><li>现在Eden区中进行分配</li><li>经过一次Minor  GC 进入到Survivor，岁数赋值为1</li><li>每熬过一次Minor GC，Age+1</li><li>当年龄达到阈值，则放入老年代（当累积的某个年龄超过了Survivor区的50%时，取这个值和最大阈值中的小值作为阈值）</li></ul></li><li>内存一般分配情况：<ul><li>新生代（1/3）：Eden：S0：S1=8：1：1</li><li>老年代（2/3）</li></ul></li></ul><h4 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h4><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集（Partial GC）：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代垃圾进行收集（eden区满时）</li><li>老年代收集（MajorGC / Old GC）：只对老年代进行垃圾收集（）</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li></ul><p>整堆收集（Full GC）：收集是整个Java堆和方法区（新生代晋升大小超过老年代的空间大小会在永久代分配空间不足，或者系统调用垃圾回收算法）</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>为了确保在Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间：只要老年代的来纳许空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC</p><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加1</li><li>当引用失效，计数器就减1</li><li>任何时候计数器为0的对象就是不可能再被使用的</li></ul><p>弊端：难以解决对象之间互相循环引用的问题</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Gc Roots 的对象为起点，向下搜索，当一个对象到 GC Roots没有任何的引用链相连的话，则证明此对象时不可用的需要被回收</p><p>作为GC Roots的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h5 id="对象可以回收就一定会回收么？"><a href="#对象可以回收就一定会回收么？" class="headerlink" title="对象可以回收就一定会回收么？"></a>对象可以回收就一定会回收么？</h5><p>回收之前需要经历两次标记，第一次时可达性分析法中不可达的对象进行标记，被判定的对象放在一个队列里进行二次标记，如果这时候还没有与其他对象建立关联，那么就被回收</p><h4 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h4><ul><li>强引用：最普遍的引用，垃圾回收器不会回收它。当内存空间不足时，只会抛出<code>OutOfMemoryError</code>错误</li><li>软引用：内存空间足够时不会回收，当内存空间不足时，会回收这些对象的内存</li><li>弱引用：一旦发现弱引用对象，不管当前内存空间足够与否，都会回收它的内存。但是垃圾收集器的线程优先级是较低的，不一定会执行的很早</li><li>虚引用：虚引用必须和引用队列使用</li></ul><h4 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h4><p>字符串常量：没有任何一个String对象引用该字符串常量时</p><h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><ul><li>该类的所有实例对象都被回收，堆中不存在该类的实例对象</li><li>加载该类的类加载器也被回收</li><li>该类对应的类对象没有再其他地方被引用，也没有再审核地方通过反射访问该类的方法</li></ul><p>这时候可以回收，不一定会回收</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>先标记出不需要回收的对象，再标记完成后统一回收掉没有被标记的对象。最基础的收集算法</p><p>问题：</p><p>​    1. 效率不足</p><pre><code>2. 空间问题（会出现大量不连续的碎片）</code></pre><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230418145507754.png" alt="image-20230418145507754"></p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中的一块。当把这一块内存使用完后，将还存活的对象复制到另一块去</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/90984624.e8c186ae.png" alt="复制算法"></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代特点提出的一种标记算法，标记过程和标记-清除算法一样，但是后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/94057049.22c58294.png" alt="标记-整理算法 "></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，就是根据堆中的各个年代类选择合适的垃圾收集算法</p><h5 id="HotSpot为什么要分为新生代和老年代"><a href="#HotSpot为什么要分为新生代和老年代" class="headerlink" title="HotSpot为什么要分为新生代和老年代"></a>HotSpot为什么要分为新生代和老年代</h5><p>因为有大量对象会被直接收集，放在新生代中使用合适的垃圾收集算法可以付出少量的成本，对于存活几率比较高的对象放到老年代中，使用合适的垃圾收集算法进行处理</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现，更具具体的应用场景选择适合自己的垃圾收集器</p><h4 id="Serial（串行）-收集器"><a href="#Serial（串行）-收集器" class="headerlink" title="Serial（串行） 收集器"></a>Serial（串行） 收集器</h4><p>最基本的垃圾收集器，单线程，重点是在垃圾收集工作时需要暂停其他所有的工作线程</p><p>新生代：标记-复制，老年代：标记-整理</p><p>简单高效</p><h4 id="ParNew-收集器（Serial的多线程版本）"><a href="#ParNew-收集器（Serial的多线程版本）" class="headerlink" title="ParNew 收集器（Serial的多线程版本）"></a>ParNew 收集器（Serial的多线程版本）</h4><p>新生代：标记-复制，老年代：标记-整理</p><p>许多Server模式下的虚拟机的首要选择</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>关注点在吞吐量（高效率的利用CPU）。吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值</p><p>新生代：标记-复制，老年代：标记-整理</p><p>JDK1.8的默认收集器，默认使用Parallel Scavenge + Parallel Old</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial 收集器的老年代版本，是一个单线程的收集器，和Parallel Scavenge收集器搭配使用</p><h4 id="Parallel-Olde-收集器"><a href="#Parallel-Olde-收集器" class="headerlink" title="Parallel Olde 收集器"></a>Parallel Olde 收集器</h4><p>Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。注重用户体验的应用上使用。</p><p>第一款真正意义上的并发收集器，让垃圾收集线程和用户线程同时工作</p><p>四个步骤：</p><ul><li>初始标记：暂停所有线程，并记录下与root直接相连的对象，执行速度较快</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。此外会跟踪记录发生引用更新的地方</li><li>重新标记：为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，停顿时间一般比初始标记时间长，比并发标记时间短</li><li>并发清除：开启用户线程，同时GC线程开始堆未标记的区域做清扫</li></ul><p>优点：并发回收，低停顿</p><p>缺点：对CPU资源敏感，无法处理浮动垃圾（标记之后，连接该对象的可达性链路断开，该对象称为浮动垃圾），使用的回收算法是标记-清除，会产生大量空间碎片</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征</p><ul><li>并行和并发：能够充分利用CPU和多核环境的硬件优势</li><li>分代收集：保留了分代的概念</li><li>空间整合：整体来看基于标记-整理算法，局部基于标记-复制</li><li>可预测的停顿：一大优势，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ul><p>收集步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/mingyry/a7eb5674.html"/>
      <url>/mingyry/a7eb5674.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p><strong>JDK1.8之后的运行区域:</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p><p>其中线程包含：</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享的：</p><ul><li>堆</li><li>方法区（1.8之后移除了）换成了元空间</li><li>直接内存</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是当前线程所执行的字节码的行号指示器，为了线程切换后能够恢复到正确的执行位置，因此每个线程都需要有一个独立的程序计数器</p><p>两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>多线程下，可以记录当前线程的执行位置，当线程发生切换后，能够返回到上次的运行位置</li></ul><p>注意：程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈也称为栈帧，生命周期和线程相同，每一个方法调用都会有一个对应的栈帧被压入，每一个方法调用结束后都有一个栈帧被弹出</p><p>虚拟机栈的组成如下图</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/stack-area.png" alt="Java 虚拟机栈"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>存放编译器可知的各种数据类型（boolean、int、char等）和对象引用（reference类型，它不同于对象本身（对象实际的所在内存空间在堆中），可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与次对象相关的位置）</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>用于存放方法执行过程中产生的中间计算结果。另外，临时变量也会放在操作数栈中</p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>将符号引用转换为调用方法的直接引用，当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。</p><h5 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h5><p>栈帧随着方法的调用而创建，随着方法结束而销毁。无论方法正常返回还是异常完成都算在方法的结束，因此方法必须有返回值</p><h5 id="栈中出现的错误"><a href="#栈中出现的错误" class="headerlink" title="栈中出现的错误"></a>栈中出现的错误</h5><ul><li><code>StackOverFlowError</code>：若栈的内存大小不允许动态扩展，函数调用陷入无限循环，导致栈中被压入太多的栈帧而占用太多的空间。当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，会抛出异常</li><li><code>OutOfMemoryError</code>：若栈的内存大小可以动态扩展，当虚拟机在动态扩展栈时候无法申请到足够的内存空间，则抛出异常</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>为虚拟机所使用到的<strong>Native</strong>（非Java的方法，一般是c或者c++的方法）方法服务</p><p>栈内结构和虚拟机栈类似</p><p>也会出现<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>两个错误</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>此内存区域唯一目的是存放对象实例，几乎所有的对象实例以及数组都是在这里分配内存（例外：开启逃逸分析：某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存）</p><p>堆是垃圾收集器管理的主要区域，也被称为GC堆，垃圾收集的具体内容放到<a href="#Java 垃圾回收">Java垃圾回收</a></p><h5 id="堆中出现的错误"><a href="#堆中出现的错误" class="headerlink" title="堆中出现的错误"></a>堆中出现的错误</h5><p>最容易出现的是<code>OutOfMemoryError</code>错误，有几种表现形式：</p><ul><li><code>GC Overhead Limit Exceeded</code>：当JVM花费太多时间执行垃圾回收并且只能回收到很少的堆空间时，就会发生此错误</li><li><code>Java heap space</code>：创建对象时，堆内存中的空间不足以存放新创建的对象，会引发此错误</li></ul><h5 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p>JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的区域，目的为了避免字符串的重复创建</p><p>JDK1.7之前存放在永久代中，JDK1.7后字符串常量池和静态变量存放在Java堆中</p><p>转移的原因是因为永久代（方法区实现）的GC回收效率太低，放在堆中可以更高效的回收字符串内存</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>是JVM运行时数据区域的一块逻辑区域，是个个线程共享的内存区域</p><p>方法区存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></p><h5 id="方法区和永久代以及元空间的关系"><a href="#方法区和永久代以及元空间的关系" class="headerlink" title="方法区和永久代以及元空间的关系"></a>方法区和永久代以及元空间的关系</h5><p>类似于接口和类的关系</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p>为什么要将永久代替换为元空间：</p><ul><li>永久代有JVM设置的固定大小的上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，溢出的几率更小</li><li>元空间存放类的元数据，空间越大可加载的类越多</li><li>JDK8中虚拟机合并不需要额外设置永久代</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class文件中存放编译器生成的各种字面量和符合引用的常量池表</p><p>字面量就是源代码中的固定值的表示法包括整数、浮点数和字符串字面量。常见的符合引用（就是以一组符合来描述所引用的对象，并不一定是已经加载到虚拟机中的内容）包括类符合引用、字段符号引用、方法符合引用、接口方法符合引用</p><p>当常量池无法再申请到内存是会抛出<code>OutOfMemoryError</code>错误</p><blockquote><p>常量池中存放着引用，实际对象还是存放在Java 堆中</p><p>Animal an = new Animal()；</p><p>an：引用   Animal：对象</p><p>Java中都是通过引用来操作对象的</p></blockquote><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时的数据区的一部分，而是通过JNI的方式在本地内存上分配的，也会出现<code>OutOfMemoryError</code>错误</p><h3 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h3><h4 id="第一步：类加载检查"><a href="#第一步：类加载检查" class="headerlink" title="第一步：类加载检查"></a>第一步：类加载检查</h4><p>虚拟机遇到一条new指令时，先检查这个指令的参数能否在运行时常量池中定位到这个类的符号引用，检查这个符号引用所代表的类是否被加载过、解析和初始化过。</p><p>如果没有，则执行类加载的过程</p><h4 id="第二步：分配内存"><a href="#第二步：分配内存" class="headerlink" title="第二步：分配内存"></a>第二步：分配内存</h4><p>在类加载检查通过后，把堆中的一块确定大小的内存划分出来，分配给新生对象</p><p>分配方式：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整的情况下</li><li>原理：根据分界指针，分配内存</li><li>GC收集器：Serial，ParNew</li></ul></li><li><p>空闲列表：</p><ul><li>使用场合：堆内存不规整的情况下</li><li>原理：虚拟机维护一个列表，表中记录哪些内存块可用</li><li>GC收集器：CMS</li></ul></li><li><p>以上方式的使用取决于内存是否规整，就是GC收集器的算法使用的是<code>标记-清除</code>还是<code>标记-整理</code>，<code>标记-复制</code>内存也是规整的</p></li></ul><p>内存分配的并发解决：</p><ul><li>CAS+失败重试：乐观锁，保证分配方式的原子性</li><li>TLAB：预先为Eden区分配内存，首先在TLAB分配，分配需要空间大于TLAB则采取上述CAS进行内存分配</li></ul><h4 id="第三步：初始化零值"><a href="#第三步：初始化零值" class="headerlink" title="第三步：初始化零值"></a>第三步：初始化零值</h4><p>内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值（不包括对象头），保证对象的实例字段在Java代码中可以不赋初始值就可以直接使用</p><h4 id="第四步：设置对象头"><a href="#第四步：设置对象头" class="headerlink" title="第四步：设置对象头"></a>第四步：设置对象头</h4><p>虚拟机需要对对象进行必要的设置，将对象信息存放在对象头中，例如信息有类的元数据信息、对象的哈希码、对象的GC分代年龄等信息</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6nlu6vcab7.png" alt="img"></p><h4 id="第五步：执行init方法"><a href="#第五步：执行init方法" class="headerlink" title="第五步：执行init方法"></a>第五步：执行init方法</h4><p>安装程序员的意愿进行初始化</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/f9c822367eaf5200222a8bf604629fa7.png" alt="img"></p><ol><li>对象头：存储自身运行时的数据<pre><code>类型指针（确定该对象是哪个类的实例）</code></pre></li><li>实例数据：真正存储的有效信息</li><li>对齐填充：对象大小必须是8字节的整数倍</li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。访问方式有两种：</p><ul><li><p>使用句柄：reference中存储的是对象的句柄地址，句柄中包含对象实例数据与对象类型数据的具体地址信息，优点是稳定，对象被移动只需要改变句柄中的实例数据指针就可以</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p></li><li><p>直接引用：reference中存储的直接就是对象的地址，优点是访问速度快</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://javaguide.cn/he">https://javaguide.cn/he</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-HTTP</title>
      <link href="/mingyry/c6823846.html"/>
      <url>/mingyry/c6823846.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-HTTP"><a href="#计算机网络-HTTP" class="headerlink" title="计算机网络-HTTP"></a>计算机网络-HTTP</h2><h3 id="HTTP：超文本传输协议"><a href="#HTTP：超文本传输协议" class="headerlink" title="HTTP：超文本传输协议"></a>HTTP：超文本传输协议</h3><h4 id="HTTP常见的状态码"><a href="#HTTP常见的状态码" class="headerlink" title="HTTP常见的状态码"></a>HTTP常见的状态码</h4><p><code>1XX</code>属于提示信息，是协议处理中的一种中间状态</p><p><code>2XX</code>表示服务器成功处理了客户端的请求</p><ul><li><p><code>200 OK</code> 最常见的成功状态码，表示一切正常</p></li><li><p><code>204 No Content</code> 成功状态码，但是响应头中没有body数据</p></li><li><code>206 Partial Content</code> 应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分</li></ul><p><code>3XX</code>表示重定向，需要客户端重现发送请求获取资源</p><ul><li><p><code>301 Moved Permanently</code> 表示永久重定向，说明请求的资源已经不存在了</p></li><li><p><code>302 Found</code> 表示临时充电线，说明请求的资源还在，但暂时需要另一个URL来访问</p><p>301和302浏览器会自动重新定向到新的URL</p></li><li><p><code>304 Not Modified</code> 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件</p></li></ul><p><code>4XX</code> 表示客户端发送的报文有误，服务器无法处理</p><ul><li><p><code>400 Bad Request</code> 表示客户端请求的报文有错误</p></li><li><p><code>403 Forbidden</code> 表示服务器禁止访问资源</p></li><li><code>404 Not Found</code> 表示请求的资源在服务器上不存在或者未找到</li></ul><p><code>5XX</code>表示客户端请求报文正确，但是服务器处理时内部发生错误，属于服务器端的错误码</p><ul><li><code>500 Internal Server Error</code> 通用错误码，服务器端发生错误</li><li><code>501 Not Implemented</code> 表示客户端请求的功能还不支持</li><li><code>502 Bad Gateway</code> 服务器作为网关或代理时返回的错误码、表示服务器自身工作正常，访问后端服务器发生了错误</li><li><code>503 Service Unavailable</code> 表示服务器当前很忙，暂时无法响应客户端</li></ul><h4 id="Get方法和Post方法"><a href="#Get方法和Post方法" class="headerlink" title="Get方法和Post方法"></a>Get方法和Post方法</h4><ul><li>Get方法是从服务器获取指定的资源</li><li>Post方法是根据Body对指定的资源做出处理</li></ul><p>安全性：请求方法不会破坏服务器上的资源</p><p>幂等性：多次执行相同的操作，结果都是相同的</p><ul><li>Get方法是安全且幂等的，可以对Get请求的数据做缓存，可以将缓存发给到浏览器身上，也可以做到代理上（nginx）</li><li>Post方法不安全且不幂等，不能把Post请求作为缓存</li></ul><p>注意：以上前提是根据RFC（互联网中的标准，所定义的）规范定义的语义来分析的，你也可以选择在get方法中携带body。</p><h4 id="HTTP的缓存技术"><a href="#HTTP的缓存技术" class="headerlink" title="HTTP的缓存技术"></a>HTTP的缓存技术</h4><h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</p><ul><li><code>Cache-Control</code>， 是一个相对时间</li><li><p><code>Expires</code>，是一个绝对时间</p></li><li><p>都表示资源在客户端缓存的有效期</p></li></ul><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>当请求的响应码是<code>304</code>时，就告诉浏览器可以使用本地缓存的资源，这种需要通过服务器来告知客户端是否可以使用缓存的方式叫做协商缓存</p><p>请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：</p><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p></li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>简单：基本的报文格式就是<code>header+body</code>，头部信息也是<code>key-value</code>的简单文本的形式</li><li>灵活和易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</li><li>应用广泛和跨平台：可以跨平台使用</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>无状态双刃剑：</p><p>每次请求都需要验证用户的信息（解决办法，cookie或者jwt，或者Session）</p></li><li><p>明文传输的弊端：</p><p>HTTP所有的信息都可以被窃取</p></li><li><p>不安全</p><ul><li>通信使用了明文</li><li>不验证通信双方的身份</li><li>无法证明报文的完整性</li></ul></li></ul><h4 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h4><p>HTTP协议是基于TCP/IP，并且使用了请求-应答的通信模式</p><ul><li><p>长连接：    </p><p>只要任意一端没有明确提出断开连接，则保持TCP连接状态</p><p>减少了TCP连接重复建立和断开所造成的开销，减轻了服务器端的负载</p></li><li><p>管道（pipeline）网络传输：</p><ul><li>在同一个TCP连接里，客户端可以发起多个请求，不需要等待回应，即可再发送请求，<strong>减少了整体的响应时间</strong></li><li>问题：解决了请求的队头阻塞，但是没有解决响应的队头阻塞问题，并且没有使用</li></ul></li><li><p>队头阻塞：</p><p>当顺序发送的请求队列有一个请求没有没处理时，其他后面的请求都无法处理，一直阻塞</p></li></ul><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><ul><li><p>避免发送HTTP请求：</p><p>通过缓存技术，将响应的数据缓存在本地，获取本地数据的速度肯定要大于网路传输的速度</p></li><li><p>减少HTTP请求次数：</p><ul><li><p>减少重定向请求次数：</p><p>将重定向工作交给代理服务器来完成，不用经过客户端</p></li><li><p>合并请求：</p><ul><li>减少了重复发送的HTTP头部</li><li>解决方法：合并资源，到客户端后再将资源分解</li></ul></li><li><p>延迟发送请求：</p><p>按需获取，不需要所有资源都加载</p></li></ul></li><li><p>减少HTTP响应的数据大小</p><p>对相应的资源进行压缩</p><ul><li><p>无损压缩：</p><p>信息不会被破环，可以完全恢复成压缩前的模样</p></li><li><p>有损压缩：</p><p>牺牲一些质量来减少数据量、提高压缩比。用于压缩多媒体数据，音频、视频、图片等</p></li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了SSL/TLS安全协议使得报文能够加密传输</p><p>TCP三次握手之后，再进行SSL/TLS的握手过程，才可以进行加密报文传输</p><h4 id="HTTP-的风险和-HTTPS-的解决"><a href="#HTTP-的风险和-HTTPS-的解决" class="headerlink" title="HTTP 的风险和 HTTPS 的解决"></a>HTTP 的风险和 HTTPS 的解决</h4><p>安全上存在三个风险</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p>HTTPS的<code>SSL/TLS</code>协议的 解决办法：</p><ul><li>信息加密：交互信息无法被窃取 （混合加密）</li><li>校验机制：无法篡改通信内容 （摘要算法+数字签名）</li><li>身份证书：保证身份的准确性（数字证书）</li></ul><h5 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h5><p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的方式</p><ul><li>再通信建立前采用<strong>非对称加密</strong>的方式，交换会话密钥:key:，后续就不再使用非对称加密</li><li>再通信过程中全部使用<strong>对称加密</strong>的会话密钥:key:加密明文数据</li></ul><p>采用混合加密的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换</li><li><strong>非对称加密</strong>，使用公钥和私钥，解决了密钥交换问题但速度慢</li></ul><h5 id="摘要算法和数字签名"><a href="#摘要算法和数字签名" class="headerlink" title="摘要算法和数字签名"></a>摘要算法和数字签名</h5><p>利用摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的指纹，之歌哈希值是唯一的，且无法通过哈希值推导出内容</p><p>通过摘要算法可以保证内容不会被篡改，但是无法保证整个内容有没有被替换出去，缺少客户端收到的消息来源于服务端的证明</p><p>采用<strong>非对称加密算法</strong>来解决这个问题：</p><ul><li>一个公钥，公开给所有人</li><li>一个私钥，必须由本人管理，不可泄漏</li></ul><p>两个密钥可以互相加密或者解密，流程不同，目的也不同</p><ul><li><p><strong>公钥加密，私钥解密</strong>：</p><ul><li><strong>保证内容传输的安全</strong></li><li>被公钥加密的内容，其他人是无法解密的，只有持有私钥的人才能解密</li></ul></li><li><p><strong>私钥加密，公钥解密</strong>：</p><ul><li>保证消息不会被冒充</li><li>私钥不可泄漏，如果公钥能够正常解密出私钥加密的内容，就说米这个消息时来源于持有私钥身份的人发送的</li></ul></li></ul><p>数字签名算法：就是通过私钥加密，公钥解密的方式来确认消息的身份</p><h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><ul><li>已经保证了消息的完整性</li><li>保证了消息来源的可靠性</li></ul><p>但是缺少身份验证的环节，可以私钥和公钥都被替换掉了</p><p>因此，提出数字证书：</p><p>「个人信息 + 公钥 + 数字签名」打包成一个数字证书</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419110359781.png" alt="image-20230419110359781" style="zoom: 80%;" /></p><h4 id="HTTPS建立连接的流程"><a href="#HTTPS建立连接的流程" class="headerlink" title="HTTPS建立连接的流程"></a>HTTPS建立连接的流程</h4><p>SSL/TLS 协议的基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥</li><li>双方协商生产会话密钥</li><li>双方采用会话密钥进行加密通信</li></ul><p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法 (opens new window)和 ECDHE 算法 (opens new window)。</p><h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程"></p><ul><li>第一次握手：客户端发送 「<strong>Client Hello</strong>」里面有TLS版本号，随机数C，密码套件列表</li><li>第二次握手：<ul><li>服务器端发送「<strong>Server Hello</strong>」，里面有确认的TLS版本号，随机数S，密码套件（RSA）</li><li>服务器端「<strong>Server Certificate</strong>」，里面有数字证书</li><li>服务端发了「<strong>Server Hello Done</strong>」消息，告诉打招呼完毕</li></ul></li><li>第三次握手：<ul><li>客户端发送「<strong>Client Key Exchange</strong>」，里面包含加密后的随机数A，此时客户端已经有三个随机数，生成了<strong>会话密钥（Master Secret）</strong>。</li><li>客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务器开始使用加密方式发送消息</li><li>客户端发一个「<strong>Finish</strong>」</li></ul></li><li>第四次握手：<ul><li>服务器端发「<strong>Change Cipher Spec</strong>」告诉客户端开始使用加密方式发送消息</li><li>服务器端发「<strong>Finish</strong>」</li><li>服务器端会发「<strong>Encrypted Handshake Message</strong>」消息，让客户端验证对称密钥是否可以正常使用</li></ul></li></ul><h5 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h5><p>不支持前向保密</p><p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解</p><h4 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h4><p><strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p><p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p><ul><li><p>第一次握手：客户端发送 「<strong>Client Hello</strong>」里面有TLS版本号，随机数C，密码套件列表</p></li><li><p>第二次握手：</p><ul><li><p>服务端发送「<strong>Server Hello</strong>」消息，里面有确认的TLS版本号，随机数S，密码套件（ECDHE）</p></li><li><p>服务器端发送「<strong>Server Certificate</strong>」，里面有数字证书</p></li><li>服务器端发送「<strong>Server Key Exchange</strong>」，里面有选择的椭圆曲线，椭圆曲线的公钥，密钥留在服务器内</li><li>服务端发送「<strong>Server Hello Done</strong>」消息，告诉打招呼完毕</li></ul></li></ul><p><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p><ul><li><p>第三次握手：</p><ul><li>客户端发送「<strong>Client Key Exchange</strong>」，里面有椭圆曲线的公钥，私钥留在客户端内</li><li>客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</li><li>客户端会发「<strong>Encrypted Handshake Message</strong>」消息，让服务器端验证对称密钥是否可以正常使用</li></ul></li><li><p>第四次握手：</p><ul><li>服务端 发「<strong>Change Cipher Spec</strong>」告诉客户端开始使用加密方式发送消息</li><li>服务器端会发「<strong>Encrypted Handshake Message</strong>」消息，让客户端验证对称密钥是否可以正常使用</li></ul></li></ul><p>ECDHE密钥协商算法支持前向保密</p><h4 id="HTTPS一定安全可靠么"><a href="#HTTPS一定安全可靠么" class="headerlink" title="HTTPS一定安全可靠么"></a>HTTPS一定安全可靠么</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img"></p><p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p><h4 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h4><ul><li>性能损耗：<ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul></li><li><p>硬件优化：</p><ul><li><strong>HTTPS 协议是计算密集型，而不是 I/O 密集型</strong></li><li>选择好的CPU</li><li>选择可以<strong>支持 AES-NI 特性的 CPU</strong></li></ul></li><li><p>软件优化：</p><ul><li>软件升级：<ul><li>将 Linux 内核从 2.x 升级到 4.x；</li><li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li></ul></li><li>协议优化：<ul><li>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高。</li><li><strong>选用 ECDHE 密钥交换</strong>，支持「False Start」，<strong>而且安全性也高，具备前向安全性</strong></li></ul></li><li>TLS升级：<ul><li>TLS 1.2 升级成 TLS 1.3，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</li><li><strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</li></ul></li></ul></li><li><p>证书优化：</p><ul><li>证书传输优化：选择ECDSA证书</li><li>证书验证优化：</li></ul></li><li><p>会话复用：</p><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p><ul><li><p>Session ID：<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong></p><p>问题：</p><ul><li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li><li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li></ul></li><li><p>Session Ticket：<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p></li></ul><p>二者都<strong>不具备前向安全性</strong></p></li></ul><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h4 id="HTTP-1-1的问题"><a href="#HTTP-1-1的问题" class="headerlink" title="HTTP/1.1的问题"></a>HTTP/1.1的问题</h4><ul><li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li><li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li><li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li><li><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；</li><li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li></ul><h4 id="HTTP-2兼容HTTP-1-1"><a href="#HTTP-2兼容HTTP-1-1" class="headerlink" title="HTTP/2兼容HTTP/1.1"></a>HTTP/2兼容HTTP/1.1</h4><h4 id="改进方面"><a href="#改进方面" class="headerlink" title="改进方面"></a>改进方面</h4><ul><li>头部压缩：<ul><li><strong>HPACK</strong> 算法压缩头部数据</li></ul></li><li>二进制帧：<ul><li>将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率</li></ul></li><li>并发传输：<ul><li>通过 Stream，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量</li></ul></li><li>服务器主动推送资源：<ul><li>根据Stream的编号来实现推送，偶数号 Stream 发送资源给客户端。</li><li>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</li></ul></li></ul><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419115607305.png" alt="image-20230419115607305" style="zoom:80%;" /></p><ul><li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</li><li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li><li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</li></ul><p><strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419115832102.png" alt="image-20230419115832102"></p><h4 id="缺陷：-1"><a href="#缺陷：-1" class="headerlink" title="缺陷："></a>缺陷：</h4><ul><li><p>队头阻塞：</p><ul><li>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</li><li>比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。    <img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419120120966.png" alt="image-20230419120120966"></li></ul></li><li><p>TCP 与 TLS 的握手时延迟：</p><ul><li>TCP 三次握手和 TLS 四次握手（TLS 1.2）需要 3 个 RTT 的时延才能发出请求数据</li></ul></li><li>网络迁移需要重新连接：<ul><li>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的</li><li>如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手</li></ul></li></ul><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>针对HTTP/2中的问题，提出了HTTP/3来解决，主要就是使用了UDP协议，并且「应用层」实现了 <strong>QUIC 协议</strong>，让UDP协议变得可靠了</p><h4 id="QUIC协议的特点"><a href="#QUIC协议的特点" class="headerlink" title="QUIC协议的特点"></a>QUIC协议的特点</h4><ul><li>无队头阻塞：<ul><li>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream</li><li>QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</li><li>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li></ul></li><li><p>更快的连接建立：</p><ul><li>QUIC 协议握手，这个握手过程只需要 1 RTT</li><li><strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，</strong></li></ul></li><li><p>连接迁移：</p><ul><li>QUIC 协议通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己</li><li>即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接</li></ul></li></ul><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/da970d16a205fb48d6a8bea14498814d.png" alt="四层网络协议"></p><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p><p> RPC 调用的协议目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</p><p>内部集群的微服务之间则采用 RPC 协议进行通讯。</p><p><strong>HTTP/2.0</strong> 在 <strong>HTTP/1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC</p><h4 id="HTTP和RPC的区别"><a href="#HTTP和RPC的区别" class="headerlink" title="HTTP和RPC的区别"></a>HTTP和RPC的区别</h4><ul><li><p>服务发现</p><ul><li><strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong>去解析得到它背后的 IP 地址，默认 80 端口</li><li><strong>RPC</strong> 的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，想要访问某个服务，就去这些中间服务去获得 IP 和端口信息</li></ul></li><li><p>底层连接形式：</p><ul><li><strong>HTTP/1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>Keep Alive</strong>）</li><li><strong>RPC</strong> 协议，除了长连接以外，建个<strong>连接池</strong>，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong></li><li><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池</strong>，比如 <strong>Go</strong> 就是这么干的。</li></ul></li><li>传输的内容：<ul><li>HTTP/1.1，传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>Json</strong> 来<strong>序列化</strong>结构体数据。比较冗余</li><li>RPC，因为它定制化程度更高，采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据</li></ul></li></ul><h3 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h3><p>场景需求：<strong>服务器主动发消息给客户端的场景</strong></p><p>三种方式：</p><h4 id="使用-HTTP-不断轮询："><a href="#使用-HTTP-不断轮询：" class="headerlink" title="使用 HTTP 不断轮询："></a>使用 HTTP 不断轮询：</h4><p><strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p><p>一种「<strong>伪</strong>」服务器推的形式，是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p><p>常见方式：<strong>扫码登录</strong>：<strong>前端</strong>不知道扫没扫，向<strong>后端</strong>服务器询问</p><p>但这样，会有两个比较明显的问题：</p><ul><li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li><li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li></ul><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><ul><li>先将HTTP 请求<strong>超时设置的很大</strong>，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></li><li>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/1058a96ba35215c0f30accc3ff5bb824.png" alt="图片"></p><h4 id="WebScoket-1"><a href="#WebScoket-1" class="headerlink" title="WebScoket"></a>WebScoket</h4><p><strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>，适用于客户端和服务器之间都要互相主动发大量数据的场景。</p><p>WebScoket建立流程：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/f4edd3018914fe6eb38fad6aa3fd2d65.png" alt="图片" style="zoom:80%;" /></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-IP</title>
      <link href="/mingyry/248e04fe.html"/>
      <url>/mingyry/248e04fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-IP"><a href="#计算机网络-IP" class="headerlink" title="计算机网络-IP"></a>计算机网络-IP</h2><h3 id="IP基本认识"><a href="#IP基本认识" class="headerlink" title="IP基本认识"></a>IP基本认识</h3><p>IP 在 TCP/IP 参考模型中处于第三层，也就是<strong>网络层</strong></p><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong></p><blockquote><p>网络层与数据链路层有什么关系呢？</p><p><strong>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p></blockquote><p>在网络中数据包传输中也是如此，<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><h3 id="IP地址的基础知识"><a href="#IP地址的基础知识" class="headerlink" title="IP地址的基础知识"></a>IP地址的基础知识</h3><p>IP 地址（IPv4 地址）由 <code>32</code> 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。</p><p>而人类为了方便记忆采用了<strong>点分十进制</strong>的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 <code>4</code> 组，每组以「<code>.</code>」隔开，再将每组转换成十进制。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/4.jpg" alt=""></p><p>IP 地址最大值也就是</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/5.jpg" alt=""></p><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/7.jpg" alt=""></p><blockquote><p>什么是 A、B、C 类地址？ </p></blockquote><p>A、B、C 类主要分为两个部分，分别是<strong>网络号和主机号</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/8.jpg" alt="img"></p><blockquote><p>A、B、C 分类地址最大主机个数是如何计算的呢？</p></blockquote><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播</li><li>主机号全为 0 指定某个网络</li></ul><p>最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数:</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/9.jpg" alt="img"></p><blockquote><p>广播地址用于什么？</p></blockquote><p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p><p>广播地址可以分为本地广播和直接广播两种。</p><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li></ul><blockquote><p>什么是 D、E 类地址？</p></blockquote><p>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/12.jpg" alt="img"></p><blockquote><p>多播地址用于什么？</p></blockquote><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p><p>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/13.jpg" alt="单播、广播、多播通信" style="zoom:80%;" /></p><p>多播使用的 D 类地址，其前四位是 <code>1110</code> 就表示是多播地址，而剩下的 28 位是多播的组编号。</p><p>从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：</p><ul><li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li><li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li><li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li></ul><blockquote><p>IP分类的优点</p></blockquote><p>不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/14.jpg" alt="IP 分类判断" style="zoom:67%;" /></p><blockquote><p>IP 分类的缺点</p></blockquote><p><em>缺点一</em></p><p><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就<strong>缺少地址的灵活性</strong>。</p><p><em>缺点二</em></p><p>A、B、C类有个尴尬处境，就是<strong>不能很好的与现实网络匹配</strong>。</p><ul><li>C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。</li><li>而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li></ul><p>这两个缺点，都可以在 <code>CIDR</code> 无分类地址解决。</p><h4 id="CIDR无分类地址"><a href="#CIDR无分类地址" class="headerlink" title="CIDR无分类地址"></a>CIDR无分类地址</h4><p>32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><blockquote><p>怎么划分网络号和主机号的呢？</p></blockquote><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code>，这就使得 IP 地址更加具有灵活性。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/15.jpg" alt="img" style="zoom:67%;" /></p><p>还有另一种划分网络号与主机号形式，那就是<strong>子网掩码</strong>，掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p><p><strong>将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/16.jpg" alt="img" style="zoom: 80%;" /></p><blockquote><p>为什么要分离网络号和主机号？</p></blockquote><p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p><p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p><blockquote><p> 怎么进行子网划分？</p></blockquote><p>网掩码还有一个作用，那就是<strong>划分子网</strong>。</p><p><strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong>。形式如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/18.jpg" alt="img"></p><ul><li>未做子网划分的 ip 地址：网络地址＋主机地址</li><li>做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421100351993.png" alt="image-20230421100351993"></p><h4 id="公有-IP-地址与私有-IP-地址"><a href="#公有-IP-地址与私有-IP-地址" class="headerlink" title="公有 IP 地址与私有 IP 地址"></a>公有 IP 地址与私有 IP 地址</h4><p>在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/22.jpg" alt="img"></p><h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。</p><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。</p><p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有<strong>相同网络地址</strong>的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/25.jpg" alt="IP 地址与路由控制"></p><ol><li>主机 A 要发送一个 IP 包，其源地址是 <code>10.1.1.30</code> 和目标地址是 <code>10.1.2.10</code>，由于没有在主机 A 的路由表找到与目标地址 <code>10.1.2.10</code> 相同的网络地址，于是包被转发到默认路由（路由器 <code>1</code> ）</li><li>路由器 <code>1</code> 收到 IP 包后，也在路由器 <code>1</code> 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 <code>10.1.0.2</code> 这台路由器 <code>2</code></li><li>路由器 <code>2</code> 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 <code>2</code> 的 <code>10.1.2.1</code> 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机</li></ol><h4 id="IP-分片与重组"><a href="#IP-分片与重组" class="headerlink" title="IP 分片与重组"></a>IP 分片与重组</h4><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，其中，我们最常见数据链路是以太网，它的 MTU 是 <code>1500</code> 字节。</p><p>当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。</p><p>分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，<strong>路由器是不会进行重组</strong>的。</p><p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 <code>MSS</code> 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p><h4 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h4><p>IPv6 的地址是 <code>128</code> 位的，这可分配的地址数量是大的惊人</p><p>但 IPv6 除了有更多的地址之外，还有更好的安全性和扩展性，说简单点就是 IPv6 相比于 IPv4 能带来更好的网络体验。</p><p>但是因为 IPv4 和 IPv6 不能相互兼容，所以不但要我们电脑、手机之类的设备支持，还需要网络运营商对现有的设备进行升级，所以这可能是 IPv6 普及率比较慢的一个原因。</p><blockquote><p>IPv6 地址的结构</p></blockquote><p>IPv6 的地址主要有以下类型地址：</p><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/29.jpg" alt="IPv6地址结构"></p><h4 id="IPv4-首部与-IPv6-首部"><a href="#IPv4-首部与-IPv6-首部" class="headerlink" title="IPv4 首部与 IPv6 首部"></a>IPv4 首部与 IPv6 首部</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/31.jpg" alt="IPv4 首部与 IPv6 首部的差异"></p><p>IPv6 相比 IPv4 的首部改进：</p><ul><li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li><li><strong>取消了分片/重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li><li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 <code>40</code> 字节。</li></ul><h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><ul><li>DNS 域名解析</li><li>ARP 与 RARP 协议</li><li>DHCP 动态获取 IP 地址</li><li>NAT 网络地址转换</li><li>ICMP 互联网控制报文协议</li><li>IGMP 因特网组管理协议</li></ul><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p><strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。</p><blockquote><p>域名的层级关系</p></blockquote><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器</li><li>顶级域 DNS 服务器（com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/32.jpg" alt="DNS 树状结构" style="zoom:80%;" /></p><blockquote><p>域名解析的工作流程</p></blockquote><p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 <code>hosts</code>，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：</p><ol><li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。</p><p>然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。</p><p>ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。</p><ul><li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机</li></ul><blockquote><p>RARP 协议你知道是什么吗？</p></blockquote><p><strong>已知 MAC 地址求 IP 地址</strong>，将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p><p>需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/35.jpg" alt="RARP" style="zoom:80%;" /></p><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP 动态获取 IP 地址</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/36.jpg" alt="DHCP 工作流程" style="zoom: 80%;" /></p><p>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。</p><p>这 4 个步骤：</p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li><li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li></ul><p>DHCP 交互中，<strong>全程都是使用 UDP 广播通信</strong>。</p><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址</li></ul><blockquote><p>用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p></blockquote><p>为了解决这一问题，就出现了 <strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/37.jpg" alt=" DHCP 中继代理" style="zoom:80%;" /></p><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li></ul><p>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>Pv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。</p><p>于是，提出了一种<strong>网络地址转换 NAT</strong> 的方法，再次缓解了 IPv4 地址耗尽的问题。</p><p>NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/38.jpg" alt="NAT"></p><p>由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。</p><p>因此，可以把 IP 地址 + 端口号一起进行转换。</p><p>这样，就用一个全球 IP 地址就可以了，这种转换技术就叫<strong>网络地址与端口转换 NAPT。</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/39.jpg" alt="NAPT"></p><p><strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p><blockquote><p>缺点</p></blockquote><p>由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><blockquote><p>如何解决 NAT 潜在的问题呢？</p></blockquote><p><em>第一种就是改用 IPv6</em></p><p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。</p><p><em>第二种 NAT 穿透技术</em></p><p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p><blockquote><p>ICMP 功能都有啥？</p></blockquote><p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/4.jpg" alt="ICMP 目标不可达消息"></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p><blockquote><p>ICMP 类型</p></blockquote><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/41.jpg" alt="常见的 ICMP 类型" style="zoom:67%;" /></p><h4 id="IGMP-Internet组管理协议"><a href="#IGMP-Internet组管理协议" class="headerlink" title="IGMP(Internet组管理协议)"></a>IGMP(Internet组管理协议)</h4><p>在前面我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/42.jpg" alt="组播模型"></p><p><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong></p><ul><li>IGMP 报文向路由器申请加入和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除非主机通过 IGMP 加入到组播组，主机申请加入到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h3><p>重点来看 <code>ping</code> 的<strong>发送和接收过程</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103655610.png" alt="image-20230421103655610"></p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>第一个是<strong>类型</strong>，对于回送请求消息而言该字段为 <code>8</code>；</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103716689.png" alt="image-20230421103716689"></p><p> ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p>加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103805334.png" alt="image-20230421103805334"></p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421103850220.png" alt="image-20230421103850220"></p><h3 id="断网了，还能-ping-通-127-0-0-1-吗？"><a href="#断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="断网了，还能 ping 通 127.0.0.1 吗？"></a>断网了，还能 ping 通 127.0.0.1 吗？</h3><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”</strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前<strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>执行 ping 0.0.0.0 ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP</title>
      <link href="/mingyry/96599ed7.html"/>
      <url>/mingyry/96599ed7.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-TCP"><a href="#计算机网络-TCP" class="headerlink" title="计算机网络-TCP"></a>计算机网络-TCP</h2><h3 id="TCP基础知识"><a href="#TCP基础知识" class="headerlink" title="TCP基础知识"></a>TCP基础知识</h3><h4 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230534096.png" alt="TCP 头格式"></p><ul><li>序列号：由计算机生成的随机数作为其初始值。<strong>用来解决网络包乱序问题。</strong></li><li>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></li><li>控制位：<ul><li>ACK：1，确认应答有效</li><li>RST：1，出现异常需要强制断开连接</li><li>SYN：1，表示希望建立连接</li><li>FIN：1，表示希望断开连接</li></ul></li></ul><h4 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h4><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421110503510.png" alt="image-20230421110503510"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230421110541154.png" alt="image-20230421110541154"></p><h4 id="TCP的概念"><a href="#TCP的概念" class="headerlink" title="TCP的概念"></a>TCP的概念</h4><p>TCP是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p><ul><li>面向连接：一对一连接，无法一对多</li><li>可靠的：保证报文一定能够到达接收端</li><li>字节流：TCP报文有序但是无边界</li></ul><h4 id="唯一确定TCP连接"><a href="#唯一确定TCP连接" class="headerlink" title="唯一确定TCP连接"></a>唯一确定TCP连接</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230433082.png" alt="TCP 四元组"></p><p>最大TCP连接数=客户端的IP数 * 客户端的端口数</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><div class="table-container"><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>需要建立连接</td><td>不需要建立连接</td></tr><tr><td>一对一</td><td>一对一、一对多、多对多</td></tr><tr><td>可靠交付数据</td><td>尽最大努力交付</td></tr><tr><td>有拥塞控制和流量控制</td><td>无</td></tr><tr><td>20字节首部开销（无选项字段下）</td><td>8字节，固定不变</td></tr><tr><td>流式传输，无边界</td><td>包传输，有边界</td></tr><tr><td>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片</td><td>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片</td></tr></tbody></table></div><h5 id="TCP-和-UDP-可以使用同一个端口"><a href="#TCP-和-UDP-可以使用同一个端口" class="headerlink" title="TCP 和 UDP 可以使用同一个端口"></a>TCP 和 UDP 可以使用同一个端口</h5><h4 id="TCP-面向字节流"><a href="#TCP-面向字节流" class="headerlink" title="TCP 面向字节流"></a>TCP 面向字节流</h4><blockquote><p>为什么 TCP 是面向字节流的协议？</p></blockquote><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p><blockquote><p>如何解决粘包？</p></blockquote><p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p><p>一般有三种方式分包的方式：</p><ul><li><p>固定长度的消息；</p></li><li><p>特殊字符作为边界；</p><ul><li><p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p></li><li><p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p></li></ul></li><li><p>自定义消息结构。</p><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p></li></ul><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419164333417.png" alt="image-20230419164333417" style="zoom:80%;" /></p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><p>Linux查看TCP状态：<code>netstat -napt</code></p><h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><p>三个方面分析三次握手的原因：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h5 id="原因1：避免历史连接"><a href="#原因1：避免历史连接" class="headerlink" title="原因1：避免历史连接"></a>原因1：避免历史连接</h5><p><strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong></p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230525514.png" alt="三次握手避免历史连接" style="zoom:80%;" /></p><blockquote><p>如果是两次握手，没办法阻止历史连接</p><p><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p></blockquote><h5 id="原因2：同步双方初始序列号"><a href="#原因2：同步双方初始序列号" class="headerlink" title="原因2：同步双方初始序列号"></a>原因2：同步双方初始序列号</h5><p>序列号在 TCP 连接中占据着非常重要的作用</p><ul><li><p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，</p></li><li><p>当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，</p></li><li><p><strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步</strong></p></li></ul><blockquote><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p></blockquote><h5 id="原因3：避免资源浪费"><a href="#原因3：避免资源浪费" class="headerlink" title="原因3：避免资源浪费"></a>原因3：避免资源浪费</h5><ul><li>两次握手会大量建立多个冗余的无效连接，造成不必要的资源浪费</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230636571.png" alt="两次握手会造成资源浪费" style="zoom:67%;" /></p><h4 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419165608471.png" alt="image-20230419165608471"></p><p>过程如下：</p><ul><li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。</li><li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li><li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li></ul><p>每次初始化序列号不一样很大程度上能够避免历史报文被下一个相同四元组的连接接收</p><h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230633447.png" alt="MTU 与 MSS"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>当TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p><p>当TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p><h4 id="握手丢失情况"><a href="#握手丢失情况" class="headerlink" title="握手丢失情况"></a>握手丢失情况</h4><h5 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h5><p>客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p><ul><li>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</li><li>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</li><li>达到最大重传次数（tcp_syn_retries ）后，等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li></ul><h5 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h5><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p><ul><li>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li><li><strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li></ul><h5 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h5><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><ul><li>当服务端重传 SYN-ACK 报文后，达到最大重传次数（ tcp_synack_retrie），于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接</li></ul><h3 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h3><h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><p>TCP 断开连接是通过<strong>四次挥手</strong>方式。</p><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:80%;" /></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><h4 id="挥手丢失情况"><a href="#挥手丢失情况" class="headerlink" title="挥手丢失情况"></a>挥手丢失情况</h4><h5 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h5><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p><ul><li>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，<strong>重传 FIN 报文</strong>，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</li><li>当客户端达到最大重传次数后，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。</li></ul><h5 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h5><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p><ul><li><p>ACK 报文是不会重传的，如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文（第一次挥手），直到收到服务端的第二次挥手，或者达到最大的重传次数。</p></li><li><p>当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</p></li></ul><blockquote><p>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态</p><ul><li>close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</li><li>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。形成死等。</li></ul></blockquote><h5 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h5><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。这时候服务器端还是可以发送数据的</p><p>服务端处于 <code>CLOSE_WAIT</code> 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 <code>LAST_ACK</code> 状态，等待客户端返回 ACK 来确认连接关闭。</p><ul><li>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</li><li>当服务端重传第三次挥手报文的次数达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 <code>FIN_WAIT_2</code> 状态是有时长限制的，如果<code>tcp_fin_timeout</code> 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接</li></ul><h5 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h5><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态.</p><p><strong>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</strong></p><ul><li>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会<strong>重发 FIN 报文</strong>，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</li><li>当服务端重传第三次挥手报文达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li><li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接.</li></ul><h4 id="TIME-WAIT的情况"><a href="#TIME-WAIT的情况" class="headerlink" title="TIME_WAIT的情况"></a>TIME_WAIT的情况</h4><h5 id="1-为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#1-为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="1. 为什么 TIME_WAIT 等待的时间是 2MSL？"></a>1. 为什么 TIME_WAIT 等待的时间是 2MSL？</h5><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，<strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><h5 id="2-为什么需要-TIME-WAIT-状态？"><a href="#2-为什么需要-TIME-WAIT-状态？" class="headerlink" title="2. 为什么需要 TIME_WAIT 状态？"></a>2. 为什么需要 TIME_WAIT 状态？</h5><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；<ul><li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li><li>TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，保证所有的数据报文都会被丢弃</li></ul></li><li>保证「被动关闭连接」的一方，能被正确的关闭<ul><li>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></li></ul></li></ul><h5 id="3-TIME-WAIT-过多有什么危害？"><a href="#3-TIME-WAIT-过多有什么危害？" class="headerlink" title="3. TIME_WAIT 过多有什么危害？"></a>3. TIME_WAIT 过多有什么危害？</h5><ul><li>第一是，<strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是，<strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><h5 id="4-服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#4-服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="4. 服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>4. 服务器出现大量 TIME_WAIT 状态的原因有哪些？</h5><p>如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><ul><li><p><em>第一个场景：HTTP 没有使用长连接</em></p><ul><li><strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</li></ul></li><li><p><em>第二个场景：HTTP 长连接超时</em></p><ul><li>HTTP 长连接具有超时时间，超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong></li><li>一般是网络问题导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时</li></ul></li><li><em>第三个场景：HTTP 长连接的请求数量达到上限</em><ul><li>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接</li><li><strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接</li><li><strong>对于一些 QPS（每秒请求数） 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong></li><li>解决办法：调大 nginx 的 keepalive_requests 参数就行</li></ul></li></ul><h5 id="5-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#5-在-TIME-WAIT-状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="5. 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？"></a>5. 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom:80%;" /></p><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li><li><strong>非法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li></ul><p>当收到合法SYN时，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p><p>当收到非法SYN时，<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p><h5 id="6-如果-TIME-WAIT-状态持续时间过短或者没有，会有什么问题？"><a href="#6-如果-TIME-WAIT-状态持续时间过短或者没有，会有什么问题？" class="headerlink" title="6.如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？"></a>6.如果 TIME_WAIT 状态持续时间过短或者没有，会有什么问题？</h5><p><code>tcp_tw_reuse</code> 的作用是让客户端快速复用处于 <code>TIME_WAIT</code> 状态的端口，相当于跳过了 <code>TIME_WAIT</code> 状态，这可能会出现这样的两个问题：</p><ul><li>历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。</li><li>如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;</li></ul><h4 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h4><p>如果「被动关闭方」<strong>没有调用 close 函数关闭连接</strong>，那么就<strong>无法发出 FIN 报文</strong>，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p><strong>通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>客户端出现故障指的是客户端的<strong>主机发生了宕机，或者断电的场景</strong>。发生这种情况的时候，如果服务端<strong>一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机</strong>这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p><ol><li><p>TCP存在<strong>保活机制</strong>（keepalive）：</p><ul><li><p>一个时间段内，如果没有任何连接相关的活动，TCP 保活机制每隔一个时间间隔，发送一个探测报文</p></li><li><p>该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应</p></li><li><p>则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></li></ul></li><li><p>心跳机制</p><ul><li>设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，</li><li>如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></li></ul></li></ol><h4 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><p><strong>总结：</strong></p><p>如果「<strong>客户端进程崩溃</strong>」，客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手。</p><p>但是，「<strong>客户端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看服务端会不会发送数据？</p><ul><li>如果服务端会发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 <code>tcp_retries2</code> 设置的值计算出一个阈值）后，会断开 TCP 连接；</li><li>如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？<ul><li>如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；</li><li>如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。</li></ul></li></ul><h4 id="拔掉网线后，-原本的-TCP-连接还存在吗"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗"></a>拔掉网线后， 原本的 TCP 连接还存在吗</h4><p>两种场景来讨论：</p><ol><li><h5 id="拔掉网线后，有数据传输："><a href="#拔掉网线后，有数据传输：" class="headerlink" title="拔掉网线后，有数据传输："></a>拔掉网线后，有数据传输：</h5><ul><li>如果服务端发送了数据报文，那么在<strong>服务端重传次数没有达到最大值之前</strong>，客户端就插回了网线，那么双方原本的 TCP 连接还是能<strong>正常存在</strong>，就好像什么事情都没有发生。</li><li>如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数<strong>达到了最大值时</strong>，服务端就会断开 TCP 连接。<strong>等到客户端插回网线后，向服务端发送了数据</strong>，因为服务端已经<strong>断开了与客户端相同四元组的 TCP 连接</strong>，所以就会回 <strong>RST</strong> 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</li></ul></li><li><h5 id="没有数据传输的情况："><a href="#没有数据传输的情况：" class="headerlink" title="没有数据传输的情况："></a>没有数据传输的情况：</h5><ul><li>如果双方都没有开启 TCP keepalive 机制，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li><li>开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li></ul></li></ol><h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><h4 id="三次握手的细节："><a href="#三次握手的细节：" class="headerlink" title="三次握手的细节："></a>三次握手的细节：</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419224841011.png" alt="image-20230419224841011" style="zoom:67%;" /></p><p><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h4 id="四次挥手细节："><a href="#四次挥手细节：" class="headerlink" title="四次挥手细节："></a>四次挥手细节：</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230538308.png" alt="客户端调用 close 过程"></p><ul><li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li><li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong></li><li>当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li></ul><h5 id="没有-accept，也能建立-TCP-连接："><a href="#没有-accept，也能建立-TCP-连接：" class="headerlink" title="没有 accept，也能建立 TCP 连接："></a>没有 accept，也能建立 TCP 连接：</h5><p><code>accpet</code> 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket</p><p>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开</p><h5 id="没有-listen，也能建立-TCP-连接："><a href="#没有-listen，也能建立-TCP-连接：" class="headerlink" title="没有 listen，也能建立 TCP 连接："></a>没有 listen，也能建立 TCP 连接：</h5><p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h5 id="没有-listen，发送数据："><a href="#没有-listen，发送数据：" class="headerlink" title="没有 listen，发送数据："></a>没有 listen，发送数据：</h5><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><h3 id="TCP可靠性"><a href="#TCP可靠性" class="headerlink" title="TCP可靠性"></a>TCP可靠性</h3><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p>如果数据在传输过程中丢失了，TCP会用<strong>重传机制</strong>解决：</p><h5 id="1-超时重传"><a href="#1-超时重传" class="headerlink" title="1. 超时重传"></a>1. 超时重传</h5><p>设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/8.jpg" alt="RTO 应略大于 RTT" style="zoom:50%;" /></p><p>TCP 的策略是<strong>超时间隔加倍。</strong></p><p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p><h5 id="2-快速重传"><a href="#2-快速重传" class="headerlink" title="2. 快速重传"></a>2. 快速重传</h5><p><strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/10.jpg" alt="快速重传机制" style="zoom: 80%;" /></p><p>存在的问题：<strong>重传的时候，是重传一个，还是重传所有。</strong></p><h5 id="3-SACK-选择性确认"><a href="#3-SACK-选择性确认" class="headerlink" title="3. SACK (选择性确认)"></a>3. SACK (<strong>选择性确认</strong>)</h5><p>在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><h5 id="4-Duplicate-SACK"><a href="#4-Duplicate-SACK" class="headerlink" title="4. Duplicate SACK"></a>4. Duplicate SACK</h5><p><strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><p>好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><h5 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h5><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/19.jpg" alt="SND.WND、SND.UN、SND.NXT"></p><p><strong>可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</strong></p><h5 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口<img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/20.jpg" alt="接收窗口"></h5><p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>发送窗口和接收窗口的被动态调节</p><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭</strong></p><blockquote><p>窗口关闭潜在的危险</p><p>当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/24.jpg" alt="窗口关闭潜在的危险"></p><p>TCP 解决窗口关闭时，潜在的死锁现象：</p><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p></blockquote><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>流量控制是避免「发送方」的数据填满「接收方」的缓存</p><p><strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><p>拥塞控制主要是四个算法：</p><h5 id="1-慢启动："><a href="#1-慢启动：" class="headerlink" title="1. 慢启动："></a>1. 慢启动：</h5><p>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。<strong>2的倍数增长</strong></p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」</li></ul><h5 id="2-拥塞避免算法："><a href="#2-拥塞避免算法：" class="headerlink" title="2. 拥塞避免算法："></a>2. 拥塞避免算法：</h5><p>每当收到一个 ACK 时，cwnd 增加 1/cwnd。<strong>线性增长</strong></p><p>触发了重传机制，也就进入了「拥塞发生算法」。</p><h5 id="3-拥塞发生："><a href="#3-拥塞发生：" class="headerlink" title="3. 拥塞发生："></a>3. 拥塞发生：</h5><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传<ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul></li><li>快速重传<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul></li></ul><h5 id="4-快速恢复："><a href="#4-快速恢复：" class="headerlink" title="4. 快速恢复："></a>4. 快速恢复：</h5><p>算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 <code>ssthresh</code> 的值，原因是该 ACK 确认了新的数据，说明从 <code>duplicated ACK</code> 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230419231410090.png" alt="image-20230419231410090" style="zoom:80%;" /></p><h3 id="TCP半连接队列和全连接队列"><a href="#TCP半连接队列和全连接队列" class="headerlink" title="TCP半连接队列和全连接队列"></a>TCP半连接队列和全连接队列</h3><h4 id="什么是-TCP-半连接队列和全连接队列？"><a href="#什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="什么是 TCP 半连接队列和全连接队列？"></a>什么是 TCP 半连接队列和全连接队列？</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/3.jpg" alt="半连接队列与全连接队列"></p><ul><li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK</li><li>客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li></ul><h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p>攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务</p><p><strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog：<ul><li>网卡接收数据包的速度大于内核处理的速度时</li></ul></li><li>增大 TCP 半连接队列：</li><li>开启 tcp_syncookies：<ul><li>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</li></ul></li><li>减少 SYN+ACK 重传次数：<ul><li>减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</li></ul></li></ul><h4 id="TCP-全连接队列溢出"><a href="#TCP-全连接队列溢出" class="headerlink" title="TCP 全连接队列溢出"></a>TCP 全连接队列溢出</h4><p>当服务端并发处理大量请求时，如果 <strong>TCP 全连接队列过小</strong>，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/11.jpg" alt="全连接队列溢出"></p><blockquote><p>如何增大 TCP 全连接队列呢？</p></blockquote><p><strong>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong>。</p><ul><li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li><li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li></ul><h4 id="TCP-半连接队列溢出"><a href="#TCP-半连接队列溢出" class="headerlink" title="TCP 半连接队列溢出"></a>TCP 半连接队列溢出</h4><p><strong>增大半连接队列，</strong></p><ul><li><strong>不仅增大 tcp_max_syn_backlog 的值，</strong></li><li><strong>还要增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。</li></ul><h3 id="TCP协议的缺陷"><a href="#TCP协议的缺陷" class="headerlink" title="TCP协议的缺陷"></a>TCP协议的缺陷</h3><h4 id="升级-TCP-的工作很困难"><a href="#升级-TCP-的工作很困难" class="headerlink" title="升级 TCP 的工作很困难"></a>升级 TCP 的工作很困难</h4><p>很多 TCP 协议的新特性，都是需要客户端和服务端同时支持才能生效的，并且TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核。</p><h4 id="TCP-建立连接的延迟"><a href="#TCP-建立连接的延迟" class="headerlink" title="TCP 建立连接的延迟"></a>TCP 建立连接的延迟</h4><p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。</p><h4 id="TCP-存在队头阻塞问题"><a href="#TCP-存在队头阻塞问题" class="headerlink" title="TCP 存在队头阻塞问题"></a>TCP 存在队头阻塞问题</h4><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。</p><h4 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h4><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p><h3 id="TCP面试问题"><a href="#TCP面试问题" class="headerlink" title="TCP面试问题"></a>TCP面试问题</h3><h4 id="1-SYN-报文什么时候情况下会被丢弃？"><a href="#1-SYN-报文什么时候情况下会被丢弃？" class="headerlink" title="1. SYN 报文什么时候情况下会被丢弃？"></a>1. SYN 报文什么时候情况下会被丢弃？</h4><ul><li>半连接队列满了：<ul><li>如果开启syncookies功能，即使半连接队列满了，也不会丢弃syn包</li><li>增大半连接队列，<strong>增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong></li></ul></li><li>全连接队列满了：<ul><li>调大 accpet 队列的最大长度，调大的方式是通过<strong>调大 backlog 以及 somaxconn 参数。</strong></li></ul></li></ul><h4 id="2-已建立连接的TCP，收到SYN会发生什么？"><a href="#2-已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="2. 已建立连接的TCP，收到SYN会发生什么？"></a>2. 已建立连接的TCP，收到SYN会发生什么？</h4><p>客户端再上线发起SYN握手，服务器怎么应对？</p><ul><li><strong>客户端的 SYN 报文里的端口号与历史连接不相同</strong><ul><li>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</li><li>旧连接里处于 Established 状态的服务端，如果服务端发送了数据包给客户端，客户的内核就会回 RST 报文，服务端收到后就会释放连接。</li><li>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</li></ul></li><li><strong>客户端的 SYN 报文里的端口号与历史连接相同</strong><br>如果客户端恢复后，发送的 SYN 报文中的源端口号跟上一次连接的源端口号一样<ul><li><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></li><li><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></li></ul></li></ul><h4 id="3-四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#3-四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="3.四次挥手中收到乱序的 FIN 包会如何处理？"></a>3.四次挥手中收到乱序的 FIN 包会如何处理？</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:80%;" /></p><ul><li><p>在 <strong>FIN_WAIT_2</strong> 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「<strong>乱序队列</strong>」，并不会进入到 TIME_WAIT 状态。</p></li><li><p>等再次收到前面被网络延迟的数据包时，会<strong>判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据</strong>，如果能在乱序队列中找到与当<strong>前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</strong></p></li></ul><h4 id="4-HTTPS-中-TLS-和-TCP-能同时握手吗？"><a href="#4-HTTPS-中-TLS-和-TCP-能同时握手吗？" class="headerlink" title="4. HTTPS 中 TLS 和 TCP 能同时握手吗？"></a>4. HTTPS 中 TLS 和 TCP 能同时握手吗？</h4><p><em>HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLSv1.2 四次握手</em></p><p>可以同时握手，两个前提同时满足才可以：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><h5 id="TCP-Fast-Open"><a href="#TCP-Fast-Open" class="headerlink" title="TCP Fast Open"></a>TCP Fast Open</h5><p><strong>想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程</strong></p><p>如果客户端和服务端同时支持 TCP Fast Open 功能，那么在完成首次通信过程后，后续客户端与服务端 的通信则可以绕过三次握手发送数据，这就减少了握手带来的 1 个 RTT 的时间消耗。</p><h5 id="TLSv1-3"><a href="#TLSv1-3" class="headerlink" title="TLSv1.3"></a>TLSv1.3</h5><p><strong>会话恢复</strong>机制，在<strong>重连 TLSv1.3 只需要 0-RTT</strong>，</p><h5 id="TCP-Fast-Open-TLSv1-3"><a href="#TCP-Fast-Open-TLSv1-3" class="headerlink" title="TCP Fast Open + TLSv1.3"></a>TCP Fast Open + TLSv1.3</h5><p>在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，<strong>在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。</strong></p><p>如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。</p><p><strong>因此如果「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的。</strong></p><p><strong>如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成。</strong></p><h4 id="5-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？"><a href="#5-TCP-四次挥手中，能不能把第二次的-ACK-报文，-放到第三次-FIN-报文一起发送？" class="headerlink" title="5. TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？"></a>5. TCP 四次挥手中，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？</h4><p><strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/52f35dcbe24a4ca7abb23f292837c707.png" alt="在这里插入图片描述"></p><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><blockquote><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></blockquote><h4 id="6-TCP-序列号和确认号是如何变化的？"><a href="#6-TCP-序列号和确认号是如何变化的？" class="headerlink" title="6. TCP 序列号和确认号是如何变化的？"></a>6. TCP 序列号和确认号是如何变化的？</h4><p><strong>发送的 TCP 报文：</strong></p><ul><li><strong>公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</strong></li><li><strong>公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</strong></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-UDP</title>
      <link href="/mingyry/d8da6227.html"/>
      <url>/mingyry/d8da6227.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-UDP"><a href="#计算机网络-UDP" class="headerlink" title="计算机网络-UDP"></a>计算机网络-UDP</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/format,png-20230309230439961.png" alt="UDP 头部格式"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC协议来实现UDP的可靠传输，已经应用在了HTTP/3上。</p><p>拿 HTTP/3 举例子，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/ab3283383013b707d1420b6b4cb8517c.png" alt="img"></p><h3 id="QUIC-是如何实现可靠传输的？"><a href="#QUIC-是如何实现可靠传输的？" class="headerlink" title="QUIC 是如何实现可靠传输的？"></a>QUIC 是如何实现可靠传输的？</h3><p>Packet Number 单调递增的两个好处：</p><ul><li><p>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。</p></li><li><p>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</p></li></ul><p>一个 Packet 报文中可以存放多个 QUIC Frame。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/6a94d41ef3d14cb6b7846e73da6c3104.png" alt="img" style="zoom:80%;" /></p><p>每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。</p><p>我这里只举例 Stream 类型的 Frame 格式，Stream 可以认为就是一条 HTTP 请求，它长这样：</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/536298d2c54a43b699026bffe0f85010.png" alt="img" style="zoom:80%;" /></p><ul><li>Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；</li><li>Offset 作用：类似于 TCP 协议中的 Seq 序号，<strong>保证数据的顺序性和可靠性</strong>；</li><li>Length 作用：指明了 Frame 数据的长度。</li></ul><p><strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong></p><p>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题</p><h3 id="QUIC-是如何解决-TCP-队头阻塞问题的？"><a href="#QUIC-是如何解决-TCP-队头阻塞问题的？" class="headerlink" title="QUIC 是如何解决 TCP 队头阻塞问题的？"></a>QUIC 是如何解决 TCP 队头阻塞问题的？</h3><blockquote><p>TCP 队头阻塞的问题，其实就是<strong>接收窗口的队头阻塞问题</strong>。</p><p><strong>TCP 必须按序处理数据，也就是 TCP 层为了保证数据的有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留</strong>，</p></blockquote><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p><h3 id="QUIC-是如何做流量控制的？"><a href="#QUIC-是如何做流量控制的？" class="headerlink" title="QUIC 是如何做流量控制的？"></a>QUIC 是如何做流量控制的？</h3><p>QUIC 实现流量控制的方式：</p><ul><li>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</li><li>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</li></ul><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><ul><li><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</li><li><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</li></ul><h3 id="QUIC-对拥塞控制改进"><a href="#QUIC-对拥塞控制改进" class="headerlink" title="QUIC 对拥塞控制改进"></a>QUIC 对拥塞控制改进</h3><p>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法，相当于将 TCP 的拥塞控制算法照搬过来了。</p><h3 id="QUIC-更快的连接建立"><a href="#QUIC-更快的连接建立" class="headerlink" title="QUIC 更快的连接建立"></a>QUIC 更快的连接建立</h3><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/4cad213f5125432693e0e2a512c2d1a1.png" alt="img"></p><h3 id="QUIC-是如何迁移连接的？"><a href="#QUIC-是如何迁移连接的？" class="headerlink" title="QUIC 是如何迁移连接的？"></a>QUIC 是如何迁移连接的？</h3><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xiaolincoding.com/network/">https://www.xiaolincoding.com/network/</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识</title>
      <link href="/mingyry/1ad06ab1.html"/>
      <url>/mingyry/1ad06ab1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h2><p>JDBC (Java Database Connectivity) 是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来范文数据库的标准Java类库，（java.sql, javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</p><h3 id="1-2-数据存储技术"><a href="#1-2-数据存储技术" class="headerlink" title="1.2 数据存储技术"></a>1.2 数据存储技术</h3><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO（Java Data Object）技术</li><li>第三方O/R工具，如Hibernate，Mybatis等</li></ul><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC</p><h2 id="2-获取数据库连接"><a href="#2-获取数据库连接" class="headerlink" title="2. 获取数据库连接"></a>2. 获取数据库连接</h2><h3 id="2-1-Driver-接口实现类"><a href="#2-1-Driver-接口实现类" class="headerlink" title="2.1 Driver 接口实现类"></a>2.1 Driver 接口实现类</h3><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动：com.mysql.jdbc.Driver</li></ul><h3 id="2-2-加载和注册JDBC驱动"><a href="#2-2-加载和注册JDBC驱动" class="headerlink" title="2.2 加载和注册JDBC驱动"></a>2.2 加载和注册JDBC驱动</h3><ul><li><p>加载驱动：加载JDBC驱动需要调用Class类的静态方法forName()，向其传递要加载的JDBC驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”)</strong>;</li></ul></li><li><p>注册驱动：DriverManager类是驱动程序管理器类，负责管理驱动程序</p><ul><li>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</li><li>通常不用显式调用DriverManager类的registerDriver()方法来注册，因为Driver接口的驱动程序类都包含了静态代码块，会在创建时自动调用方法。</li></ul></li></ul><h3 id="2-3-URL"><a href="#2-3-URL" class="headerlink" title="2.3 URL"></a>2.3 URL</h3><ul><li>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。</li><li>JDBC URL 的标准由三部分组成，各部分间用冒号分割。<ul><li>jdbc：子协议：子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依照不同的子协议而变化，用子名称的目的是为了定位数据库提供足够多的信息。包含<strong>主机名</strong>（对应服务端的ip地址），端口号，数据库名</li></ul></li></ul><p>举例：<br><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135140020.png" alt="image-20230516135140020"> </p><h3 id="2-4-用户名和密码"><a href="#2-4-用户名和密码" class="headerlink" title="2.4 用户名和密码"></a>2.4 用户名和密码</h3><ul><li>user，password 可以用“属性名=属性值”方式告诉数据库</li><li>可以调用DriverManager类的getConnection()方法建立到数据库的连接</li></ul><h3 id="2-5-连接方式"><a href="#2-5-连接方式" class="headerlink" title="2.5 连接方式"></a>2.5 连接方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">    <span class="comment">//1.加载配置文件 </span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);       <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); </span><br><span class="line">    pros.load(is); </span><br><span class="line">    <span class="comment">//2.读取配置信息 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>); </span><br><span class="line">    <span class="comment">//3.加载驱动 </span></span><br><span class="line">    Class.forName(driverClass); </span><br><span class="line">    <span class="comment">//4.获取连接 </span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=root </span><br><span class="line">password=abc123 </span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test </span></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="3-使用PreparedStatement实现CRUD操作"><a href="#3-使用PreparedStatement实现CRUD操作" class="headerlink" title="3. 使用PreparedStatement实现CRUD操作"></a>3. 使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-Statement的弊端"><a href="#3-1-Statement的弊端" class="headerlink" title="3.1 Statement的弊端"></a>3.1 Statement的弊端</h3><ul><li>问题一：存在拼串操作、繁琐</li><li><p>问题二：存在SQL注入问题</p></li><li><p>SQL注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令（如：SELECT user，password FROM user_table WHERE user=’a’ OR 1 = ‘AND password = ‘ OR ‘1’ = ‘1’）利用系统的SQL引擎完成恶意行为的做法。</p></li><li>使用PreparedStatement取代Statement可以防范SQL注入</li></ul><h3 id="3-2-PreparedStatement的使用"><a href="#3-2-PreparedStatement的使用" class="headerlink" title="3.2 PreparedStatement的使用"></a>3.2 PreparedStatement的使用</h3><h4 id="3-2-1-PreparedStatement介绍"><a href="#3-2-1-PreparedStatement介绍" class="headerlink" title="3.2.1 PreparedStatement介绍"></a>3.2.1 PreparedStatement介绍</h4><ul><li>通过调用Connection对象的preparedStatement(String sql) 方法获取PreparedStatement对象</li></ul><h4 id="3-2-2-PreparedStatement的优势"><a href="#3-2-2-PreparedStatement的优势" class="headerlink" title="3.2.2 PreparedStatement的优势"></a>3.2.2 PreparedStatement的优势</h4><ul><li>代码的可读性和可维护性</li><li><p>PreparedStatement能最大可能提高性能：</p><ul><li>DBServer会对预编译语句提供性能优化</li><li>（语法检查，语义检查，翻译成二进制命令，缓存）</li></ul></li><li><p>PreparedStatement可以防止SQL注入</p></li></ul><h3 id="3-3-实现看代码"><a href="#3-3-实现看代码" class="headerlink" title="3.3 实现看代码"></a>3.3 实现看代码</h3><h3 id="3-4-资源的释放"><a href="#3-4-资源的释放" class="headerlink" title="3.4 资源的释放"></a>3.4 资源的释放</h3><ul><li>释放ResultSet，Statement，Connection</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放</li><li>可以在finally中关闭，保证即使其他代码出现异常，资源也一定能被关闭。</li></ul><h2 id="4-操作大型字段BLOB"><a href="#4-操作大型字段BLOB" class="headerlink" title="4. 操作大型字段BLOB"></a>4. 操作大型字段BLOB</h2><ul><li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li><li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接。</li><li>MySQL的四种BLOB类型（除了在存储的最大信息量上不同外，他们是等同的）</li></ul><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135217940.png" alt="image-20230516135217940" style="zoom: 67%;" /></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：max_allowed_packet = 16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h2 id="5-批量插入"><a href="#5-批量插入" class="headerlink" title="5. 批量插入"></a>5. 批量插入</h2><p>当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句;</li><li>clearBatch()：清空缓存的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */</span><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection(); </span><br><span class="line">    <span class="comment">//1.设置为不自动提交数据 </span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>; </span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123; </span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i); </span><br><span class="line">                                    </span><br><span class="line">        <span class="comment">//1.“攒”sql </span></span><br><span class="line">        ps.addBatch();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">//2.执行 </span></span><br><span class="line">            ps.executeBatch(); </span><br><span class="line">            <span class="comment">//3.清空 </span></span><br><span class="line">            ps.clearBatch(); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.提交数据 </span></span><br><span class="line">    conn.commit(); </span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis(); </span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">    JDBCUtils.closeResource(conn, ps); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-数据库事务"><a href="#6-数据库事务" class="headerlink" title="6. 数据库事务"></a>6. 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li>事务：一组逻辑操作单元，使数据从一种转台变换到另一种状态</li><li>事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被<strong>提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所做的所有修改，整个事务<strong>回滚(rollback)</strong>到最初状态。</li><li>为了保证数据库中的数据的一致性，数据的操作应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚</p></li><li><p>数据什么时候意味着提交？</p><ul><li>当一个连接对象被创建时，默认情况下时自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p>JDBC程序中为了让多个SQL语句作为一个事务执行：</p><ul><li>调用Connection对象的setAutoCommit(false);以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用commit()；方法提交事务</li><li>在出现异常时，调用rollback()；方法回滚事务</li></ul><blockquote><p>若此时Connection没有被关闭，还可能被重复使用，则需要恢复其自动提交状态setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a><strong>6.3</strong> 事务的ACID属性</h3><ol><li><strong>原子性（Atomicity）</strong> </li></ol><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><ol><li><strong>一致性（Consistency）</strong> </li></ol><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p><ol><li><strong>隔离性（Isolation）</strong> </li></ol><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ol><li><strong>持久性（Durability）</strong> </li></ol><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><p><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</p></li><li><p><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</p></li><li><p><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</p></li></ul><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高,数据一致性就越好,但并发性越弱。</strong></p><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135252180.png" alt="image-20230516135252180"></p><ul><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li><li><p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ</strong>。</p></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 <strong>在MySql中设置隔离级别</strong></h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation,表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation</span><br></pre></td></tr></table></figure></li><li><p>设置当前mySQL连接的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>设置数据库系统的全局的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 授予通过网络方式登陆的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privialeges on *.* to tom@&#x27;%&#x27; identified by &#x27;abc123&#x27;;</span><br><span class="line"># 给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="8-数据库连接池"><a href="#8-数据库连接池" class="headerlink" title="8. 数据库连接池"></a>8. 数据库连接池</h2><h3 id="8-1-数据库连接池的必要性"><a href="#8-1-数据库连接池的必要性" class="headerlink" title="8.1 数据库连接池的必要性"></a>8.1 数据库连接池的必要性</h3><ul><li>传统模式的缺陷<ul><li>需要数据库连接的时候，向数据库要求一个连接，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。</li><li>对于每一次数据库连接，使用完后都得断开。（思考：何为java的内存泄露？）</li><li>这种开发不能控制被创建的连接对象数。</li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li>为了解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</li><li><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕后再放回。</li><li>数据库连接池负责分配、管理和释放数据库连接，<strong>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong></li><li>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数zhanyou 阿是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</li><li><p>工作原理：<br><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/image-20230516135331428.png" alt="image-20230516135331428" style="zoom:67%;" /></p></li><li><p>数据库连接池技术的优点：</p><ol><li>资源重用<br>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</li><li>更快的系统反应速度<br>数据库连接池在初始化过程中，已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</li><li>新的资源分配手段<br>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</li><li>统一的连接管理，避免数据库连接泄露<br>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</li></ol></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC的数据库连接池使用 javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由服务器(Weblogic,WebSphere,Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong>是Apache提供的数据库连接池。tomcat服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong>是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。Hibernate官方推荐使用。</li><li><strong>Proxool</strong>是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li><strong>BoneCP</strong>是一个开源组织提供的数据库连接池，速度快。</li><li><strong>Druid</strong>是阿里提供的数据库连接池，据说集DBCP、C3P0、Proxool优点于一身的数据库连接池，但是速度不确定是否有BoneCP快。</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯是也经常把DataSource称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库的访问速度</strong>。</li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是数据库连接的工厂，因此 整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close()；但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123; </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection(); </span><br><span class="line">    <span class="keyword">return</span> conn; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span>  // 同时可以有5条sql语句在读取数据库</span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="8-3-2-Druid-德鲁伊-数据库连接池"><a href="#8-3-2-Druid-德鲁伊-数据库连接池" class="headerlink" title="8.3.2 Druid(德鲁伊)数据库连接池"></a>8.3.2 Druid(德鲁伊)数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection; </span><br><span class="line"><span class="keyword">import</span> java.util.Properties; </span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource; </span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>)); </span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro); </span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection(); </span><br><span class="line">    System.out.println(conn); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true </span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root </span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456 </span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10 // 初始化建立物理连接的个数。</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20 // 最大连接池的数量</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">1000 // 获取连接时最大等待时间</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall // 配置扩展插件，监控统计filters:start  日志filters:log4  防御sql注入filters:wall</span></span><br></pre></td></tr></table></figure><h2 id="9-Apache-DBUtils实现CRUD操作"><a href="#9-Apache-DBUtils实现CRUD操作" class="headerlink" title="9. Apache-DBUtils实现CRUD操作"></a>9. Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils-简介"><a href="#9-1-Apache-DBUtils-简介" class="headerlink" title="9.1 Apache-DBUtils 简介"></a>9.1 Apache-DBUtils 简介</h3><ul><li>commons-dbutils 是Apache组织提供的一个开源JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</li><li>API介绍：<ul><li>org.apache.commons.dbutils.QueryRunner  提供数据库操作的一系列重载的update()和query()操作</li><li>org.apache.commons.dbutils.ResultSetHandler  用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现</li><li>工具类：org.apache.commons.dbutils.DbUtils</li></ul></li></ul><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWithTx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接的操作（ </span></span><br><span class="line">        <span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">        <span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid </span></span><br><span class="line">        <span class="comment">//2.对数据表进行一系列CRUD操作 </span></span><br><span class="line">        <span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0) </span></span><br><span class="line">        <span class="comment">//version2.0的增删改 public void update(Connection conn,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125; </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类 </span></span><br><span class="line">        <span class="comment">//提交数据 conn.commit(); </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//回滚数据 conn.rollback(); </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123; </span><br><span class="line">            e1.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="comment">//3.关闭连接等操作 </span></span><br><span class="line">        <span class="comment">//① JDBCUtils.closeResource(); </span></span><br><span class="line">        <span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
