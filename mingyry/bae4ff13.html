<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | 明月依然的小站</title><meta name="author" content="Wenyu Yu"><meta name="copyright" content="Wenyu Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis为什么要使用Redis 一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：   读写性能优异 Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。   数据类型丰富 Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。   原子性 Redis的所有操作都是原子性的，同时R">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://mingyry.github.io/mingyry/bae4ff13.html">
<meta property="og:site_name" content="明月依然的小站">
<meta property="og:description" content="Redis为什么要使用Redis 一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：   读写性能优异 Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。   数据类型丰富 Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。   原子性 Redis的所有操作都是原子性的，同时R">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Redis-Logo.wine.png">
<meta property="article:published_time" content="2023-04-11T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-14T13:06:13.666Z">
<meta property="article:author" content="Wenyu Yu">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Redis-Logo.wine.png"><link rel="shortcut icon" href="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fwallhaven-85keej.png"><link rel="canonical" href="https://mingyry.github.io/mingyry/bae4ff13.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?00e91e237345a7bf551803ef3d797bde";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-14 21:06:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fluffy.png" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Ffriend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Redis-Logo.wine.png')"><nav id="nav"><span id="blog-info"><a href="/" title="明月依然的小站"><span class="site-name">明月依然的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2023-08-14T13:06:13.666Z" title="更新于 2023-08-14 21:06:13">2023-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h2><blockquote>
<p>一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：</p>
</blockquote>
<ul>
<li>读写性能优异<ul>
<li>Redis能读的速度是110000次/s,写的速度是81000次/s。</li>
</ul>
</li>
<li>数据类型丰富<ul>
<li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
</ul>
</li>
<li>原子性<ul>
<li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
</ul>
</li>
<li>丰富的特性<ul>
<li>Redis支持 publish/subscribe, 通知, key 过期等特性。</li>
</ul>
</li>
<li>持久化<ul>
<li>Redis支持RDB, AOF等持久化方式</li>
</ul>
</li>
<li>发布订阅<ul>
<li>Redis支持发布/订阅模式</li>
</ul>
</li>
<li>分布式<ul>
<li>Redis Cluster</li>
</ul>
</li>
</ul>
<h3 id="Redis和Memcached的比较"><a href="#Redis和Memcached的比较" class="headerlink" title="Redis和Memcached的比较"></a>Redis和Memcached的比较</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ol>
<li>都是基于内存的数据库。</li>
<li>都有过期策略</li>
<li>性能都较好</li>
</ol>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>不仅支持K/V，还支持多种数据类型（list，set，zset，hash等）</td>
<td>仅支持K/V数据类型</td>
</tr>
<tr>
<td>持久化</td>
<td>可以把内存中的数据持久化到磁盘中</td>
<td>仅在内存中</td>
</tr>
<tr>
<td>灾难恢复机制</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>数据转移</td>
<td>在内存使用完后，将不用的数据放到磁盘中</td>
<td>内存使用完毕，会报异常</td>
</tr>
<tr>
<td>集群模式</td>
<td>原生支持cluster模式</td>
<td>没有原生集群模式，需要客户端帮助</td>
</tr>
<tr>
<td>线程</td>
<td>单线程的IO多路复用（6.0后针对网络数据的读写引入了多线程）</td>
<td>多线程，非阻塞IO复用</td>
</tr>
<tr>
<td>额外功能</td>
<td>发布订阅模型、Lua 脚本、事务等功能</td>
<td>没有额外功能</td>
</tr>
<tr>
<td>删除策略</td>
<td>惰性删除和定期删除</td>
<td>惰性删除</td>
</tr>
</tbody>
</table>
</div>
<h3 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h3><h4 id="旁路缓存模式（Cache-Aside-Pattern）"><a href="#旁路缓存模式（Cache-Aside-Pattern）" class="headerlink" title="旁路缓存模式（Cache Aside Pattern）"></a>旁路缓存模式（Cache Aside Pattern）</h4><p>适合读请求较多的情况</p>
<p><strong>读：</strong></p>
<ul>
<li>从Cache中读取数，读取到直接返回</li>
<li>Cache中读取不到，从数据库中读取数据，直接返回</li>
<li>数据库再把数据放到Cache中</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/cache-aside-read.png" alt="img"></p>
<p><strong>写：</strong></p>
<ul>
<li>先写入数据库</li>
<li>再删除Cache中对应的缓存</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/cache-aside-write.png" alt="img"></p>
<p><strong>如果先删除缓存再更新数据库：</strong></p>
<p>会造成 <strong>数据库（DB）和缓存（Cache）数据不一致</strong></p>
<blockquote>
<p>请求A 先删除缓存， 然后在更新数据库，在A更新数据库的过程中</p>
<p>请求B 查询缓存，查询数据库，然后将缓存的值更新为旧值</p>
<p>这时A 更新好数据库，数据库值变为新值。出现了数据库和缓存不一致</p>
</blockquote>
<p>虽然先更新数据库再删除缓存也会出现不一致，但是缓存的操作比较快速，能够减少这种情况</p>
<h5 id="该模式的缺点："><a href="#该模式的缺点：" class="headerlink" title="该模式的缺点："></a>该模式的缺点：</h5><ul>
<li>首次请求的数据不在缓存中</li>
<li>写操作比较频繁的话，缓存中的数据会一直被删除</li>
</ul>
<h4 id="读写穿透模式（Read-Write-Through-Pattern）"><a href="#读写穿透模式（Read-Write-Through-Pattern）" class="headerlink" title="读写穿透模式（Read/Write Through Pattern）"></a>读写穿透模式（Read/Write Through Pattern）</h4><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
<p>但是日常开发过程中比较少见，因为Redis并没有将缓存写入到DB的功能</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/write-through.png" alt="img"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/read-through.png" alt="img"></p>
<h4 id="异步缓存写入模式（Write-Behind-Pattern）"><a href="#异步缓存写入模式（Write-Behind-Pattern）" class="headerlink" title="异步缓存写入模式（Write Behind Pattern）"></a>异步缓存写入模式（Write Behind Pattern）</h4><p><strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p>造成的问题就是如果机器宕机，那么未被更新到DB的所有内容都将丢失</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>String字符串</strong></td>
<td>可以是字符串、整数或浮点数</td>
<td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td><strong>List列表</strong></td>
<td>一个链表，链表上的每个节点都包含一个字符串</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td><strong>Set集合</strong></td>
<td>包含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td><strong>Hash散列</strong></td>
<td>包含键值对的无序散列表</td>
<td>包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td><strong>Zset有序集合</strong></td>
<td>和散列一样，用于存储键值对</td>
<td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基础数据结构详解"><a href="#基础数据结构详解" class="headerlink" title="基础数据结构详解"></a>基础数据结构详解</h3><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><blockquote>
<p>String是redis中最基本的数据类型，一个key对应一个value。</p>
</blockquote>
<p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p>
<ul>
<li><strong>图例</strong></li>
</ul>
<p>下图是一个String类型的实例，其中键为hello，值为world</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-3.png" alt="img"></p>
<ul>
<li><strong>命令使用</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取存储在给定键中的值</td>
<td>GET name</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
<td>SET name value</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值</td>
<td>DEL name</td>
</tr>
<tr>
<td>INCR</td>
<td>将键存储的值加1</td>
<td>INCR key</td>
</tr>
<tr>
<td>DECR</td>
<td>将键存储的值减1</td>
<td>DECR key</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将键存储的值加上整数</td>
<td>INCRBY key amount</td>
</tr>
<tr>
<td>DECRBY</td>
<td>将键存储的值减去整数</td>
<td>DECRBY key amount</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>命令执行</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr counter</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100</span><br><span class="line">(<span class="built_in">integer</span>) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr counter</span><br><span class="line">(<span class="built_in">integer</span>) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line"><span class="string">&quot;102&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景</p>
<ul>
<li><strong>缓存</strong>： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li><p><strong>计数器</strong>：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p>
<p>用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数</p>
</li>
<li><strong>session</strong>：常见方案spring session + redis实现session共享</li>
<li><strong>分布式锁</strong>：利用SETNX 实现简易的分布式锁</li>
</ul>
</li>
</ul>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><blockquote>
<p>Redis中的List其实就是链表（Redis用双端链表实现List）。</p>
</blockquote>
<p>使用List结构，我们可以轻松地实现最新消息排队功能（比如新浪微博的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。</p>
<ul>
<li><p><strong>图例</strong></p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-5.png" alt="img" style="zoom:67%;" /></p>
</li>
<li><p><strong>命令使用</strong></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td>将给定值推入到列表右端</td>
<td>RPUSH key value</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将给定值推入到列表左端</td>
<td>LPUSH key value</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的右端弹出一个值，并返回被弹出的值</td>
<td>RPOP key</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的左端弹出一个值，并返回被弹出的值</td>
<td>LPOP key</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
<td>LRANGE key 0 -1</td>
</tr>
<tr>
<td>LINDEX</td>
<td>通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</td>
<td>LINDEX key index</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用列表的技巧<ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
</ul>
</li>
<li><strong>命令执行</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist -1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 10        <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>实战场景<ul>
<li><strong>微博TimeLine</strong>: 有人发布微博，用lpush加入时间轴，展示新的列表信息。</li>
<li><strong>消息队列</strong>：不咋好用，Redis5.0提出Stream作为消息队列，但是没有专业的消息队列好用</li>
</ul>
</li>
</ul>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><blockquote>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
</blockquote>
<p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<ul>
<li><strong>图例</strong></li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-7.png" alt="img"></p>
<ul>
<li><strong>命令使用</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>向集合添加一个或多个成员</td>
<td>SADD key value</td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的成员数</td>
<td>SCARD key</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合中的所有成员</td>
<td>SMEMBERS key member</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>判断 member 元素是否是集合 key 的成员</td>
<td>SISMEMBER key member</td>
</tr>
</tbody>
</table>
</div>
<p>其它一些集合操作，请参考这里<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-sets.html">https://www.runoob.com/redis/redis-sets.html</a></p>
<ul>
<li><strong>命令执行</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景</p>
<ul>
<li><p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li><p><strong>点赞，或点踩，收藏等</strong>，可以放到set中实现</p>
<p><code>SCARD</code>（获取集合数量），来存放对应的评论或者视频的点赞的用户的id</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li><p>共同好友（交集），好友推荐（差集），共同关注（交集）等</p>
<p><code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</p>
</li>
</ul>
</li>
<li><p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li><p>抽奖系统、随机点名</p>
<p><code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景），<code>`SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）</p>
</li>
</ul>
</li>
</ul>
<h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><blockquote>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
</blockquote>
<ul>
<li><strong>图例</strong></li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-4.png" alt="img"></p>
<ul>
<li><strong>命令使用</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>添加键值对</td>
<td>HSET hash-key sub-key1 value1</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
<td>HGET hash-key key1</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列中包含的所有键值对</td>
<td>HGETALL hash-key</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列中，那么就移除这个键</td>
<td>HDEL hash-key sub-key1</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>命令执行</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget user user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user name1</span><br><span class="line"><span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset user name2 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email2 xiaohao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br><span class="line">5) <span class="string">&quot;name2&quot;</span></span><br><span class="line">6) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">7) <span class="string">&quot;email2&quot;</span></span><br><span class="line">8) <span class="string">&quot;xiaohao@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景</p>
<ul>
<li><p><strong>缓存</strong>： 能直观，相比string更节省空间，维护缓存信息，如用户信息，视频信息，购物车信息等。</p>
<p><code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）</p>
</li>
</ul>
</li>
</ul>
<h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><blockquote>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
</blockquote>
<p>有序集合的成员是唯一的, 但分数(score)却可以重复。有序集合是通过两种数据结构实现：</p>
<ol>
<li><strong>压缩列表(ziplist)</strong>: ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li><strong>跳跃表（zSkiplist)</strong>: 跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这是采用跳跃表的主要原因。跳跃表的复杂度是O(log(n))。</li>
</ol>
<ul>
<li><strong>图例</strong></li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-8.png" alt="img" style="zoom:67%;" /></p>
<ul>
<li><strong>命令使用</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>将一个带有给定分值的成员添加到有序集合里面</td>
<td>ZADD zset-key 178 member1</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td>
<td>ZRANGE zset-key 0-1 withccores</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定元素成员存在于有序集合中，那么就移除这个元素</td>
<td>ZREM zset-key member1</td>
</tr>
</tbody>
</table>
</div>
<p>更多命令请参考这里 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-sorted-sets.html">https://www.runoob.com/redis/redis-sorted-sets.html</a></p>
<ul>
<li><strong>命令执行</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景</p>
<ul>
<li><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul>
<li><p>各种排行榜</p>
<p><code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<p>Redis中只保存排行榜需要展示的数据，具体的数据还是要去对应的数据库中查询</p>
<p>zSet可以对多个zSet进行组合排序，来求一些多时间或者多角色的排序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3种特殊类型"><a href="#3种特殊类型" class="headerlink" title="3种特殊类型"></a>3种特殊类型</h2><h3 id="HyperLogLogs（基数统计）"><a href="#HyperLogLogs（基数统计）" class="headerlink" title="HyperLogLogs（基数统计）"></a>HyperLogLogs（基数统计）</h3><blockquote>
<p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构！</p>
</blockquote>
<ul>
<li><strong>什么是基数？</strong></li>
</ul>
<p>举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）</p>
<ul>
<li><strong>HyperLogLogs 基数统计用来解决什么问题</strong>？</li>
</ul>
<p>这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。</p>
<ul>
<li><strong>它的优势体现在哪</strong>？</li>
</ul>
<p>一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。</p>
<ul>
<li><strong>相关命令使用</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd key1 a b c d e f g h i	<span class="comment"># 创建第一组元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key1					<span class="comment"># 统计元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; pfadd key2 c j k l m e g a		<span class="comment"># 创建第二组元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key2</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; pfmerge key3 key1 key2			<span class="comment"># 合并两组：key1 key2 -&gt; key3 并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount key3</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景：</p>
<ul>
<li><p>基于Redis统计UV（独立访客），统计一天内访问某站点的用户数</p>
<ul>
<li><p><code>PV(页面浏览量)</code>数据不去重，<code>UV</code>数据需要去重</p>
</li>
<li><p>先将访问页面的每个用户id添加到<code>HyperLogLogs</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计指定页面的UV</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Bitmap-（位存储）"><a href="#Bitmap-（位存储）" class="headerlink" title="Bitmap （位存储）"></a>Bitmap （位存储）</h3><blockquote>
<p>Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。</p>
</blockquote>
<ul>
<li><strong>用来解决什么问题</strong>？</li>
</ul>
<p>比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ <strong>两个状态的，都可以使用 Bitmaps</strong>！</p>
<p>如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！</p>
<ul>
<li><strong>相关命令使用</strong></li>
</ul>
<p>使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ……</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<p>查看某一天是否有打卡！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<p>统计操作，统计打卡的天数！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>实战场景：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011957758/article/details/74783347">https://blog.csdn.net/u011957758/article/details/74783347</a></p>
</li>
</ul>
<h3 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial (地理位置)"></a>geospatial (地理位置)</h3><blockquote>
<p>Redis 的 Geo 在 Redis 3.2 版本就推出了! 这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人</p>
</blockquote>
<h4 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h4><blockquote>
<p>添加地理位置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<p><strong>规则</strong></p>
<p>两级无法直接添加，我们一般会下载城市数据(这个网址可以查询 GEO： <a target="_blank" rel="noopener" href="http://www.jsons.cn/lngcode)！">http://www.jsons.cn/lngcode)！</a></p>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span><br><span class="line">(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span><br></pre></td></tr></table></figure>
<h4 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h4><blockquote>
<p>获取指定的成员的经度和纬度</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city taiyuan manjing</span><br><span class="line">1) 1) <span class="string">&quot;112.54999905824661255&quot;</span></span><br><span class="line">   1) <span class="string">&quot;37.86000073876942196&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;118.75999957323074341&quot;</span></span><br><span class="line">   1) <span class="string">&quot;32.03999960287850968&quot;</span></span><br></pre></td></tr></table></figure>
<p>获得当前定位, 一定是一个坐标值!</p>
<h4 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h4><blockquote>
<p>如果不存在, 返回空</p>
</blockquote>
<p>单位如下</p>
<ul>
<li>m</li>
<li>km</li>
<li>mi 英里</li>
<li>ft 英尺</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city taiyuan shenyang m</span><br><span class="line"><span class="string">&quot;1026439.1070&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city taiyuan shenyang km</span><br><span class="line"><span class="string">&quot;1026.4391&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h4><blockquote>
<p>附近的人 ==&gt; 获得所有附近的人的地址, 定位, 通过半径来查询</p>
</blockquote>
<p>获得指定数量的人</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km			以 100,30 这个坐标为中心, 寻找半径为1000km的城市</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">4) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist</span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;864.9816&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;118.75999957323074341&quot;</span></span><br><span class="line">      2) <span class="string">&quot;32.03999960287850968&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数 key 经度 纬度 半径 单位 [显示结果的经度和纬度] [显示结果的距离] [显示的结果的数量]</p>
<h4 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h4><blockquote>
<p>显示与指定成员一定半径范围内的其他成员</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city taiyuan 1000 km</span><br><span class="line">1) <span class="string">&quot;manjing&quot;</span></span><br><span class="line">2) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">3) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city taiyuan 1000 km withcoord withdist count 2</span><br><span class="line">1) 1) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;112.54999905824661255&quot;</span></span><br><span class="line">      2) <span class="string">&quot;37.86000073876942196&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;514.2264&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数与 georadius 一样</p>
<h4 id="geohash-较少使用"><a href="#geohash-较少使用" class="headerlink" title="geohash(较少使用)"></a>geohash(较少使用)</h4><blockquote>
<p>该命令返回11个字符的hash字符串</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash china:city taiyuan shenyang</span><br><span class="line">1) <span class="string">&quot;ww8p3hhqmp0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wxrvb9qyxk0&quot;</span></span><br></pre></td></tr></table></figure>
<p>将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近</p>
<h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><blockquote>
<p>geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> china:city</span><br><span class="line">zset</span><br></pre></td></tr></table></figure>
<p>查看全部元素 删除指定的元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 withscores</span><br><span class="line"> 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;4040115445396757&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;4054133997236782&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;manjing&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;4066006694128997&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;4068216047500484&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;shenyang&quot;</span></span><br><span class="line">1)  <span class="string">&quot;4072519231994779&quot;</span></span><br><span class="line">2)  <span class="string">&quot;shengzhen&quot;</span></span><br><span class="line">3)  <span class="string">&quot;4154606886655324&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city manjing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;taiyuan&quot;</span></span><br><span class="line">4) <span class="string">&quot;shenyang&quot;</span></span><br><span class="line">5) <span class="string">&quot;shengzhen&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Stream数据类型"><a href="#Stream数据类型" class="headerlink" title="Stream数据类型"></a>Stream数据类型</h3><p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p>
<p>美团技术团队的一篇文章，<a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/07/01/mq-design.html">消息队列设计精要</a> 中的图</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-1.png" alt="img"></p>
<p><strong>Redis考虑的设计</strong></p>
<ul>
<li>消息ID的序列化生成</li>
<li>消息遍历</li>
<li>消息的阻塞和非阻塞读取</li>
<li>消息的分组消费</li>
<li>未完成消息的处理</li>
<li>消息队列监控</li>
<li>…</li>
</ul>
<p>Redis Stream 是一种超轻量MQ，并没有完全实现消息队列所有设计要点</p>
<h4 id="Stream详解"><a href="#Stream详解" class="headerlink" title="Stream详解"></a>Stream详解</h4><ul>
<li>Stream的结构设计</li>
<li>生产和消费<ul>
<li>基本的增删查改</li>
<li>单一消费者的消费</li>
<li>消费组的消费</li>
</ul>
</li>
<li>监控状态</li>
</ul>
<h4 id="Stream的结构"><a href="#Stream的结构" class="headerlink" title="Stream的结构"></a>Stream的结构</h4><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-2.png" alt="img"></p>
<p>上图解析：</p>
<ul>
<li><code>Consumer Group</code> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。</li>
<li><code>last_delivered_id</code> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li>
<li><code>pending_ids</code> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 <code>ack</code> (Acknowledge character：确认字符）。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</li>
</ul>
<p>此外我们还需要理解两点：</p>
<ul>
<li><code>消息ID</code>: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。</li>
<li><code>消息内容</code>: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。</li>
</ul>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>消息队列相关命令：</p>
<ul>
<li>XADD - 添加消息到末尾</li>
<li>XTRIM - 对流进行修剪，限制长度</li>
<li>XDEL - 删除消息</li>
<li>XLEN - 获取流包含的元素数量，即消息长度</li>
<li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li>
<li>XREVRANGE - 反向获取消息列表，ID 从大到小</li>
<li>XREAD - 以阻塞或非阻塞方式获取消息列表</li>
</ul>
<h4 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h4><p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从Stream头部读取两条消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 2 streams codehole 0-0</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851486781-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;30&quot;</span></span><br><span class="line">      2) 1) 1527851493405-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;yurui&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;29&quot;</span></span><br><span class="line"><span class="comment"># 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息</span></span><br><span class="line">127.0.0.1:6379&gt; xread count 1 streams codehole $</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $</span><br><span class="line"><span class="comment"># 我们从新打开一个窗口，在这个窗口往Stream里塞消息</span></span><br><span class="line">127.0.0.1:6379&gt; xadd codehole * name youming age 60</span><br><span class="line">1527852774092-0</span><br><span class="line"><span class="comment"># 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容</span></span><br><span class="line"><span class="comment"># 而且还显示了一个等待时间，这里我们等待了93s</span></span><br><span class="line">127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527852774092-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;youming&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;60&quot;</span></span><br><span class="line">(93.11s)</span><br></pre></td></tr></table></figure>
<p>客户端如果想要使用xread进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用xread时，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。</p>
<p>block 0表示永远阻塞，直到消息到来，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread block 1000 count 1 streams codehole $</span><br><span class="line">(nil)</span><br><span class="line">(1.07s)</span><br></pre></td></tr></table></figure>
<h4 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h4><ul>
<li><strong>消费组消费图</strong></li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-3.png" alt="img"></p>
<p>相关命令：</p>
<ul>
<li>XGROUP CREATE - 创建消费者组</li>
<li>XREADGROUP GROUP - 读取消费者组中的消息</li>
<li>XACK - 将消息标记为”已处理”</li>
<li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li>
<li>XGROUP DELCONSUMER - 删除消费者</li>
<li>XGROUP DESTROY - 删除消费者组</li>
<li>XPENDING - 显示待处理消息的相关信息</li>
<li>XCLAIM - 转移消息的归属权</li>
<li>XINFO - 查看流和消费者组的相关信息；</li>
<li>XINFO GROUPS - 打印消费者组的信息；</li>
<li>XINFO STREAM - 打印流信息</li>
</ul>
<p><strong>创建消费组</strong></p>
<p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create codehole cg1 0-0  <span class="comment">#  表示从头开始消费</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># $表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略</span></span><br><span class="line">127.0.0.1:6379&gt; xgroup create codehole cg2 $</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; xinfo stream codehole  <span class="comment"># 获取Stream信息</span></span><br><span class="line"> 1) length</span><br><span class="line"> 2) (<span class="built_in">integer</span>) 3  <span class="comment"># 共3个消息</span></span><br><span class="line"> 3) radix-tree-keys</span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 5) radix-tree-nodes</span><br><span class="line"> 6) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 7) <span class="built_in">groups</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 2  <span class="comment"># 两个消费组</span></span><br><span class="line"> 9) first-entry  <span class="comment"># 第一个消息</span></span><br><span class="line">10) 1) 1527851486781-0</span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;30&quot;</span></span><br><span class="line">11) last-entry  <span class="comment"># 最后一个消息</span></span><br><span class="line">12) 1) 1527851498956-0</span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;xiaoqian&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xinfo <span class="built_in">groups</span> codehole  <span class="comment"># 获取Stream的消费组信息</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg1&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组还没有消费者</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组没有正在处理的消息</span></span><br><span class="line">2) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg2&quot;</span></span><br><span class="line">   3) consumers  <span class="comment"># 该消费组还没有消费者</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 0</span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0  <span class="comment"># 该消费组没有正在处理的消息</span></span><br></pre></td></tr></table></figure>
<p><strong>消费组消费</strong></p>
<p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;号表示从当前消费组的last_delivered_id后面开始读</span></span><br><span class="line"><span class="comment"># 每当消费者读取一条消息，last_delivered_id变量就会前进</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851486781-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;laoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;30&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851493405-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;yurui&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;29&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 2 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527851498956-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;xiaoqian&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;1&quot;</span></span><br><span class="line">      2) 1) 1527852774092-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;youming&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;60&quot;</span></span><br><span class="line"><span class="comment"># 再继续读取，就没有新消息了</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 那就阻塞等待吧</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole &gt;</span><br><span class="line"><span class="comment"># 开启另一个窗口，往里塞消息</span></span><br><span class="line">127.0.0.1:6379&gt; xadd codehole * name lanying age 61</span><br><span class="line">1527854062442-0</span><br><span class="line"><span class="comment"># 回到前一个窗口，发现阻塞解除，收到新消息了</span></span><br><span class="line">127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole &gt;</span><br><span class="line">1) 1) <span class="string">&quot;codehole&quot;</span></span><br><span class="line">   2) 1) 1) 1527854062442-0</span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;lanying&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;61&quot;</span></span><br><span class="line">(36.54s)</span><br><span class="line">127.0.0.1:6379&gt; xinfo <span class="built_in">groups</span> codehole  <span class="comment"># 观察消费组信息</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg1&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1  <span class="comment"># 一个消费者</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 5  <span class="comment"># 共5条正在处理的信息还有没有ack</span></span><br><span class="line">2) 1) name</span><br><span class="line">   2) <span class="string">&quot;cg2&quot;</span></span><br><span class="line">   3) consumers</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># 消费组cg2没有任何变化，因为前面我们一直在操纵cg1</span></span><br><span class="line">   5) pending</span><br><span class="line">   6) (<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 如果同一个消费组有多个消费者，我们可以通过xinfo consumers指令观察每个消费者的状态</span></span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1  <span class="comment"># 目前还有1个消费者</span></span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 5  <span class="comment"># 共5条待处理消息</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 418715  <span class="comment"># 空闲了多长时间ms没有读取消息了</span></span><br><span class="line"><span class="comment"># 接下来我们ack一条消息</span></span><br><span class="line">127.0.0.1:6379&gt; xack codehole cg1 1527851486781-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1</span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 4  <span class="comment"># 变成了5条</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 668504</span><br><span class="line"><span class="comment"># 下面ack所有消息</span></span><br><span class="line">127.0.0.1:6379&gt; xack codehole cg1 1527851493405-0 1527851498956-0 1527852774092-0 1527854062442-0</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; xinfo consumers codehole cg1</span><br><span class="line">1) 1) name</span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) pending</span><br><span class="line">   4) (<span class="built_in">integer</span>) 0  <span class="comment"># pel空了</span></span><br><span class="line">   5) idle</span><br><span class="line">   6) (<span class="built_in">integer</span>) 745505</span><br></pre></td></tr></table></figure>
<h4 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h4><p>Stream提供了XINFO来实现对服务器信息的监控，可以查询：</p>
<h4 id="Stream深入理解"><a href="#Stream深入理解" class="headerlink" title="Stream深入理解"></a>Stream深入理解</h4><h5 id="Stream用在什么样场景"><a href="#Stream用在什么样场景" class="headerlink" title="Stream用在什么样场景"></a>Stream用在什么样场景</h5><p>可用作时通信等，大数据分析，异地数据备份等</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-4.png" alt="img"></p>
<p>客户端可以平滑扩展，提高处理能力</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-stream-5.png" alt="img"></p>
<h5 id="消息ID的设计"><a href="#消息ID的设计" class="headerlink" title="消息ID的设计"></a>消息ID的设计</h5><p>由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个64位整型（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p>
<p>可以通过multi批处理，来验证序号的递增：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg one</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg two</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg three</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg four</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; XADD memberMessage * msg five</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) <span class="string">&quot;1553441006884-0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1553441006884-1&quot;</span></span><br><span class="line">3) <span class="string">&quot;1553441006884-2&quot;</span></span><br><span class="line">4) <span class="string">&quot;1553441006884-3&quot;</span></span><br><span class="line">5) <span class="string">&quot;1553441006884-4&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于一个redis命令的执行很快，所以可以看到在同一时间戳内，是通过序号递增来表示消息的。</p>
<p>为了保证消息是有序的，因此Redis生成的ID是单调递增有序的。由于ID中包含时间戳部分，为了避免服务器时间错误而带来的问题（例如服务器时间延后了），Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号），从而保证ID的单调递增性质。</p>
<p><strong>强烈建议使用Redis的方案生成消息ID，因为这种时间戳+序号的单调递增的ID方案，几乎可以满足你全部的需求。但同时，记住ID是支持自定义的，别忘了！</strong></p>
<h5 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h5><p>每个Pending的消息有4个属性：</p>
<ul>
<li>消息ID</li>
<li>所属消费者</li>
<li>IDLE，已读取时长</li>
<li>delivery counter，消息被读取次数</li>
</ul>
<p>消费者处理完毕了消息需要使用命令 XACK 完成告知消息处理完成</p>
<p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。等待消费者再次上线后，可以读取该Pending列表，就可以继续处理该消息了，保证消息的有序和不丢失。</p>
<h5 id="消费者彻底宕机后如何转移给其它消费者处理"><a href="#消费者彻底宕机后如何转移给其它消费者处理" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理"></a>消费者彻底宕机后如何转移给其它消费者处理</h5><p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法<strong>XCLAIM</strong>来实现，需要<strong>设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p>
<h5 id="Dead-Letter，死信问题"><a href="#Dead-Letter，死信问题" class="headerlink" title="Dead Letter，死信问题"></a>Dead Letter，死信问题</h5><p>如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的delivery counter就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用XDEL语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除队列中的消息</span></span><br><span class="line">127.0.0.1:6379&gt; XDEL mq 1553585533795-1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查看队列中再无此消息</span></span><br><span class="line">127.0.0.1:6379&gt; XRANGE mq - +</span><br><span class="line">1) 1) <span class="string">&quot;1553585533795-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;msg&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;1553585533795-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;msg&quot;</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意本例中，并没有删除Pending中的消息因此你查看Pending，消息还会在。可以执行XACK标识其处理完毕！</p>
</blockquote>
<h2 id="Redis底层结构"><a href="#Redis底层结构" class="headerlink" title="Redis底层结构"></a>Redis底层结构</h2><p>redis底层设计：</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-2-2.png" alt="img"></p>
<ul>
<li><strong>对象设计机制</strong>: 对象结构(redisObject)</li>
<li><strong>编码类型和底层数据结构</strong>: 对应编码的数据结构</li>
</ul>
<h3 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h3><h4 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h4><p>redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>下图对应上面的结构</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-1.png" alt="img"></p>
<p><strong>其中type、encoding和ptr是最重要的三个属性</strong>。</p>
<ul>
<li><strong>type记录了对象所保存的值的类型</strong>，它的值可能是以下常量中的一个：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1 <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2 <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3 <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4 <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>encoding记录了对象所保存的值的编码</strong>，它的值可能是以下常量中的一个：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* 注意：版本2.6后不再使用. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* 注意：不再使用了，旧版本2.x中String的底层之一. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ptr是一个指针，指向实际保存值的数据结构</strong>，这个数据结构由type和encoding属性决定。举个例子， 如果一个redisObject 的type 属性为<code>OBJ_LIST</code> ， encoding 属性为<code>OBJ_ENCODING_QUICKLIST</code> ，那么这个对象就是一个Redis 列表（List)，它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象</li>
</ul>
<p><strong>lru属性: 记录了对象最后一次被命令程序访问的时间</strong></p>
<p><strong>空转时长</strong>：当前时间减去键的值对象的lru时间，就是该键的空转时长。Object idletime命令可以打印出给定键的空转时长</p>
<p>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<h4 id="命令的类型检查和多态"><a href="#命令的类型检查和多态" class="headerlink" title="命令的类型检查和多态"></a>命令的类型检查和多态</h4><blockquote>
<p>那么Redis是如何处理一条命令的呢？</p>
</blockquote>
<p><strong>当执行一个处理数据类型命令的时候，redis执行以下步骤</strong></p>
<ul>
<li>根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；</li>
<li>检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；</li>
<li>根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；</li>
<li>返回数据结构的操作结果作为命令的返回值。</li>
</ul>
<p>比如现在执行LPOP命令：</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-3.png" alt="img"></p>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><blockquote>
<p>redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。</p>
</blockquote>
<p><strong>redis预分配的值对象如下</strong>：</p>
<ul>
<li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li>
<li>包括0 在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-4.png" alt="img"></p>
<blockquote>
<p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等自勉之的内存数据结构</p>
</blockquote>
<p><strong>为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象</strong>？</p>
<ul>
<li>列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。</li>
<li>如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)</li>
<li>如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)</li>
<li>如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)</li>
</ul>
<p>如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的</p>
<h4 id="引用计数以及对象的消毁"><a href="#引用计数以及对象的消毁" class="headerlink" title="引用计数以及对象的消毁"></a>引用计数以及对象的消毁</h4><blockquote>
<p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p>
</blockquote>
<ul>
<li>每个redisObject结构都带有一个refcount属性，指示这个对象被引用了多少次；</li>
<li>当新创建一个对象时，它的refcount属性被设置为1；</li>
<li>当对一个对象进行共享时，redis将这个对象的refcount加一；</li>
<li>当使用完一个对象后，或者消除对一个对象的引用之后，程序将对象的refcount减一；</li>
<li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li>
</ul>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-object-2-3.png" alt="img"></p>
<p>底层数据结构部分：</p>
<ul>
<li>简单动态字符串 - sds</li>
<li>压缩列表 - ZipList</li>
<li>快表 - QuickList</li>
<li>字典/哈希表 - Dict</li>
<li>整数集 - IntSet</li>
<li>跳表 - ZSkipList</li>
</ul>
<h4 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h4><p>Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 <strong>简单动态字符串（simple dynamic string,SDS</strong>）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p>
<ul>
<li><strong>SDS的总体概览</strong>如下图:</li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-3.png" alt="img"></p>
<p>其中<code>sdshdr</code>是头部, <code>buf</code>是真实存储用户数据的地方. 另外注意, 从命名上能看出来, 这个数据结构除了能存储二进制数据, 显然是用于设计作为字符串使用的, 所以在buf中, 用户数据后总跟着一个\0. 即图中 <code>&quot;数据&quot; + &quot;\0&quot;</code>是为所谓的buf。</p>
<p>通过上图我们可以看到，SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的头部, 分别如下:</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-2.png" alt="img"></p>
<p>其中：</p>
<ul>
<li><code>len</code> 保存了SDS保存字符串的长度</li>
<li><code>buf[]</code> 数组用来保存字符串的每个元素</li>
<li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的\0, 剩余的字节数.</li>
<li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用.</li>
</ul>
<h5 id="为什么使用SDS"><a href="#为什么使用SDS" class="headerlink" title="为什么使用SDS"></a>为什么使用SDS</h5><blockquote>
<p><strong>为什么不使用C语言字符串实现，而是使用 SDS呢</strong>？这样实现有什么好处？</p>
</blockquote>
<ul>
<li><strong>常数复杂度获取字符串长度</strong></li>
</ul>
<p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p>
<ul>
<li><strong>杜绝缓冲区溢出</strong></li>
</ul>
<p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p>
<ul>
<li><strong>减少修改字符串的内存重新分配次数</strong></li>
</ul>
<p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p>
<p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p>
<p>1、<code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>2、<code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p>
<ul>
<li><strong>二进制安全</strong></li>
</ul>
<p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p>
<ul>
<li><strong>兼容部分 C 字符串函数</strong></li>
</ul>
<p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h&gt;</code> 中的一部分函数。</p>
<h4 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h4><p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p>
<p>整个ziplist在内存中的存储格式如下：</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-6.png" alt="img"></p>
<ul>
<li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li>
<li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li>
<li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li>
<li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li>
</ul>
<h5 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h5><p>一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code></p>
<p><code>prevlen</code>：前一个entry的大小；</p>
<p><code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；</p>
<p><code>entry-data</code>：真是用于存储entry表示的数据；</p>
<h5 id="为什么ZipList特别省内存"><a href="#为什么ZipList特别省内存" class="headerlink" title="为什么ZipList特别省内存"></a>为什么ZipList特别省内存</h5><blockquote>
<p>所以只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p>
</blockquote>
<ul>
<li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li>
<li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，<strong>所以增加encoding字段</strong>，针对不同的encoding来细化存储大小；</li>
<li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li>
</ul>
<p><strong>为什么我们去研究ziplist特别节省内存的数据结构</strong>？ 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p>
<h5 id="ziplist的缺点"><a href="#ziplist的缺点" class="headerlink" title="ziplist的缺点"></a>ziplist的缺点</h5><p>最后我们再看看它的一些缺点：</p>
<ul>
<li>ziplist也不预留内存空间, 并且在移除结点后, 也是立即缩容, 这代表每次写操作都会进行内存分配操作.</li>
<li>结点如果扩容, 导致结点占用的内存增长, 并且超过254字节的话, 可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节. <strong>最坏情况下, 第一个结点的扩容, 会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容</strong>. 虽然这个内存重分配的操作依然只会发生一次, 但代码中的时间复杂度是o(N)级别, 因为链式扩容只能一步一步的计算. 但这种情况的概率十分的小, 一般情况下链式扩容能连锁反映五六次就很不幸了. 之所以说这是一个蛋疼问题, 是因为, 这样的坏场景下, 其实时间复杂度并不高: 依次计算每个entry新的空间占用, 也就是o(N), 总体占用计算出来后, 只执行一次内存重分配, 与对应的memmove操作, 就可以了.</li>
</ul>
<h4 id="快表-QuickList"><a href="#快表-QuickList" class="headerlink" title="快表 - QuickList"></a>快表 - QuickList</h4><p>它是一种以ziplist为结点的双端链表结构. 宏观上, quicklist是一个链表, 微观上, 链表中的每个结点都是一个ziplist。</p>
<h5 id="quicklist内存布局图"><a href="#quicklist内存布局图" class="headerlink" title="quicklist内存布局图"></a>quicklist内存布局图</h5><p>quicklist的内存布局图如下所示:</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-4.png" alt="img"></p>
<p>quicklist有自己的优点， 也有缺点， 对于使用者来说, 其使用体验类似于线性数据结构， list作为最传统的双链表, 结点通过指针持有数据， 指针字段会耗费大量内存。 ziplist解决了耗费内存这个问题， 但引入了新的问题： 每次写操作整个ziplist的内存都需要重分配。 quicklist在两者之间做了一个平衡， 并且使用者可以通过自定义<code>quicklist.fill</code>, 根据实际业务情况, 经验主义调参。</p>
<h4 id="字典-哈希表-Dict"><a href="#字典-哈希表-Dict" class="headerlink" title="字典/哈希表 - Dict"></a>字典/哈希表 - Dict</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><strong>哈希表结构定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于 size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br></pre></td></tr></table></figure>
<p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="type">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">          <span class="type">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure>
<p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p>
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-13.png" alt="img"></p>
<h5 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h5><ul>
<li><strong>哈希算法</strong>：Redis计算哈希值和索引值方法如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line"><span class="built_in">hash</span> = dict-&gt;<span class="built_in">type</span>-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span></span><br><span class="line">index = <span class="built_in">hash</span> &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解决哈希冲突</strong>：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。</li>
<li><strong>扩容和收缩</strong>：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：</li>
</ul>
<p>1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。</p>
<p>2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。</p>
<p>3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</p>
<ul>
<li><strong>触发扩容的条件</strong>：</li>
</ul>
<p>1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</p>
<p>2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</p>
<p>ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</p>
<ul>
<li><strong>渐近式 rehash</strong></li>
</ul>
<p>什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</p>
<h4 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h4><p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</p>
<h5 id="intset结构"><a href="#intset结构" class="headerlink" title="intset结构"></a>intset结构</h5><p>首先看源码结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p>
<p><code>length</code> 代表其中存储的整数的个数</p>
<p><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p>
<h5 id="内存布局图"><a href="#内存布局图" class="headerlink" title="内存布局图"></a>内存布局图</h5><p>其内存布局如下图所示</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-8.png" alt="img"></p>
<p>我们可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p>
<h4 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h4><p>作为有序列表 (Zset) 的使用。</p>
<p>跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p>
<p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-9.png" alt="img"></p>
<p>如果我们增加如下两级索引，那么它搜索次数就变成了3次</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/db-redis-ds-x-10.png" alt="img"></p>
<ul>
<li><strong>skiplist与平衡树、哈希表的比较</strong></li>
</ul>
<p>来源于：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8ac45fd01548">https://www.jianshu.com/p/8ac45fd01548</a></p>
<p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p>
<p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p>
<p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>
<p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
<p>查找单个key，skiplist和平衡树的时间复杂度都为<strong>O(log n)</strong>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p>
<p>跳表的删除和添加的时间复杂度都为O(log n)</p>
<p>从算法实现难度上来比较，skiplist比平衡树要简单得多</p>
<h2 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h2><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<p>Redis 的 <code>EXPIRE</code> 命令可以指定一个键的过期时间，当达到过期时间后，Redis 会自动删除该键。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PERSIST</code></td>
<td><code>PERSIST key-name</code>—移除键的过期时间</td>
</tr>
<tr>
<td><code>TTL</code></td>
<td><code>TTL key-name</code>—查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td><code>EXPIRE</code></td>
<td><code>EXPIRE key-name seconds</code>—让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td><code>EXPIREAT</code></td>
<td><code>EXPIREAT key-name timestamp</code>—将给定键的过期时间设置为给定的 UNIX 时间戳</td>
</tr>
<tr>
<td><code>PTTL</code></td>
<td><code>PTTL key-name</code>—查看给定键距离过期时间还有多少毫秒（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIRE</code></td>
<td><code>PEXPIRE key-name milliseconds</code>—让给定键在指定的毫秒数之后过期（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIREAT</code></td>
<td><code>PEXPIREAT key-name timestamp-milliseconds</code>—将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
</tbody>
</table>
</div>
<p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。</strong></p>
<h3 id="过期检查"><a href="#过期检查" class="headerlink" title="过期检查"></a>过期检查</h3><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/redis-expired-dictionary.png" alt="redis过期字典"></p>
<h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>对Key的删除：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>Redis采用的是定期删除+惰性/懒汉式删除</p>
<p>惰性删除：在访问或者修改key之前，检查key是否过期</p>
<p>定期删除：从过期字典中随机抽取20个Key，检查这20个Key是否过期，并删除已过期的key。如果已过期的key超过25%，则继续重复抽取20个Key，继续循环。</p>
<h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。00</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://MingYRY.github.io">Wenyu Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mingyry.github.io/mingyry/bae4ff13.html">https://mingyry.github.io/mingyry/bae4ff13.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://MingYRY.github.io" target="_blank">明月依然的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Redis-Logo.wine.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mingyry/d1df8b0a.html" title="Maven3.1"><img class="cover" src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/u=2880868162,2691535896&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2F404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Maven3.1</div></div></a></div><div class="next-post pull-right"><a href="/mingyry/238ee950.html" title="网络技术之 CDN"><img class="cover" src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/tcp-86029986.jpg" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2F404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网络技术之 CDN</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mingyry/37cf2cfd.html" title="Redis集群"><img class="cover" src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/Redis-Logo.wine.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-08-14</div><div class="title">Redis集群</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">1.1.</span> <span class="toc-text">为什么要使用Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.1.</span> <span class="toc-text">Redis和Memcached的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">不同点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">缓存读写策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%88Cache-Aside-Pattern%EF%BC%89"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">旁路缓存模式（Cache Aside Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">该模式的缺点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%E6%A8%A1%E5%BC%8F%EF%BC%88Read-Write-Through-Pattern%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">读写穿透模式（Read&#x2F;Write Through Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Write-Behind-Pattern%EF%BC%89"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">异步缓存写入模式（Write Behind Pattern）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础数据结构详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.2.</span> <span class="toc-text">String字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">List列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">Set集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E6%95%A3%E5%88%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">Hash散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">1.2.6.</span> <span class="toc-text">Zset有序集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3种特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLogs%EF%BC%88%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">HyperLogLogs（基数统计）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%EF%BC%88%E4%BD%8D%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">Bitmap （位存储）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">geospatial (地理位置)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#geoadd"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">geoadd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#geopos"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">geopos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#geodist"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">geodist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#georadius"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">georadius</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#georadiusbymember"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">georadiusbymember</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#geohash-%E8%BE%83%E5%B0%91%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">geohash(较少使用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">底层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">Stream数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Stream详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">Stream的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">独立消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%BB%84%E6%B6%88%E8%B4%B9"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">消费组消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%9B%91%E6%8E%A7"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">信息监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">Stream深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.4.7.1.</span> <span class="toc-text">Stream用在什么样场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AFID%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.4.7.2.</span> <span class="toc-text">消息ID的设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.4.7.3.</span> <span class="toc-text">消息丢失问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%BD%BB%E5%BA%95%E5%AE%95%E6%9C%BA%E5%90%8E%E5%A6%82%E4%BD%95%E8%BD%AC%E7%A7%BB%E7%BB%99%E5%85%B6%E5%AE%83%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%84%E7%90%86"><span class="toc-number">1.3.4.7.4.</span> <span class="toc-text">消费者彻底宕机后如何转移给其它消费者处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dead-Letter%EF%BC%8C%E6%AD%BB%E4%BF%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.4.7.5.</span> <span class="toc-text">Dead Letter，死信问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">Redis底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">对象机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">redisObject数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">命令的类型检查和多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">对象共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B6%88%E6%AF%81"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">引用计数以及对象的消毁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-sds"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">简单动态字符串 - sds</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8SDS"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">为什么使用SDS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-ZipList"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">压缩列表 - ZipList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Entry%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">Entry结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ZipList%E7%89%B9%E5%88%AB%E7%9C%81%E5%86%85%E5%AD%98"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">为什么ZipList特别省内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ziplist%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.2.3.</span> <span class="toc-text">ziplist的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8-QuickList"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">快表 - QuickList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#quicklist%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">quicklist内存布局图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-%E5%93%88%E5%B8%8C%E8%A1%A8-Dict"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">字典&#x2F;哈希表 - Dict</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%A6%81%E7%82%B9"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">一些要点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86-IntSet"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">整数集 - IntSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#intset%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.5.1.</span> <span class="toc-text">intset结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE"><span class="toc-number">1.4.2.5.2.</span> <span class="toc-text">内存布局图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8-ZSkipList"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">跳表 - ZSkipList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">Redis内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.1.</span> <span class="toc-text">设置过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%A3%80%E6%9F%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">过期检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">内存淘汰机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">1.6.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fwallhaven-5g7rd3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Wenyu Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://MingYRY.github.io/">blog</a>!</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo"/></a><a class="github-badge" target="_blank" href="https://demo.jerryc.me/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题版本Butterfly"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由Gtihub托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px"><img src="https://img.shields.io/badge/%E9%BB%91ICP%E5%A4%87-2023004985%E5%8F%B7-lightgrey" title="本站已在工信部备案"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'JnVNUuheue1XlmfbyvgSY1Oe-gzGzoHsz',
      appKey: 'bVRKDRonMGGQ5U4Me0xmipvT',
      placeholder: '欢迎在博客中留言！ 1.昵称输入QQ号可以自动识别头像和QQ邮箱 2.博客留言中昵称和email必须填写 3.欢迎留下网址方便互相回访',
      avatar: 'monsterid',
      serverURLs: 'https://jnvnuuhe.lc-cn-n1-shared.com',
      emojiMaps: "",
      pageSize: '10',
      master: '3451cd11a28a25de7691d4d856b929d3',   //博主邮箱md5加密32位小写
      tagMeta: ["博主", "小伙伴", "访客"],     //标识字段名
      friends: ['b412f37e42d89e15c8aaf065934eb62e'],  //小伙伴邮箱Md5
      enableQQ: true,
      lang: 'zh-CN',
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="1384026889" data-server="netease" data-type="song" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://unpkg.com/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="乐观,健康,积极,自由,暴富,增肌,APEX" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://unpkg.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/aplayer/dist/APlayer.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://unpkg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4015716_msa9w6uaxn.js"></script><!-- hexo injector body_end end --></body></html>