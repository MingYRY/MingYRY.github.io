<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式调度 | 明月依然的小站</title><meta name="author" content="Wenyu Yu"><meta name="copyright" content="Wenyu Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分布式调度分布式ID为什么需要全局唯一ID传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT&#x3D;1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。 ID过于明显的问题 安全性问题，容易被暴力破解，并且根据i">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式调度">
<meta property="og:url" content="https://mingyry.github.io/mingyry/74281dcb.html">
<meta property="og:site_name" content="明月依然的小站">
<meta property="og:description" content="分布式调度分布式ID为什么需要全局唯一ID传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT&#x3D;1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。 ID过于明显的问题 安全性问题，容易被暴力破解，并且根据i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg">
<meta property="article:published_time" content="2023-07-01T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-14T13:06:13.671Z">
<meta property="article:author" content="Wenyu Yu">
<meta property="article:tag" content="分布式调度">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg"><link rel="shortcut icon" href="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fwallhaven-85keej.png"><link rel="canonical" href="https://mingyry.github.io/mingyry/74281dcb.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?00e91e237345a7bf551803ef3d797bde";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式调度',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-14 21:06:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fluffy.png" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Ffriend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="明月依然的小站"><span class="site-name">明月依然的小站</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分布式调度</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">更新于</span><time datetime="2023-08-14T13:06:13.671Z" title="更新于 2023-08-14 21:06:13">2023-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分布式调度"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="分布式调度"><a href="#分布式调度" class="headerlink" title="分布式调度"></a>分布式调度</h1><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><h3 id="为什么需要全局唯一ID"><a href="#为什么需要全局唯一ID" class="headerlink" title="为什么需要全局唯一ID"></a>为什么需要全局唯一ID</h3><p>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT=1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。</p>
<h3 id="ID过于明显的问题"><a href="#ID过于明显的问题" class="headerlink" title="ID过于明显的问题"></a>ID过于明显的问题</h3><ol>
<li><strong>安全性问题</strong>，容易被暴力破解，并且根据id规律推断其他用户的id</li>
<li><strong>隐私泄露风险</strong></li>
<li><strong>数据可预测性</strong>，能够轻易的猜测订单或者交易的信息，并且推断交易数目</li>
<li><strong>扩展性受限</strong>，可能会导致多个操作同时对同一资源进行竞争，从而增加冲突和性能瓶颈</li>
<li><strong>维护困难</strong>，需要额外的资源和机制来保证规律的更新和变化</li>
</ol>
<p>阿里巴巴《Java 开发手册》提出单表行数超过500万行或者单表容量超过 2GB 就需要考虑分库分表了</p>
<p>解决上述问题，就需要使用分布式ID（也称全局唯一ID），满足以下特点：</p>
<ol>
<li><strong>全局唯一性：</strong>保证在整个分布式系统中唯一性，不会出现重复的标识符</li>
<li><strong>高可用性：</strong>可以通过水平扩展、冗余备份或集群部署来确保服务的可用性</li>
<li><strong>安全性：</strong>独立于应用程序和业务逻辑，被设计为一个单独的组件或服务</li>
<li><strong>高性能：</strong>要求在很短的时间内生成唯一的标识符，采用高效的算法和数据结构，以及优化的网络通信和存储策略。</li>
<li><strong>递增性：</strong>设计成可按时间顺序排序，以便更容易对生成的ID进行索引、检索或排序操作。这对于一些场景，如日志记录和事件溯源等，非常重要。</li>
</ol>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p><code>UUID （Universally Unique Identifier）</code>，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 <code>16^32=2^128</code>，约等于 <code>3.4 x 10^38</code>。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>
<p>生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符’ - ‘，一般我们使用的时候会将连字符删除 uuid.<code>toString().replaceAll(&quot;-&quot;,&quot;&quot;)</code>。</p>
<p>目前UUID的产生方式有5种版本，每个版本的算法不同，应用范围也不同。</p>
<ul>
<li><code>基于时间的UUID</code> - 版本1： 这个一般是通过当前时间，随机数，和本地Mac地址来计算出来，可以通过 org.apache.logging.log4j.core.util包中的 UuidUtil.getTimeBasedUuid()来使用或者其他包中工具。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好。</li>
<li><code>DCE安全的UUID</code> - 版本2 DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</li>
<li><code>基于名字的UUID（MD5）</code>- 版本3 基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</li>
<li><code>随机UUID</code> - 版本4 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本。</li>
<li><code>基于名字的UUID（SHA1）</code> - 版本5 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</li>
</ul>
<p>我们 Java中 JDK自带的 UUID产生方式就是版本4根据随机数生成的 UUID 和版本3基于名字的 UUID，有兴趣的可以去看看它的源码。</p>
<p><strong>虽然 UUID 生成方便，本地生成没有网络消耗，但是使用起来也有一些缺点</strong>：</p>
<ul>
<li><strong>不易于存储</strong>：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li>
<li><strong>信息不安全</strong>：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，暴露使用者的位置。</li>
<li><strong>对MySQL索引不利</strong>：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能，可以查阅 Mysql 索引原理 B+树的知识。</li>
</ul>
<h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>是不是一定要基于外界的条件才能满足分布式唯一ID的需求呢，我们能不能在我们分布式数据库的基础上获取我们需要的ID？</p>
<p>由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。</p>
<p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增。</p>
<ul>
<li><code>auto_increment_offset</code>：表示自增长字段从那个数开始，他的取值范围是1 .. 65535。</li>
<li><code>auto_increment_increment</code>：表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535。</li>
</ul>
<p>假设有三台机器，则DB1中order表的起始ID值为1，DB2中order表的起始值为2，DB3中order表的起始值为3，它们自增的步长都为3，则它们的ID生成范围如下图所示：</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-id-2.png" alt="img"></p>
<p>通过这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。</p>
<p>但是缺点也很明显，首先它<strong>强依赖DB</strong>，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是<strong>数据一致性在特殊情况下难以保证</strong>。主从切换时的不一致可能会导致重复发号。还有就是<strong>ID发号性能瓶颈限制在单台MySQL的读写性能</strong>。</p>
<h3 id="使用Redis实现"><a href="#使用Redis实现" class="headerlink" title="使用Redis实现"></a>使用Redis实现</h3><p>Redis实现分布式唯一ID主要是通过提供像 <code>INCR</code> 和 <code>INCRBY</code> 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。</p>
<p>但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。</p>
<p>为了避免<strong>长期自增后数字过大可以通过与当前时间戳组合起来使用</strong>，另外为了保证并发和业务多线程的问题可以采用 Redis + Lua的方式进行编码，保证安全。</p>
<p><strong>Redis使用：时间戳+序列号+数据库自增</strong></p>
<p>Redis 实现分布式全局唯一ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于redis，<strong>需要系统引进redis组件，增加了系统的配置复杂性</strong>。</p>
<p>当然现在Redis的使用性很普遍，所以如果其他业务已经引进了Redis集群，则可以资源利用考虑使用Redis来实现。</p>
<h3 id="雪花算法-Snowflake"><a href="#雪花算法-Snowflake" class="headerlink" title="雪花算法-Snowflake"></a>雪花算法-Snowflake</h3><p>Snowflake，雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的。</p>
<p><strong>第1位</strong>占用1bit，其值始终是0，可看做是符号位不使用。</p>
<p><strong>第2位</strong>开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是<code>(1L&lt;&lt;41)/(1000L360024*365)</code>=69 年的时间。</p>
<p><strong>中间的10-bit位</strong>可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。</p>
<p><strong>最后12-bit位</strong>是自增序列，可表示2^12 = 4096个数。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-id-3.png" alt="img"></p>
<p><strong>雪花算法提供了一个很好的设计思想，雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活</strong>。</p>
<p>但是雪花算法强<strong>依赖机器时钟</strong>，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。官方对于此并没有给出解决方案，而是简单的抛错处理，这样会造成在时间被追回之前的这段时间服务不可用。</p>
<p>很多其他类雪花算法也是在此思想上的设计然后改进规避它的缺陷，后面介绍的<code>百度 UidGenerator</code> 和 <code>美团分布式ID生成系统 Leaf</code> 中snowflake模式都是在 snowflake 的基础上演进出来的。</p>
<h3 id="Mist-薄雾算法"><a href="#Mist-薄雾算法" class="headerlink" title="Mist 薄雾算法"></a>Mist 薄雾算法</h3><blockquote>
<p>如下内容摘自 <a target="_blank" rel="noopener" href="https://github.com/asyncins/mist/tree/master">GitHub中项目README</a></p>
</blockquote>
<p>薄雾算法是不同于 snowflake 的全局唯一 ID 生成算法。相比 snowflake ，薄雾算法具有更高的数值上限和更长的使用期限。</p>
<h4 id="薄雾算法的设计思路是怎么样的？"><a href="#薄雾算法的设计思路是怎么样的？" class="headerlink" title="薄雾算法的设计思路是怎么样的？"></a>薄雾算法的设计思路是怎么样的？</h4><p>薄雾算法采用了与 snowflake 相同的位数——64，在考量业务场景和要求后并没有沿用 1-41-10-12 的占位，而是采用了 1-47-8-8 的占位。即：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 1      2                                                     48         56       64</span><br><span class="line">* +------+-----------------------------------------------------+----------+----------+</span><br><span class="line">* retain | increas                                             | salt     | salt |</span><br><span class="line">* +------+-----------------------------------------------------+----------+----------+</span><br><span class="line">* 0      | 0000000000 0000000000 0000000000 0000000000 0000000 | 00000000 | 00000000 |</span><br><span class="line">* +------+-----------------------------------------------------+------------+--------+</span><br></pre></td></tr></table></figure>
<ul>
<li>第一段为最高位，占 1 位，保持为 0，使得值永远为正数；</li>
<li>第二段放置自增数，占 47 位，自增数在高位能保证结果值呈递增态势，遂低位可以为所欲为；</li>
<li>第三段放置随机因子一，占 8 位，上限数值 255，使结果值不可预测；</li>
<li>第四段放置随机因子二，占 8 位，上限数值 255，使结果值不可预测；</li>
</ul>
<h4 id="薄雾算法生成的数值是什么样的？"><a href="#薄雾算法生成的数值是什么样的？" class="headerlink" title="薄雾算法生成的数值是什么样的？"></a>薄雾算法生成的数值是什么样的？</h4><p>薄雾自增数为 1～10 的运行结果类似如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">171671</span><br><span class="line">250611</span><br><span class="line">263582</span><br><span class="line">355598</span><br><span class="line">427749</span><br><span class="line">482010</span><br><span class="line">581550</span><br><span class="line">644278</span><br><span class="line">698636</span><br><span class="line">762474</span><br></pre></td></tr></table></figure>
<p>根据运行结果可知，薄雾算法能够满足“全局不重复，不可猜测且呈递增态势”的场景要求。</p>
<h4 id="为什么薄雾算法不受时间回拨影响？"><a href="#为什么薄雾算法不受时间回拨影响？" class="headerlink" title="为什么薄雾算法不受时间回拨影响？"></a>为什么薄雾算法不受时间回拨影响？</h4><p>snowflake 受时间回拨影响的根本原因是高位采用时间戳的二进制值，而薄雾算法的高位是按序递增的数值。结果值的大小由高位决定，遂薄雾算法不受时间回拨影响。</p>
<h4 id="为什么说薄雾算法的结果值不可预测？"><a href="#为什么说薄雾算法的结果值不可预测？" class="headerlink" title="为什么说薄雾算法的结果值不可预测？"></a>为什么说薄雾算法的结果值不可预测？</h4><p>考虑到“不可预测”的要求，薄雾算法的中间位是 8 位随机值，且末 8 位是也是随机值，两组随机值大大增加了预测难度，因此称为结果值不可预测。</p>
<p>中间位和末位随机值的开闭区间都是 [0, 255]，理论上随机值可以出现 <code>256 * 256</code> 种组合。</p>
<h4 id="当程序重启，薄雾算法的值会重复吗？"><a href="#当程序重启，薄雾算法的值会重复吗？" class="headerlink" title="当程序重启，薄雾算法的值会重复吗？"></a>当程序重启，薄雾算法的值会重复吗？</h4><p>snowflake 受时间回拨影响，一旦时间回拨就有极大概率生成重复的 ID。薄雾算法中的高位是按序递增的数值，程序重启会造成按序递增数值回到初始值，但由于中间位和末尾随机值的影响，因此不是必定生成（有大概率生成）重复 ID，但递增态势必定受到影响。</p>
<h4 id="薄雾算法的值会重复，那我要它干嘛？"><a href="#薄雾算法的值会重复，那我要它干嘛？" class="headerlink" title="薄雾算法的值会重复，那我要它干嘛？"></a>薄雾算法的值会重复，那我要它干嘛？</h4><p>1、无论是什么样的全局唯一 ID 生成算法，都会有优点和缺点。在实际的应用当中，没有人会将全局唯一 ID 生成算法完全托付给程序，而是会用数据库存储关键值或者所有生成的值。全局唯一 ID 生成算法大多都采用分布式架构或者主备架构提供发号服务，这时候就不用担心它的重复问题；</p>
<p>2、生成性能比雪花算法高太多倍；</p>
<p>3、代码少且简单，在大型应用中，单功能越简单越好；</p>
<h4 id="是否提供薄雾算法的工程实践或者架构实践？"><a href="#是否提供薄雾算法的工程实践或者架构实践？" class="headerlink" title="是否提供薄雾算法的工程实践或者架构实践？"></a>是否提供薄雾算法的工程实践或者架构实践？</h4><p>是的，作者的另一个项目 <a target="_blank" rel="noopener" href="https://github.com/asyncins/medis">Medis</a> 是薄雾算法与 Redis 的结合，实现了“全局不重复”，你再也不用担心程序重启带来的问题。</p>
<h4 id="薄雾算法的分布式架构，推荐-CP-还是-AP？"><a href="#薄雾算法的分布式架构，推荐-CP-还是-AP？" class="headerlink" title="薄雾算法的分布式架构，推荐 CP 还是 AP？"></a>薄雾算法的分布式架构，推荐 CP 还是 AP？</h4><p>CAP 是分布式架构中最重要的理论，C 指的是一致性、A 指的是可用性、P 指的是分区容错性。CAP 当中，C 和 A 是互相冲突的，且 P 一定存在，遂我们必须在 CP 和 AP 中选择。<strong>实际上这跟具体的业务需求有关</strong>，但是对于全局唯一 ID 发号服务来说，大多数时候可用性比一致性更重要，也就是选择 AP 会多过选择 CP。至于你怎么选，还是得结合具体的业务场景考虑。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上基本列出了所有常用的分布式ID生成方式，其实大致分类的话可以分为两类：</p>
<ul>
<li><strong>一种是类DB型的</strong>，根据设置不同起始值和步长来实现趋势递增，需要考虑服务的容错性和可用性。</li>
<li><strong>另一种是类snowflake型</strong>，这种就是将64位划分为不同的段，每段代表不同的涵义，基本就是时间戳、机器ID和序列数。这种方案就是需要考虑时钟回拨的问题以及做一些 buffer的缓冲设计提高性能。</li>
</ul>
<p>而且可通过将三者（时间戳，机器ID，序列数）划分不同的位数来改变使用寿命和并发数。</p>
<p>例如对于并发数要求不高、期望长期使用的应用，可增加时间戳位数，减少序列数的位数. 例如配置成<code>&#123;&quot;workerBits&quot;:23,&quot;timeBits&quot;:31,&quot;seqBits&quot;:9&#125;</code>时, 可支持28个节点以整体并发量14400 UID/s的速度持续运行68年。</p>
<p>对于节点重启频率频繁、期望长期使用的应用, 可增加工作机器位数和时间戳位数, 减少序列数位数. 例如配置成<code>&#123;&quot;workerBits&quot;:27,&quot;timeBits&quot;:30,&quot;seqBits&quot;:6&#125;</code>时, 可支持37个节点以整体并发量2400 UID/s的速度持续运行34年。</p>
<h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><blockquote>
<p>Session + Cookie 会话方案比较简单，这里我在网上找了点资料，再回顾下基础吧。</p>
</blockquote>
<h4 id="为什么要产生Session"><a href="#为什么要产生Session" class="headerlink" title="为什么要产生Session"></a>为什么要产生Session</h4><p>http协议本身是无状态的，客户端只需要向服务器请求下载内容，客户端和服务器都不记录彼此的历史信息，每一次请求都是独立的。</p>
<p>为什么是无状态的呢？因为浏览器与服务器是使用socke套接字进行通信，服务器将请求结果返回给浏览器之后，会关闭当前的socket链接，而且服务器也会在处理页面完毕之后销毁页面对象。</p>
<p>然而在Web应用的很多场景下需要维护用户状态才能正常工作(是否登录等)，或者说提供便捷(记住密码，浏览历史等)，状态的保持就是一个很重要的功能。因此在web应用开发里就出现了保持http链接状态的技术：一个是cookie技术，另一种是session技术。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p>
<h4 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h4><p>Cookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。</p>
<p>一个简单的 cookie 设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br><span class="line">HTTP/2.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<h4 id="Cookie-的工作步骤"><a href="#Cookie-的工作步骤" class="headerlink" title="Cookie 的工作步骤"></a>Cookie 的工作步骤</h4><ol>
<li>浏览器请求服务器，如果服务器需要记录该用户的状态，就是用 response 向浏览器颁发一个 Cookie。</li>
<li>浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<h4 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h4><p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。\</em></strong></p>
<h4 id="Cookie-的重要属性"><a href="#Cookie-的重要属性" class="headerlink" title="Cookie 的重要属性"></a>Cookie 的重要属性</h4><div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>name=value</strong></td>
<td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td>
</tr>
<tr>
<td><strong>domain</strong></td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td><strong>path</strong></td>
<td><strong>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong>。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td>
</tr>
<tr>
<td><strong>maxAge</strong></td>
<td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td>
</tr>
<tr>
<td><strong>expires</strong></td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td>
</tr>
<tr>
<td><strong>secure</strong></td>
<td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td>
</tr>
<tr>
<td><strong>httpOnly</strong></td>
<td><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h4><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<ul>
<li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li>
<li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li>
</ul>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/16f523a04d0b3cf5~tplv-t2oaga2asx-watermark.awebp" alt="session.png"></p>
<h4 id="Session-的工作步骤"><a href="#Session-的工作步骤" class="headerlink" title="Session 的工作步骤"></a>Session 的工作步骤</h4><ol>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ol>
<p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>
<h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p>Cookie 和 Session 的主要区别可以参考以下表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用范围</strong></td>
<td>保存在客户端（浏览器）</td>
<td>保存在服务器端</td>
</tr>
<tr>
<td><strong>隐私策略</strong></td>
<td>存储在客户端，比较容易遭到非法获取</td>
<td>存储在服务端，安全性相对 Cookie 要好一些</td>
</tr>
<tr>
<td><strong>存储方式</strong></td>
<td>只能保存 ASCII</td>
<td>可以保存任意数据类型。 一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</td>
</tr>
<tr>
<td><strong>存储大小</strong></td>
<td>不能超过 4K</td>
<td>存储大小远高于 Cookie</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可设置为永久保存 比如我们经常使用的默认登录（记住我）功能</td>
<td>一般失效时间较短 客户端关闭或者 Session 超时都会失效。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="如果禁用-Cookie-怎么办"><a href="#如果禁用-Cookie-怎么办" class="headerlink" title="如果禁用 Cookie 怎么办"></a>如果禁用 Cookie 怎么办</h3><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p>
<p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<p>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p>
<p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p>
<h3 id="会话技术的发展"><a href="#会话技术的发展" class="headerlink" title="会话技术的发展"></a>会话技术的发展</h3><blockquote>
<p>会话技术的发展?</p>
</blockquote>
<ul>
<li>单机 - Session + Cookie</li>
<li>多机器 <ul>
<li>在负载均衡侧 - Session 粘滞</li>
<li>Session数据同步</li>
</ul>
</li>
<li>多机器，集群 - session集中管理，比如redis；目前方案上用的最多的是Spring Session，早前也有用tomcat集成方式的。</li>
<li>无状态token，比如JWT</li>
</ul>
<h3 id="分布式会话的方案"><a href="#分布式会话的方案" class="headerlink" title="分布式会话的方案"></a>分布式会话的方案</h3><h4 id="Session-Stick"><a href="#Session-Stick" class="headerlink" title="Session Stick"></a>Session Stick</h4><blockquote>
<p>粘性 Session（Sticky Sessions）<strong>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上</strong>，这样就可以把用户的 Session 存放在该服务器节点中。</p>
</blockquote>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-2.png" alt="img"></p>
<p>这种方案实现比较简单，对于Web服务器来说和单机的情况一样。但是可能会带来如下问题：</p>
<ul>
<li>如果有一台服务器宕机或者重启，那么这台机器上的会话数据会全部丢失。</li>
<li>会话标识是应用层信息，那么负载均衡要将同一个会话的请求都保存到同一个Web服务器上的话，就需要进行应用层（第7层）的解析，这个开销比第4层大。</li>
<li>负载均衡器将变成一个有状态的节点，要将会话保存到具体Web服务器的映射。和无状态节点相比，内存消耗更大，容灾方面也会更麻烦。</li>
</ul>
<h4 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h4><p>Session Replication 的方案则不对负载均衡器做更改，而是在Web服务器之间增加了会话数据同步的功能，各个服务器之间通过同步保证不同Web服务器之间的Session数据的一致性，如下图所示。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-2.png" alt="img"></p>
<p>Session Replication 方案对负载均衡器不再有要求，但是同样会带来以下问题：</p>
<ul>
<li>同步Session数据会造成额外的网络带宽的开销，只要Session数据有变化，就需要将新产生的Session数据同步到其他服务器上，服务器数量越多，同步带来的网络带宽开销也就越大。</li>
<li>每台Web服务器都需要保存全部的Session数据，如果整个集群的Session数量太多的话，则对于每台机器用于保存Session数据的占用会很严重。</li>
</ul>
<h4 id="Session-数据集中存储"><a href="#Session-数据集中存储" class="headerlink" title="Session 数据集中存储"></a>Session 数据集中存储</h4><p>Session 数据集中存储方案则是将集群中的所有Session集中存储起来，Web服务器本身则并不存储Session数据，不同的Web服务器从同样的地方来获取Session，如下图所示。</p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/arch-z-session-3.png" alt="img"></p>
<p>相对于Session Replication方案，此方案的Session数据将不保存在本机，并且Web服务器之间也没有了Session数据的复制，但是该方案存在的问题在于：</p>
<ul>
<li>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，但是通信发生在内网，则问题不大。</li>
<li>如果集中存储Session的机器或集群出现问题，则会影响应用。</li>
</ul>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>JSON Web Token，一般用它来替换掉Session实现数据共享。</p>
<p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ul>
<li>1、客户端通过用户名和密码登录服务器；</li>
<li>2、服务端对客户端身份进行验证；</li>
<li>3、服务端对该用户生成Token，返回给客户端；</li>
<li>4、客户端将Token保存到本地浏览器，一般保存到cookie中；</li>
<li>5、客户端发起请求，需要携带该Token；</li>
<li>6、服务端收到请求后，首先验证Token，之后返回数据。</li>
</ul>
<h3 id="JWT-Token"><a href="#JWT-Token" class="headerlink" title="JWT Token"></a>JWT Token</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>
<h3 id="Spring-session-redis"><a href="#Spring-session-redis" class="headerlink" title="Spring session + redis"></a>Spring session + redis</h3><p>上面那种 tomcat + redis 的方式好用，但是会<strong>严重依赖于 web 容器</strong>，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？</p>
<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fspring-session">sping session</a> 是一个很好的选择。</p>
<p>spring session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring session 从 redis 中获取数据了</p>
<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><h3 id="定时任务和分布式任务介绍"><a href="#定时任务和分布式任务介绍" class="headerlink" title="定时任务和分布式任务介绍"></a>定时任务和分布式任务介绍</h3><h4 id="定时任务应用场景"><a href="#定时任务应用场景" class="headerlink" title="定时任务应用场景"></a>定时任务应用场景</h4><p>比如每天/每周/每月生成日志汇总，定时发送推送信息，定时生成数据表格等</p>
<h4 id="定时任务的基础"><a href="#定时任务的基础" class="headerlink" title="定时任务的基础"></a>定时任务的基础</h4><blockquote>
<p>Cron表达式是定时任务的基础。Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：</p>
</blockquote>
<ul>
<li>Seconds Minutes Hours DayofMonth Month DayofWeek Year</li>
<li>Seconds Minutes Hours DayofMonth Month DayofWeek</li>
</ul>
<h4 id="单体应用定时任务的演化"><a href="#单体应用定时任务的演化" class="headerlink" title="单体应用定时任务的演化"></a>单体应用定时任务的演化</h4><h5 id="cron-脚本定时任务"><a href="#cron-脚本定时任务" class="headerlink" title="cron+脚本定时任务"></a>cron+脚本定时任务</h5><p>Linux定时任务工具crontb</p>
<h5 id="JDK内置之Timer"><a href="#JDK内置之Timer" class="headerlink" title="JDK内置之Timer"></a>JDK内置之Timer</h5><p>JDK内置的Timer, 现在很少被使用。</p>
<blockquote>
<p>为什么几乎很少使用Timer这种方式？</p>
<p>Timer底层是使用一个单线来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。</p>
<p>如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。</p>
</blockquote>
<h5 id="JDK内置之ScheduleExecutorService"><a href="#JDK内置之ScheduleExecutorService" class="headerlink" title="JDK内置之ScheduleExecutorService"></a>JDK内置之ScheduleExecutorService</h5><p>ScheduledExecutorService是基于线程池的实现方式。</p>
<blockquote>
<p><strong>为什么用ScheduledExecutorService 代替 Timer</strong>？</p>
<p>上文我们说到Timer底层是使用一个单线程来实现多个Timer任务处理的，所有任务都是由同一个线程来调度，所有任务都是串行执行，意味着同一时间只能有一个任务得到执行，而前一个任务的延迟或者异常会影响到之后的任务。</p>
<p>如果有一个定时任务在运行时，产生未处理的异常，那么当前这个线程就会停止，那么所有的定时任务都会停止，受到影响。</p>
<p>而ScheduledExecutorService是基于线程池的，可以开启多个线程进行执行多个任务，每个任务开启一个线程； 这样任务的延迟和未处理异常就不会影响其它任务的执行了</p>
</blockquote>
<h5 id="Netty之HashedWheelTimer"><a href="#Netty之HashedWheelTimer" class="headerlink" title="Netty之HashedWheelTimer"></a>Netty之HashedWheelTimer</h5><ul>
<li><strong>Netty的HashedWheelTimer要解决什么问题</strong></li>
</ul>
<p>在Netty中的一个典型应用场景是判断某个连接是否idle，如果idle（如客户端由于网络原因导致到服务器的心跳无法送达），则服务器会主动断开连接，释放资源。判断连接是否idle是通过定时任务完成的，但是Netty可能维持数百万级别的长连接，对每个连接去定义一个定时任务是不可行的，所以如何提升I/O超时调度的效率呢？</p>
<p>Netty根据时间轮(Timing Wheel)开发了HashedWheelTimer工具类，用来优化I/O超时调度(本质上是延迟任务）；之所以采用时间轮(Timing Wheel)的结构还有一个很重要的原因是I/O超时这种类型的任务对时效性不需要非常精准。</p>
<ul>
<li><strong>HashedWheelTimer的使用方式</strong></li>
</ul>
<p>通过构造函数看主要参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashedWheelTimer</span><span class="params">(</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> tickDuration, TimeUnit unit, <span class="type">int</span> ticksPerWheel, <span class="type">boolean</span> leakDetection,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> maxPendingTimeouts, Executor taskExecutor)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体参数说明如下：</p>
<ul>
<li><code>threadFactory</code>：线程工厂，用于创建工作线程， 默认是Executors.defaultThreadFactory()</li>
<li><code>tickDuration</code>：tick的周期，即多久tick一次</li>
<li><code>unit</code>: tick周期的单位</li>
<li><code>ticksPerWheel</code>：时间轮的长度，一圈下来有多少格</li>
<li><code>leakDetection</code>：是否开启内存泄漏检测，默认是true</li>
<li><code>maxPendingTimeouts</code>：最多执行的任务数，默认是-1，即不限制。在高并发量情况下才会设置这个参数。</li>
</ul>
<h5 id="Spring-Tasks"><a href="#Spring-Tasks" class="headerlink" title="Spring Tasks"></a>Spring Tasks</h5><p>Spring提供的schedule任务</p>
<p>具体使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔1分钟执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 1000 * 60 * 1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runScheduleFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;runScheduleFixedRate: current DateTime, &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个整点小时执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 */1 * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runScheduleCron</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;runScheduleCron: current DateTime, &#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>@Scheduled所支持的参数</strong>：</li>
</ul>
<ol>
<li><code>cron</code>：cron表达式，指定任务在特定时间执行；</li>
<li><code>fixedDelay</code>：表示上一次任务执行完成后多久再次执行，参数类型为long，单位ms；</li>
<li><code>fixedDelayString</code>：与fixedDelay含义一样，只是参数类型变为String；</li>
<li><code>fixedRate</code>：表示按一定的频率执行任务，参数类型为long，单位ms；</li>
<li><code>fixedRateString</code>: 与fixedRate的含义一样，只是将参数类型变为String；</li>
<li><code>initialDelay</code>：表示延迟多久再第一次执行任务，参数类型为long，单位ms；</li>
<li><code>initialDelayString</code>：与initialDelay的含义一样，只是将参数类型变为String；</li>
<li><code>zone</code>：时区，默认为当前时区，一般没有用到。</li>
</ol>
<h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p>
<p><strong>它的特点如下</strong></p>
<ul>
<li>纯java实现，可以作为独立的应用程序，也可以嵌入在另一个独立式应用程序运行</li>
<li>强大的调度功能，Spring默认的调度框架，灵活可配置；</li>
<li>作业持久化，调度环境持久化机制，可以保存并恢复调度现场。系统关闭数据不会丢失；灵活的应用方式，可以任意定义触发器的调度时间表，支持任务和调度各种组合，组件式监听器、各种插件、线程池等功能，多种存储方式等；</li>
<li>分布式和集群能力，可以被实例化，一个Quartz集群中的每个节点作为一个独立的Quartz使用，通过相同的数据库表来感知到另一个Quartz应用</li>
</ul>
<p><strong>Quartz的体系结构</strong></p>
<p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/springboot-job-quartz-1.png" alt="img"></p>
<p> 上图来源于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jijm123/p/14240320.html">https://www.cnblogs.com/jijm123/p/14240320.html</a></p>
<ul>
<li><strong>Job</strong> 表示一个工作，要执行的具体内容。</li>
<li><strong>JobDetail</strong> 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。</li>
<li><strong>Trigger</strong> 代表一个调度参数的配置，什么时候去调。</li>
<li><strong>Scheduler</strong> 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</li>
</ul>
<h3 id="分布式任务的方案"><a href="#分布式任务的方案" class="headerlink" title="分布式任务的方案"></a>分布式任务的方案</h3><blockquote>
<p>常见的分布式任务的方案有：Quartz Cluster，XXL-Job，Elastic-Job等。</p>
<ol>
<li>如果仅是小团队内部自用，可以采用XXL-Job</li>
<li>如果是稍大一点的团队，建议使用ElasticJob或者基于ElasticJob进行二次开发</li>
</ol>
</blockquote>
<h4 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h4><blockquote>
<p>XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。<a target="_blank" rel="noopener" href="https://www.xuxueli.com/xxl-job/">xxl-job官网</a></p>
</blockquote>
<h5 id="xxl-job的架构设计"><a href="#xxl-job的架构设计" class="headerlink" title="xxl-job的架构设计"></a>xxl-job的架构设计</h5><h6 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h6><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p>
<p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p>
<p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；</p>
<h6 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h6><ol>
<li>调度模块（调度中心）： <ol>
<li>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；</li>
<li>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li>
</ol>
</li>
<li>执行模块（执行器）： <ol>
<li>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；</li>
<li>接收“调度中心”的执行请求、终止请求和日志请求等。</li>
</ol>
</li>
</ol>
<h6 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h6><p><img src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/springboot-xxl-job-8.png" alt="img"></p>
<h4 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic-Job"></a>Elastic-Job</h4><blockquote>
<p>ElasticJob 是面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 ElasticJob-Lite 和 ElasticJob-Cloud 组成。 它通过弹性调度、资源管控、以及作业治理的功能，打造一个适用于互联网场景的分布式调度解决方案，并通过开放的架构设计，提供多元化的作业生态。 它的各个产品使用统一的作业 API，开发者仅需一次开发，即可随意部署。ElasticJob 已于 2020 年 5 月 28 日成为 Apache ShardingSphere 的子项目。</p>
</blockquote>
<p>使用 ElasticJob 能够让开发工程师不再担心任务的线性吞吐量提升等非功能需求，使他们能够更加专注于面向业务编码设计； 同时，它也能够解放运维工程师，使他们不必再担心任务的可用性和相关管理需求，只通过轻松的增加服务节点即可达到自动化运维的目的。</p>
<p><strong>ElasticJob-Lite</strong>: 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务。</p>
<p><strong>ElasticJob-Cloud</strong>： 采用自研 Mesos Framework 的解决方案，额外提供资源治理、应用分发以及进程隔离等功能。</p>
<p><strong>ElasticJob-Lite和ElasticJob-Cloud的区别</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>ElasticJob-Lite</th>
<th>ElasticJob-Cloud</th>
</tr>
</thead>
<tbody>
<tr>
<td>无中心化</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>资源分配</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>作业模式</td>
<td>常驻</td>
<td>常驻 + 瞬时</td>
</tr>
<tr>
<td>部署依赖</td>
<td>ZooKeeper</td>
<td>ZooKeeper + Mesos</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.nenggz.com/md/arch/arch-z-id.html">https://www.nenggz.com/md/arch/arch-z-id.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://MingYRY.github.io">Wenyu Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mingyry.github.io/mingyry/74281dcb.html">https://mingyry.github.io/mingyry/74281dcb.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://MingYRY.github.io" target="_blank">明月依然的小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6/">分布式调度</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mingyry/6f01c864.html" title="分布式协同"><img class="cover" src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2F404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式协同</div></div></a></div><div class="next-post pull-right"><a href="/mingyry/b0849f5d.html" title="分布式通信"><img class="cover" src="https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img/63126910.jpg" onerror="onerror=null;src='https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2F404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式通信</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">分布式调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FID"><span class="toc-number">1.1.</span> <span class="toc-text">分布式ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么需要全局唯一ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ID%E8%BF%87%E4%BA%8E%E6%98%8E%E6%98%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">ID过于明显的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UUID"><span class="toc-number">1.1.3.</span> <span class="toc-text">UUID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90"><span class="toc-number">1.1.4.</span> <span class="toc-text">数据库生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">使用Redis实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-Snowflake"><span class="toc-number">1.1.6.</span> <span class="toc-text">雪花算法-Snowflake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mist-%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.7.</span> <span class="toc-text">Mist 薄雾算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">薄雾算法的设计思路是怎么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">薄雾算法生成的数值是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E4%B8%8D%E5%8F%97%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">为什么薄雾算法不受时间回拨影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%9C%E5%80%BC%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%B5%8B%EF%BC%9F"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">为什么说薄雾算法的结果值不可预测？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E7%A8%8B%E5%BA%8F%E9%87%8D%E5%90%AF%EF%BC%8C%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%80%BC%E4%BC%9A%E9%87%8D%E5%A4%8D%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.7.5.</span> <span class="toc-text">当程序重启，薄雾算法的值会重复吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%80%BC%E4%BC%9A%E9%87%8D%E5%A4%8D%EF%BC%8C%E9%82%A3%E6%88%91%E8%A6%81%E5%AE%83%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="toc-number">1.1.7.6.</span> <span class="toc-text">薄雾算法的值会重复，那我要它干嘛？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%8F%90%E4%BE%9B%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%88%96%E8%80%85%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%EF%BC%9F"><span class="toc-number">1.1.7.7.</span> <span class="toc-text">是否提供薄雾算法的工程实践或者架构实践？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%84%E9%9B%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%8C%E6%8E%A8%E8%8D%90-CP-%E8%BF%98%E6%98%AF-AP%EF%BC%9F"><span class="toc-number">1.1.7.8.</span> <span class="toc-text">薄雾算法的分布式架构，推荐 CP 还是 AP？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.2.</span> <span class="toc-text">分布式会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BA%A7%E7%94%9FSession"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">为什么要产生Session</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">1.2.2.</span> <span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">什么是 Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Cookie 的工作步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Cookie 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Cookie 的重要属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-number">1.2.3.</span> <span class="toc-text">Session</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Session"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">什么是 Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Session 的工作步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E5%92%8C-Session-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">Cookie 和 Session 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%A6%81%E7%94%A8-Cookie-%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.2.5.</span> <span class="toc-text">如果禁用 Cookie 怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">会话技术的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.7.</span> <span class="toc-text">分布式会话的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Stick"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">Session Stick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-Replication"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">Session Replication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">Session 数据集中存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token"><span class="toc-number">1.2.8.</span> <span class="toc-text">Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-Token"><span class="toc-number">1.2.9.</span> <span class="toc-text">JWT Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-session-redis"><span class="toc-number">1.2.10.</span> <span class="toc-text">Spring session + redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">分布式任务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">定时任务和分布式任务介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">定时任务应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">定时任务的基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%BC%94%E5%8C%96"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">单体应用定时任务的演化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cron-%E8%84%9A%E6%9C%AC%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">cron+脚本定时任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E5%86%85%E7%BD%AE%E4%B9%8BTimer"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">JDK内置之Timer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E5%86%85%E7%BD%AE%E4%B9%8BScheduleExecutorService"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">JDK内置之ScheduleExecutorService</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Netty%E4%B9%8BHashedWheelTimer"><span class="toc-number">1.3.1.3.4.</span> <span class="toc-text">Netty之HashedWheelTimer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-Tasks"><span class="toc-number">1.3.1.3.5.</span> <span class="toc-text">Spring Tasks</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quartz"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">Quartz</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">分布式任务的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XXL-Job"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">XXL-Job</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#xxl-job%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">xxl-job的架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.2.1.1.1.</span> <span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-number">1.3.2.1.1.2.</span> <span class="toc-text">系统组成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.3.2.1.1.3.</span> <span class="toc-text">架构图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Elastic-Job"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Elastic-Job</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.4.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://blog-1317788176.cos.ap-nanjing.myqcloud.com/img%2Fwallhaven-5g7rd3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By Wenyu Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://MingYRY.github.io/">blog</a>!</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo"/></a><a class="github-badge" target="_blank" href="https://demo.jerryc.me/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题版本Butterfly"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由Gtihub托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/" style="margin-inline:5px"><img src="https://img.shields.io/badge/%E9%BB%91ICP%E5%A4%87-2023004985%E5%8F%B7--1-lightgrey" title="本站已在工信部备案"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'JnVNUuheue1XlmfbyvgSY1Oe-gzGzoHsz',
      appKey: 'bVRKDRonMGGQ5U4Me0xmipvT',
      placeholder: '欢迎在博客中留言！ 1.昵称输入QQ号可以自动识别头像和QQ邮箱 2.博客留言中昵称和email必须填写 3.欢迎留下网址方便互相回访',
      avatar: 'monsterid',
      serverURLs: 'https://jnvnuuhe.lc-cn-n1-shared.com',
      emojiMaps: "",
      pageSize: '10',
      master: '3451cd11a28a25de7691d4d856b929d3',   //博主邮箱md5加密32位小写
      tagMeta: ["博主", "小伙伴", "访客"],     //标识字段名
      friends: ['b412f37e42d89e15c8aaf065934eb62e'],  //小伙伴邮箱Md5
      enableQQ: true,
      lang: 'zh-CN',
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="1384026889" data-server="netease" data-type="song" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://unpkg.com/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="乐观,健康,积极,自由,暴富,增肌,APEX" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://unpkg.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/aplayer/dist/APlayer.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://unpkg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/c/font_4015716_msa9w6uaxn.js"></script><!-- hexo injector body_end end --></body></html>